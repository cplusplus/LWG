<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4510" status="New">
<title>Ambiguity of `std::ranges::advance` and `std::ranges::next` when the difference type is also a sentinel type</title>
<section><sref ref="[range.iter.op.advance]"/><sref ref="[range.iter.op.next]"/></section>
<submitter>Jiang An</submitter>
<date>09 Jan 2026</date>
<priority>3</priority>

<discussion>
<p>
Currently, `ranges::advance` and `ranges::next` have `operator()` overloads that accept 
`(iterator, sentinel)` and `(iterator, difference)`. However, when the difference type 
of the iterator is also a sentinel type, there may be ambiguity in both overloads.
<p/>
E.g. the following example is rejected when compiling with libc++ or libstdc++ 
(<a href="https://godbolt.org/z/z3rPEhjjs">demo</a>):
</p>
<blockquote><pre>
#include &lt;cstddef&gt;
#include &lt;iterator&gt;
#include &lt;type_traits&gt;

template&lt;class T&gt;
struct FwdIter { // triggers ADL for T
  FwdIter();

  using value_type      = std::remove_cv_t&lt;T&gt;;
  using difference_type = int;

  T&amp; operator*() const;

  FwdIter&amp; operator++();
  FwdIter operator++(int);

  friend bool operator==(const FwdIter&amp;, const FwdIter&amp;);
};

static_assert(std::forward_iterator&lt;FwdIter&lt;int&gt;&gt;);

struct OmniConv {
  OmniConv(const auto&amp;);
  friend bool operator==(OmniConv, OmniConv); // found by ADL via things related to OmniConv
};

int main() {
  FwdIter&lt;OmniConv&gt; it{};
  std::ranges::advance(it, 0); // ambiguous
  std::ranges::next(it, 0); // ambiguous
}
</pre></blockquote>
<p>
Perhaps it would be better to ensure that calling `ranges::advance` or `ranges::next` 
with an iterator value and a value of the difference type is unambiguous. Note that 
wrapping iterators that trigger ADL for the value type like the `FwdIter` in this example 
are common in standard library implementations, so ambiguity can be easily raised from 
containers with such `OmniConv` being their element type.
</p>

<note>2026-02-20; Reflector poll.</note>
<p>
Set priority to 3 after reflector poll.
</p>
<p>
The type in the example is basically a `std::any` that additionally type-erases
equality. That causes a problem for templated iterators that have their
value type's namespace as an associated namespace for ADL.
</p>
<p>
Instead of allowing integers to be sentinels in general but just restricting
them from being used with these overloads, we could just change the concept
so that integers do not model `sentinel_for`.
That's similar to what we did for `span`'s constructor which has a similar
problem (though that one's more aggressive due to compatibility constraints).
</p>

<superseded>
<p>
This wording is relative to <paper num="N5032"/>.
</p>

<ol>
<li><p>Modify <sref ref="[iterator.synopsis]"/>, header <tt>&lt;iterator&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
namespace std {
  template&lt;class T&gt; using <i>with-reference</i> = T&amp;; <i>// exposition only</i>
  template&lt;class T&gt; concept <i>can-reference</i>      <i>// exposition only</i>
    = requires { typename <i>with-reference</i>&lt;T&gt;; };
  template&lt;class T&gt; concept <i>dereferenceable</i>    <i>// exposition only</i>
    = requires(T&amp; t) {
      { *t } -&gt; <i>can-reference</i>; <i>// not required to be equality-preserving</i>
    };
  
  <ins>template&lt;class T&gt;
    constexpr bool <i>is-integer-like</i> = <i>see below</i>;           <i>// exposition only</i></ins>

  [&hellip;]
  <i>// <sref ref="[range.iter.ops]"/>, range iterator operations</i>
  namespace ranges {
    <i>// <sref ref="[range.iter.op.advance]"/>,</i> ranges::advance
    template&lt;input_or_output_iterator I&gt;
      constexpr void advance(I&amp; i, iter_difference_t&lt;I&gt; n);                <i>// freestanding</i>
    template&lt;input_or_output_iterator I, <del>sentinel_for&lt;I&gt;</del><ins>class</ins> S&gt;
      <ins>requires (!<i>is-integer-like</i>&lt;S&gt;) &amp;&amp; sentinel_for&lt;S, I&gt;</ins>
      constexpr void advance(I&amp; i, S bound);                               <i>// freestanding</i>
    template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
      constexpr iter_difference_t&lt;I&gt; advance(I&amp; i, iter_difference_t&lt;I&gt; n, <i>// freestanding</i>
                                             S bound);    
   [&hellip;]
    <i>// <sref ref="[range.iter.op.next]"/>,</i> ranges::next
    template&lt;input_or_output_iterator I&gt;
      constexpr I next(I x);                                  <i>// freestanding</i>
    template&lt;input_or_output_iterator I&gt;
      constexpr I next(I x, iter_difference_t&lt;I&gt; n);          <i>// freestanding</i>
    template&lt;input_or_output_iterator I, <del>sentinel_for&lt;I&gt;</del><ins>class</ins> S&gt;
      <ins>requires (!<i>is-integer-like</i>&lt;S&gt;) &amp;&amp; sentinel_for&lt;S, I&gt;</ins>
      constexpr I next(I x, S bound);                         <i>// freestanding</i>
    template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
      constexpr I next(I x, iter_difference_t&lt;I&gt; n, S bound); <i>// freestanding</i>    
  }
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify <sref ref="[range.iter.op.advance]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;input_or_output_iterator I, <del>sentinel_for&lt;I&gt;</del><ins>class</ins> S&gt;
  <ins>requires (!<i>is-integer-like</i>&lt;S&gt;) &amp;&amp; sentinel_for&lt;S, I&gt;</ins>
  constexpr void advance(I&amp; i, S bound);
</pre>
<blockquote>
<p>
-3- <i>Preconditions</i>: [&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify <sref ref="[range.iter.op.next]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;input_or_output_iterator I, <del>sentinel_for&lt;I&gt;</del><ins>class</ins> S&gt;
  <ins>requires (!<i>is-integer-like</i>&lt;S&gt;) &amp;&amp; sentinel_for&lt;S, I&gt;</ins>
  constexpr I next(I x, S bound);
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>

</superseded>

<note>2026-02-20; Jonathan provides new wording</note>

</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5032"/>.
</p>

<ol>
<li><p>Modify <sref ref="[iterator.concept.sentinel]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;class S, class I&gt;
  concept sentinel_for =
    semiregular&lt;S&gt; &amp;&amp;
    <ins>!<i>is-integer-like</i>&lt;S&gt; &amp;&amp;</ins>
    input_or_output_iterator&lt;I&gt; &amp;&amp;
    weakly-equality-comparable-with&lt;S, I&gt;; <i>// see <sref ref="[concept.equalitycomparable]"/></i>
</pre>
</blockquote>
</li>
</ol>

</resolution>

</issue>
