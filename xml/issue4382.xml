<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4382" status="Tentatively Ready">
<title>The <tt>simd::basic_mask(bool)</tt> overload needs to be more constrained
</title>
<section>
<sref ref="[simd.mask.ctor]"/>
</section>
<submitter>Matthias Kretz</submitter>
<date>24 Sep 2025</date>
<priority>99</priority>

<discussion>
<p>
<sref ref="[simd.mask.ctor]"/> defines the overloads `basic_mask(bool)` and
`basic_mask(unsigned_integral auto)`. This leads to the following pitfall:
</p>
<blockquote><pre>
auto g0() {
  unsigned short k = 0xf;
  return simd::mask&lt;float, 8&gt;(k); // mov eax, 15
}

auto g1() {
  unsigned short k = 0xf;
  return simd::mask&lt;float, 8&gt;(k >> 1); // mov eax, -1 ⚠️
}

auto g2() {
  unsigned int k = 0xf;
  return simd::mask&lt;float, 8&gt;(k >> 1); // mov eax, 7
}
</pre></blockquote>
<p>
In `g1`, `k` is promoted to `int`, shifted and then passed to 
the mask constructor. Instead of failing, `int(0x7)` is 
converted to `bool` and the mask thus initialized to all `true`.
<p/>
Also consider:
</p>
<ol>
<li><p><tt>simd::mask&lt;float&gt;(true_type());</tt></p></li>
<li><p><tt>unsigned_integral&lt;bool&gt;</tt> is `true` => 
<tt>same_as&lt;bool&gt; auto</tt> instead of 'bool' makes 
the overload set ambiguous</p></li>
<li><p>`float` is convertible to `bool`, thus 
<tt>simd::mask&lt;float&gt;(1.f)</tt> continues to compile</p></li>
</ol>

<superseded>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>

<li><p>Modify <sref ref="[simd.mask.overview]"/>, <tt>class template basic_mask</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::simd {
  template&lt;size_t Bytes, class Abi&gt; class basic_mask {
  public:
    [&hellip;]
    
    constexpr basic_mask() noexcept = default;
    
    // <i><sref ref="[simd.mask.ctor]"/>, basic_mask constructors</i>
    constexpr explicit basic_mask(value_type) noexcept;
    template&lt;size_t UBytes, class UAbi&gt;
      constexpr explicit basic_mask(const basic_mask&lt;UBytes, UAbi&gt;&amp;) noexcept;
    template&lt;class G&gt;
      constexpr explicit basic_mask(G&amp;&amp; gen) noexcept;
    constexpr basic_mask(const bitset&lt;size()&gt;&amp; b) noexcept;
    constexpr explicit basic_mask(unsigned_integral auto val) noexcept;
    <ins>basic_mask(signed_integral auto) = delete;</ins>
    
    [&hellip;]
  };
}
</pre>
</blockquote>

</li>

</ol>
</superseded>

<note>2025-10-06; Matthias Kretz improves wording after reflector discussion</note>

<note>2025-10-23; Reflector poll.</note>
<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>

</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>

<li><p>Modify <sref ref="[simd.mask.overview]"/>, <tt>class template basic_mask</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::simd {
  template&lt;size_t Bytes, class Abi&gt; class basic_mask {
  public:
    [&hellip;]
    
    constexpr basic_mask() noexcept = default;
    
    // <i><sref ref="[simd.mask.ctor]"/>, basic_mask constructors</i>
    constexpr explicit basic_mask(<ins>same_as&lt;</ins>value_type<ins>&gt; auto</ins>) noexcept;
    template&lt;size_t UBytes, class UAbi&gt;
      constexpr explicit basic_mask(const basic_mask&lt;UBytes, UAbi&gt;&amp;) noexcept;
    template&lt;class G&gt;
      constexpr explicit basic_mask(G&amp;&amp; gen) noexcept;
    <ins>template&lt;same_as&lt;bitset&lt;size()&gt;&gt; T&gt;</ins>
      constexpr basic_mask(const <ins>T</ins><del>bitset&lt;size()&gt;</del>&amp; b) noexcept;
    <ins>template&lt;unsigned_integral T&gt; requires (!same_as&lt;T, value_type&gt;)</ins>
      constexpr explicit basic_mask(<ins>T</ins><del>unsigned_integral auto</del> val) noexcept;
    
    [&hellip;]
  };
}
</pre>
</blockquote>

</li>

<li><p>Modify <sref ref="[simd.mask.ctor]"/> as indicated:</p>

<blockquote>
<pre>
constexpr explicit basic_mask(<ins>same_as&lt;</ins>value_type<ins>&gt; auto</ins> x) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes each element with `x`.
</p>
</blockquote>
[&hellip;]
<pre>
<ins>template&lt;same_as&lt;bitset&lt;size()&gt;&gt; T&gt;</ins>
  constexpr basic_mask(const <ins>T</ins><del>bitset&lt;size()&gt;</del>&amp; b) noexcept;
</pre>
<blockquote>
<p>
-7- <i>Effects</i>: Initializes the <tt><i>i</i></tt><sup>th</sup> element with <tt>b[<i>i</i>]</tt> 
for all <tt><i>i</i></tt> in the range `[0, size())`.
</p>
</blockquote>
<pre>
<ins>template&lt;unsigned_integral T&gt; requires (!same_as&lt;T, value_type&gt;)</ins>
  constexpr explicit basic_mask(<ins>T</ins><del>unsigned_integral auto</del> val) noexcept;
</pre>
<blockquote>
<p>
-8- <i>Effects</i>: Initializes the first <tt><i>M</i></tt> elements to the corresponding bit values 
in `val`, [&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>
</resolution>

</issue>
