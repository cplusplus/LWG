<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4378" status="New">
<title>Inconsistency between `std::basic_string`'s `data()` and `operator[]` specification</title>
<section>
<sref ref="[string.access]"/>
</section>
<submitter>Peter Bindels</submitter>
<date>16 Sep 2025</date>
<priority>4</priority>

<discussion>
<p>
From the working draft <paper num="N5014"/>, the specification for `operator[]` in <sref ref="[string.access]"/> 
p2 says:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<i>Returns</i>: <tt>*(begin() + pos)</tt> if <tt>pos &lt; size()</tt>. Otherwise, returns a reference 
to an object of type `charT` with value `charT()`, where modifying the object to any value other than 
`charT()` leads to undefined behavior.
</p>
</blockquote>
<p>
The specification for data() in <sref ref="[string.accessors]"/> p1 (and p4) says, however:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<i>Returns</i>: A pointer `p` such that `p + i == addressof(operator[](i))` for each `i` in `[0, size()]`.
</p>
</blockquote>
<p>
The former implies that `str[str.size()]` is allowed to be the address of any null terminator, 
while the latter restricts it to only being the null terminator belonging to the string.
<p/>
Suggested fix: Change wording around `operator[]` to
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<i>Returns</i>: `*(begin() + pos)` if <tt>pos &lt;= size()</tt>. The program shall not modify the value 
stored at `size()` to any value other than `charT()`; otherwise, the behavior is undefined.
</p>
</blockquote>
<p>
This moves it inline with the `data()` specification. Given the hardened precondition that 
<tt>pos &lt;= size()</tt> this does not change behavior for any in-contract access, and we do 
not define what the feature does when called with broken preconditions. I have been looking at 
the latter but that will be an EWG paper instead.
</p>

<note>2025-10-21; Reflector poll.</note>
<p>
Set priority to 4 after reflector poll.
</p>
<p>
"NAD. `begin() + size()` is not dereferenceable and should remain that way."
</p>
<p>
"Saying "if <code>pos &lt;= size()</code> is redundant given the precondition above."
</p>
<p>
"The resolution removes any guarantee that the value at `str[str.size()]`
is `charT()`. Furthermore, the premise of the issue is incorrect,
returning the address of a different null terminator not belonging to the
string would make traversing it with other string operations UB, so it
has to return a reference to a terminator that's within the same array."
</p>
<p>
"`*(begin() = size())` is UB, but could use `*(data() + size())` instead.
Personally I'd like `*end()` to be valid, but that's certainly LEWG business
requiring a paper."
</p>
<superseded>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>


<li><p>Modify <sref ref="[string.access]"/> as indicated:</p>

<blockquote>
<pre>
constexpr const_reference operator[](size_type pos) const;
constexpr       reference operator[](size_type pos);
</pre>
<blockquote>
<p>
-1- <i>Hardened preconditions</i>: <tt>pos &lt;= size()</tt> is `true`.
<p/>
-2- <i>Returns</i>: `*(begin() + pos)` if <tt>pos &lt;<ins>=</ins> size()</tt>. <del>Otherwise, returns a reference 
to an object of type `charT` with value `charT()`, where modifying the object to any value other 
than `charT()` leads to undefined behavior.</del>
<p/>
-3- <i>Throws</i>: Nothing.
<p/>
-4- <i>Complexity</i>: Constant time.
<p/>
<ins>-?- <i>Remarks</i> The program shall not modify the value stored at `size()` to any value other than `charT()`; 
otherwise, the behavior is undefined</ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>
</superseded>

<note>2025-11-11; Jonathan provides new wording</note>
<p>
We say that `basic_string` is a contiguous container, which makes the
`addressof` wording in `c_str()` and `data()` redundant.
The front matter says that there's a null terminator present,
so we can move the rule about not modifying the terminator there
instead of repeating it in `operator[]` and `c_str()`.
</p>
<p>
We can also permit modifying the string contents through
<code>const_cast&lt;charT*&gt;(str.c_str())</code>,
since there's no reason for that to be undefined when
<code>const_cast&lt;string&amp;&gt;(str).data()</code> is allowed.
</p>

</discussion>

<resolution>

<ol>

<li><p>Modify <sref ref="[basic.string.general]"/> as indicated:</p>

<blockquote>
<p>-3-
In all cases, [`data()`, `data() + size()`] is a valid range,
`data() + size()` points at an object with value `charT()`
(a "null terminator"), and <tt>size() &lt;= capacity()</tt> is `true`.
<ins>
Non-const access to the null terminator is possible,
e.g. using `*(data()+size())`, but the program has undefined behaviour
if the null terminator is modified to any value other than `charT()`.
</ins>
</p>
</blockquote>
</li>

<li><p>Modify <sref ref="[string.access]"/> as indicated:</p>

<blockquote>
<pre>
constexpr const_reference operator[](size_type pos) const;
constexpr reference       operator[](size_type pos);
</pre>
<blockquote>
<p>-1- <i>Hardened Preconditions</i>: <tt>pos &lt;= size()</tt> is `true`.</p>
<p>-2- <i>Returns</i>:
<ins>`*(data() + pos)`.</ins>
<del>
`*(begin() + pos)` if <tt>pos &lt; size()</tt>.
Otherwise, returns a reference to an object of type `charT`
with value `charT()`,
where modifying the object to any value other than `charT()`
leads to undefined behavior.
</del>
</p>
<p>-3- <i>Throws</i>: Nothing.</p>
<p>-4- <i>Complexity</i>: Constant time.</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify <sref ref="[string.accessors]"/> as indicated:</p>

<blockquote>
<pre>
constexpr const charT* c_str() const noexcept;
constexpr const charT* data() const noexcept;
<ins>constexpr charT* data() noexcept;</ins>
</pre>
<blockquote>
<p>-1- <i>Returns</i>:
<ins>`to_address(begin())`.</ins>
<del>
A pointer `p` such that `p + i == addressof(operator[](i))`
for each `i` in [`0`, `size()`].
</del>
</p>
<p>-2- <i>Complexity</i>: Constant time.</p>
<p><del>-3- <i>Remarks</i>:
The program shall not modify any of the values stored in the character array;
otherwise, the behavior is undefined.</del>
</p>
</blockquote>

<pre>
<del>constexpr charT* data() noexcept;</del>
</pre>
<blockquote>
<p><del>-4- <i>Returns</i>:
A pointer `p` such that `p + i == addressof(operator[](i))`
for each `i` in [`0`, `size()`].
</del>
</p>
<p><del>-5- <i>Complexity</i>: Constant time.</del></p>
<p><del>-6- <i>Remarks</i>:
The program shall not modify the value stored at `p + size()` to any
value other than `charT()`; otherwise, the behavior is undefined.</del>
</p>
</blockquote>

</blockquote>
</li>
</ol>

</resolution>

</issue>
