<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4435" status="New">
<title>`meta::has_identifier` doesn't handle all types</title>
<section><sref ref="[meta.reflection.names]"/></section>
<submitter>Jakub Jelinek</submitter>
<date>27 Oct 2025</date>
<priority>2</priority>

<discussion>
<p>
The wording for `meta::has_identifier` doesn't specify what it returns for
`^^int` or `^^void` or `^^Enum`.
</p>

<note>2025-10-29; Reflector poll.</note>
<p>
Set priority to 2 after reflector poll.
</p>
<p>
Move bullet point for aliases before bullet for types.
Add "cv-unqualified" to class type and enumeration type.
Simplify "`!has_template_arguments() is `true`" to
"`has_template_arguments()` is `false`".
</p>
</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>

<li><p>Modify <sref ref="[meta.reflection.names]"/> as indicated:</p>

<blockquote>
<pre>consteval bool has_identifier(info r);</pre>
<blockquote>
<p>-1- <i>Returns</i>:
<ul>
<li>(1.1) &mdash;
If `r` represents an entity that has a typedef name for linkage purposes
(<sref ref="[dcl.typedef]"/>), then `true`.
</li>
<li>(1.2) &mdash;
Otherwise, if `r` represents an unnamed entity, then `false`.
</li>
<li><ins>(1.?) &mdash;
Otherwise, if `r` represents a type alias, then `!has_template_arguments(r)`.
</ins>
</li>
<li>(1.3) &mdash;
Otherwise, if `r` represents a <ins>type, then `true` if</ins>
<del>class type, then `!has_template_arguments(r)`.</del>
<ul>
<li><ins>(1.3.1) &mdash;
`r` represents a cv-unqualified class type
and `has_template_arguments(r)` is `false`, or
</ins>
</li>
<li><ins>(1.3.2) &mdash;
`r` represents a cv-unqualified enumeration type.
</ins>
</li>
</ul>
<ins>Otherwise, `false`.</ins>
</li>
<li>(1.4) &mdash;
Otherwise, if `r` represents a function, then `true` if `has_template_arguments(r)` is `false` and the function is not a constructor, destructor, operator function, or conversion function.
Otherwise, `false`.
</li>
<li>(1.5) &mdash;
Otherwise, if `r` represents a template, then `true` if `r` does not represent a constructor template, operator function template, or conversion function template.
Otherwise, `false`.
</li>
<li>(1.6) &mdash;
Otherwise, if `r` represents the <i>i</i><sup>th</sup> parameter of a function <i>F</i> that is an (implicit or explicit) specialization of a templated function <i>T</i> and the <i>i</i><sup>th</sup> parameter of the instantiated declaration of <i>T</i> whose template arguments are those of <i>F</i> would be instantiated from a pack, then `false`.
</li>
<li>(1.7) &mdash;
Otherwise, if `r` represents the parameter <i>P</i> of a function <i>F</i>, then let <i>S</i> be the set of declarations, ignoring any explicit instantiations, that precede some point in the evaluation context and that declare either <i>F</i> or a templated function of which <i>F</i> is a specialization; `true` if
<ul>
<li>(1.7.1) &mdash;
there is a declaration <i>D</i> in <i>S</i> that introduces a name <i>N</i> for either <i>P</i> or the parameter corresponding to <i>P</i> in the templated function that <i>D</i> declares and
</li>
<li>(1.7.2) &mdash;
no declaration in <i>S</i> does so using any name other than <i>N</i>.
</li>
</ul>
Otherwise, `false`.
</li>
<li>(1.8) &mdash;
Otherwise, if `r` represents a variable, then `false` if the declaration
of that variable was instantiated from a function parameter pack.
Otherwise, `!has_template_arguments(r)`.
</li>
<li>(1.9) &mdash;
Otherwise, if `r` represents a structured binding,
then `false` if the declaration of that structured binding was instantiated
from a structured binding pack.
Otherwise, `true`.
</li>
<li><del>(1.10) &mdash;
Otherwise, if `r` represents a type alias, then `!has_template_arguments(r)`.
</del>
</li>
<li>(1.11) &mdash;
Otherwise, if `r` represents an enumerator, non-static-data member,
namespace, or namespace alias, then `true`.
</li>
<li>(1.12) &mdash;
Otherwise, if `r` represents a direct base class relationship,
then `has_identifier(type_of(r))`.
</li>
<li>(1.13) &mdash;
Otherwise, `r` represents a data member description (T,N,A,W,NUA)
(<sref ref="[class.mem.general]"/>); `true` if N is not ‚ä•.
Otherwise, `false`.
</li>
</ul>
</p>
</blockquote>
</blockquote>
</li>
</ol>

</resolution>

</issue>
