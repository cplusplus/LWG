<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="3283" status="Resolved">
<title>Types satisfying <tt>input_iterator</tt> but not <tt>equality_comparable</tt> look like
C++17 output iterators</title>
<section><sref ref="[iterator.traits]"/></section>
<submitter>Eric Niebler</submitter>
<date>10 Sep 2019</date>
<priority>2</priority>

<discussion>
<p>
In C++20, if an iterator doesn't define <em>all</em> of the associated iterator types (value,
category, reference, and difference), the primary <tt>std::iterator_traits</tt> template picks
a category based on structural conformance to a set of implementation-defined concepts that
capture the old iterator requirements tables. (See <sref ref="[iterator.traits]"/>.) In C++17,
input iterators were required to be equality-comparable with themselves. In C++20 that is not
the case, so such iterators must not be given <tt>intput_iterator_tag</tt> as a category.
They don't, so that's all well and good.
<p/>
However, <sref ref="[iterator.traits]"/> concludes that, since such an iterator cannot be an
input iterator, it must therefor be an <em>output</em> iterator, and it assigns it a category
of <tt>std::output_iterator_tag</tt>. It does this even if there is a nested
<tt>iterator_category</tt> typedef declaring the iterator to be input. (This will happen
frequently as C++20 iterators don't require iterators to declare their reference type, for
instance.) This will be extremely confusing to users who, understandably, will be at a loss to
understand why the legacy STL algorithms think their iterator is an output iterator when they
have clearly stated that the iterator is input!
<p/>
The fix is to tweak the specification such that the output category is assigned to an iterator
only (a) if it declares its category to be output, or (b) it doesn't specify a category at all.
The result, for the user, is that their iterator simply won't look like a C++17 iterator at all,
because it isn't!
<p/>
Suggested priority: P1. We can't make this change after C++20 because it would be an observable change.
<p/>
This fix has been implemented in range-v3.
</p>

<note>2019-10-12 Priority set to 1 after reflector discussion</note>

<note>2019-11 Wednesday night Issue processing in Belfast</note>
<p>Much discussion along with <iref ref="3289"/>. CC to write rationale for NAD.</p>

<note>2020-02-13, Prague; Priority reduced to 2 after LWG discussion</note>
<note>2021-05-18 Resolved by the adoption of <a href="https://wg21.link/P2259R1">P2259R1</a> at the February 2021 plenary. Status changed: New &rarr; Resolved.</note>
</discussion>

<resolution>
<p>This wording is relative to <a href="https://wg21.link/n4830">N4830</a>.</p>

<ol>
<li><p>Modify <sref ref="[iterator.traits]"/> as indicated:</p>

<blockquote>
<p>
-3- The members of a specialization <tt>iterator_traits&lt;I&gt;</tt> generated from the
<tt>iterator_traits</tt> primary template are computed as follows:
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; If <tt>I</tt> has valid [&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>(3.3) &mdash; Otherwise, if <tt>I</tt> satisfies the exposition-only concept
<tt><i>cpp17-iterator</i></tt> <ins>and either</ins></p>
<ol style="list-style-type:lower-alpha">
<li><p><ins><tt>I::iterator_category</tt> is valid and denotes <tt>output_iterator_tag</tt> or a
type publicly and unambiguously derived from <tt>output_iterator_tag</tt>, or</ins></p></li>
<li><p><ins>there is no type <tt>I::iterator_category</tt></ins></p></li>
</ol>
<p>then <tt>iterator_traits&lt;I&gt;</tt> has the following publicly accessible members:</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
</li>

</ol>

</resolution>
</issue>
