<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4389" status="SG9">
<title>`ranges::for_each` possibly behaves differently from range-based `for`</title>
<section><sref ref="[range.range]"/></section>
<submitter>Jiang An</submitter>
<date>28 Sep 2025</date>
<priority>2</priority>

<discussion>
<p>
It was found in the blog post 
<a href="https://quuxplusone.github.io/blog/2024/12/09/foreach-versus-for/">
"When `ranges::for_each` behaves differently from `for`"</a>  that `ranges::for_each` 
can behave differently from range-based `for`, because
</p>
<ol>
<li><p>`ranges::begin` and `ranges::end` possibly use different rules, i.e. one calls a member 
and the other calls an ADL-found non-member function, and</p></li>
<li><p>these CPOs continue to perform ADL when a member `begin/end` is found but the 
function call is not valid, while the range-for stops and renders the program ill-formed.</p></li>
</ol>
<p>
Perhaps the intent of Ranges was that the `ranges::range` concept should be stricter than 
plain range-for and all range types can be iterated via range-for with the same semantics 
as `ranges::for_each`. However, it seems very difficult (if not impossible) for a library 
implementation to tell whether a class has member `begin/end` but the corresponding member 
call is ill-formed with C++20 core language rules, and such determination is critical for 
eliminating the semantic differences between `ranges::for_each` and range-for.
</p>

<note>2025-10-23; Reflector poll; Status changed: New &rarr; SG9 and P2.</note>
<p>
This is certainly evoluationary question and should go to LEWG/SG9.
It would disallow having unrelated begin/end members, where the range
interface is provided by hidden friends instead of those members.
</p>
</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<blockquote class="note">
<p>
Two mutually exclusive resolutions are proposed here. One enforces semantic-identity checks, 
while the other doesn't and makes weird types satisfy but not model the range concept. I 
prefer the stricter one because the semantic-identity checks are fully static, but this probably 
requires compilers to add new intrinsics when reflection is absent.
</p>
</blockquote>

<p>
<b>Option A</b>: (stricter)
</p>

<ol>
<li><p>Modify <sref ref="[range.access.begin]"/> as indicated:</p>

<blockquote>
<p>
-2- Given a subexpression `E` with type `T`, let `t` be an lvalue that denotes the reified object for `E`. Then:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If `E` is an rvalue and <tt>enable_borrowed_range&lt;remove_cv_t&lt;T&gt;&gt;</tt> is 
`false`, `ranges::begin(E)` is ill-formed.</p></li>
<li><p>(2.2) &mdash; Otherwise, if `T` is an array type (<sref ref="[dcl.array]"/>) and 
<tt>remove_all_extents_t&lt;T&gt;</tt> is an incomplete type, `ranges::begin(E)` is 
ill-formed with no diagnostic required.</p></li>
<li><p>(2.3) &mdash; Otherwise, if `T` is an array type, `ranges::begin(E)` is 
expression-equivalent to `t + 0`.</p></li>
<li><p>(2.4) &mdash; Otherwise, if `auto(t.begin())` is a valid expression whose type models 
`input_or_output_iterator`, `ranges::begin(E)` is expression-equivalent to `auto(t.begin())`.</p></li>
<li><p><ins>(2.?) &mdash; Otherwise, if <tt>remove_cvref_t&lt;T&gt;</tt> is a class type and search for 
`begin` in the scope of that class finds at least one declaration, `ranges::begin(E)` is ill-formed.</ins></p></li>
<li><p>(2.5) &mdash; Otherwise, if `T` is a class or enumeration type and `auto(begin(t))` 
is a valid expression whose type models `input_or_output_iterator` where the meaning of `begin` 
is established as-if by performing argument-dependent lookup only (<sref ref="[basic.lookup.argdep]"/>), 
then `ranges::begin(E)` is expression-equivalent to that expression.</p></li>
<li><p>(2.6) &mdash; Otherwise, `ranges::begin(E)` is ill-formed.</p></li>
</ol>
</blockquote>
</li>

<li><p>Modify <sref ref="[range.access.end]"/> as indicated:</p>

<blockquote>
<p>
-2- Given a subexpression `E` with type `T`, let `t` be an lvalue that denotes the reified object for `E`. Then:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If `E` is an rvalue and <tt>enable_borrowed_range&lt;remove_cv_t&lt;T&gt;&gt;</tt> 
is `false`, `ranges::end(E)` is ill-formed.</p></li>
<li><p>(2.2) &mdash; Otherwise, if `T` is an array type (<sref ref="[dcl.array]"/>) and 
<tt>remove_all_extents_t&lt;T&gt;</tt> is an incomplete type, `ranges::end(E)` is ill-formed 
with no diagnostic required.</p></li>
<li><p>(2.3) &mdash; Otherwise, if `T` is an array of unknown bound, `ranges::end(E)` is ill-formed.</p></li>
<li><p>(2.4) &mdash; Otherwise, if `T` is an array, `ranges::end(E)` is expression-equivalent to 
<tt>t + extent_v&lt;T&gt;</tt>.</p></li>
<li><p>(2.5) &mdash; Otherwise, if `auto(t.end())` is a valid expression whose type models 
<tt>sentinel_for&lt;iterator_t&lt;T&gt;&gt;</tt> then `ranges::end(E)` is expression-equivalent to 
`auto(t.end())`.</p></li>
<li><p><ins>(2.?) &mdash; Otherwise, if <tt>remove_cvref_t&lt;T&gt;</tt> is a class type and search for 
`end` in the scope of that class finds at least one declaration, `ranges::end(E)` is ill-formed.</ins></p></li>
<li><p>(2.6) &mdash; Otherwise, if `T` is a class or enumeration type and `auto(end(t))` 
is a valid expression whose type models <tt>sentinel_for&lt;iterator_t&lt;T&gt;&gt;</tt> 
where the meaning of end is established as-if by performing argument-dependent
lookup only (<sref ref="[basic.lookup.argdep]"/>), then `ranges::end(E)` is expression-equivalent 
to that expression.</p></li>
<li><p>(2.7) &mdash; Otherwise, `ranges::end(E)` is ill-formed.</p></li>
</ol>
</blockquote>
</li>

<li><p>Modify <sref ref="[range.range]"/> as indicated:</p>

<blockquote>
<p>
-1- [&hellip;]
</p>
<pre>
template&lt;class T&gt;
  concept range =
    requires(T&amp; t) {
      ranges::begin(t);    // <i>sometimes equality-preserving (see below)</i>
      ranges::end(t);
    } <ins>&amp;&amp; <i>has-consistent-begin-end</i>&lt;T&gt;</ins>; <ins>// <i>see below</i></ins>
</pre>
<p>
-2- [&hellip;]
<p/>
-3- [&hellip;]
<p/>
<ins>-?- <tt><i>has-consistent-begin-end</i>&lt;T&gt;</tt> is a constant expression of type `bool`, 
and it is `true` if and only if for the `t` introduced in the requires-expression above, either</ins>
</p>
<ol style="list-style-type: none">
<li><p><ins>(?.1) &mdash; both `ranges::begin(t)` and `ranges::end(t)` are specified to select 
`auto(t.begin())` and `auto(t.end())` respectively, or</ins></p></li>
<li><p><ins>(?.2) &mdash; both `ranges::begin(t)` and `ranges::end(t)` are specified not 
to select `auto(t.begin())` and `auto(t.end())` respectively.</ins></p></li>
</ol>
</blockquote>
</li>
</ol>

<p>
<b>Option B</b>: (looser)
</p>

<ol>
<li><p>Modify <sref ref="[range.range]"/> as indicated:</p>

<blockquote>
<p>
-1- [&hellip;]
</p>
<pre>
template&lt;class T&gt;
  concept range =
    requires(T&amp; t) {
      ranges::begin(t);    // <i>sometimes equality-preserving (see below)</i>
      ranges::end(t);
    }
</pre>
<p>
-2- Given an expression `t` such that `decltype((t))` is <tt>T&amp;</tt>, `T` models `range` only if
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; [&hellip;]</p></li>
<li><p>(2.2) &mdash; [&hellip;]</p></li>
<li><p>(2.3) &mdash; [&hellip;]</p></li>
<li><p><ins>(2.?) &mdash; The range-based `for` statement <tt>for (auto&amp;&amp; x: t);</tt> is well-formed, 
and variable definitions <tt>auto <i>begin</i> = <i>begin-expr</i>;</tt> and <tt>auto <i>end</i> = <i>end-expr</i>;</tt> 
in the equivalent form (<sref ref="[stmt.ranged]"/>) of that statement are semantically equivalent to 
<tt>auto <i>begin</i> = ranges::begin(t);</tt> and <tt>auto <i>end</i> = ranges::end(t);</tt> respectively.</ins></p></li>
</ol>

</blockquote>
</li>
</ol>

</resolution>

</issue>
