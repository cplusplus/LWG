<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4460" status="New">
<title>Missing <i>Throws</i>: for last `variant` constructor</title>
<section><sref ref="[variant.ctor]"/></section>
<submitter>Jonathan Wakely</submitter>
<date>07 Nov 2025</date>
<priority>99</priority>

<discussion>
<p>
All `variant` constructors except the last one have a <i>Throws</i>: element
saying what they're allowed to throw.
</p>
<p>
This originates from an editorial pull request, where the submitter said:
</p>
<blockquote>
"It looks like this defect is an artifact of a change between
<paper num="P0088R0"/> and <paper num="P0088R1"/>.
Note how in R0 neither one of the `emplaced_type_t`/`emplaced_index_t`
(as they were then called) + `initializer_list` constructors have a
throws clause. In R1 only one of them gained it."
</blockquote>
<superseded>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>
<li><p>Modify <sref ref="[variant.ctor]"/>, as indicated:</p>

<blockquote>
<pre>
template&lt;size_t I, class U, class... Args&gt;
  constexpr explicit variant(in_place_index_t&lt;I&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>-35- <i>Constraints</i>:
<ol style="list-style-type: none">
<li>(35.1) &mdash; `I` is less than `sizeof...(Types)` and</li>
<li>(35.2) &mdash;
<code>is_constructible_v&lt;T<sub>I</sub>, initializer_list&lt;U&gt;&amp;, Args...&gt;</code>
is `true`.
</li>
</ol>
</p>
<p>-36- <i>Effects</i>:
Direct-non-list-initializes the contained value of type
<tt>T<sub>I</sub></tt> with <code>il, std::forward&lt;Args&gt;(args)...</code>.
</p>
<p>-37- <i>Postconditions</i>: `index()` is `I`.</p>
<p><ins>-?- <i>Throws</i>:
Any exception thrown by calling the selected constructor of
<tt>T<sub>I</sub></tt>.
</ins>
</p>
<p>-38- <i>Remarks</i>:
If <tt>T<sub>I</sub></tt>’s selected constructor is a constexpr constructor,
this constructor is a constexpr constructor.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</superseded>

<note>2025-11-11; Jonathan provides improved wording</note>

</discussion>

<resolution>

<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>
<li><p>Modify <sref ref="[variant.ctor]"/>, as indicated:</p>

<blockquote>
<pre>
constexpr variant() noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>-2- <i>Constraints</i>:
<code>is_default_constructible_v&lt;T<sub>0</sub>&gt;</code> is `true`.
</p>
<p>-3- <i>Effects</i>:
Constructs a `variant` holding a value-initialized value of type <tt>T<sub>0</sub></tt>.
</p>
<p>-4- <i>Postconditions</i>:
`valueless_by_exception()` is `false` and `index()` is `0`.
</p>
<p>-5- <i>Throws</i>:
Any exception thrown by the value-initialization of <tt>T<sub>0</sub></tt>.
</p>
<p>-6- <i>Remarks</i>: [&hellip;]
</p>
</blockquote>

<pre>
constexpr variant(const variant&amp;);
</pre>
<blockquote>
<p>-7- <i>Effects</i>:
If `w` holds a value, initializes the `variant` to hold the same alternative
as `w` and direct-initializes the contained value with
<code><i>GET</i>&lt;j&gt;(w)</code>, where `j` is `w.index()`.
Otherwise, initializes the `variant` to not hold a value.
</p>
<p>-8- <i>Throws</i>:
Any exception thrown by
<del>direct-initializating any <tt>T<sub>i</sub></tt> for all <i>i</i></del>
<ins>the initialization of the contained value</ins>.
</p>
<p>-9- <i>Remarks</i>: [&hellip;]
</p>
</blockquote>

<pre>
constexpr variant(variant&amp;&amp;) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>-10- <i>Constraints</i>:
<code>is_move_constructible_v&lt;T<sub>i</sub>&gt;</code> is `true`
for all <i>i</i>.
</p>
<p>-11- <i>Effects</i>:
If `w` holds a value, initializes the `variant` to hold the same alternative
as `w` and direct-initializes the contained value with
<code><i>GET</i>&lt;j&gt;(std::move(w))</code>, where `j` is `w.index()`.
Otherwise, initializes the `variant` to not hold a value.
</p>
<p>-12- <i>Throws</i>:
Any exception thrown by
<del>move-constructing any <tt>T<sub>i</sub></tt> for all <i>i</i></del>
<ins>the initialization of the contained value</ins>.
</p>
<p>-13- <i>Remarks</i>: [&hellip;]
</p>
</blockquote>

<pre>
template&lt;class T&gt; constexpr variant(T&amp;&amp;) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>-14-
Let <tt>T<sub>j</sub></tt> be a type that is determined as follows:
build an imaginary function <tt><i>FUN</i>(T<sub>i</sub>)</tt>
for each alternative type <tt>T<sub>i</sub></tt>
for which <tt>T<sub>i</sub> x[] = {std::forward&lt;T&gt;(t)};</tt>
is well-formed for some invented variable `x`.
The overload <tt><i>FUN</i>(T<sub>j</sub>)</tt> selected by overload resolution
for the expression <tt><i>FUN</i>(std::forward&lt;T&gt;(t))</tt> defines
the alternative <tt>T<sub>j</sub></tt> which is the type
of the contained value after construction.
</p>
<p>-15- <i>Constraints</i>: [&hellip;]
</p>
<p>-16- <i>Effects</i>:
Initializes `*this` to hold the alternative type <tt>T<sub>j</sub></tt>
and direct-non-list-initializes the contained value with
<code>std::forward&lt;T&gt;(t)</code>.
</p>
<p>-17- <i>Postconditions</i>: [&hellip;]
</p>
<p>-18- <i>Throws</i>:
Any exception thrown by the initialization of the
<del>selected alternative <tt>T<sub>j</sub></tt></del>
<ins>contained value</ins>.
</p>
<p>-19- <i>Remarks</i>: [&hellip;]
</p>
</blockquote>

<pre>
template&lt;class T, class... Args&gt; constexpr variant(in_place_type_t&lt;T&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>-20- <i>Constraints</i>: [&hellip;]
</p>
<p>-21- <i>Effects</i>:
Direct-non-list-initializes the contained value of type `T`
with
<code>std::forward&lt;Args&gt;(args)...</code>.
</p>
<p>-22- <i>Postconditions</i>: [&hellip;]
</p>
<p>-23- <i>Throws</i>:
Any exception thrown by
<del>the selected constructor of `T`</del>
<ins>the initialization of the contained value</ins>.
</p>
<p>-24- <i>Remarks</i>: [&hellip;]
</p>
</blockquote>

<pre>
template&lt;class T, class U, class... Args&gt;
  constexpr variant(in_place_type_t&lt;T&gt;, initializer_list&lt;U&gt; li, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>-25- <i>Constraints</i>: [&hellip;]
</p>
<p>-26- <i>Effects</i>:
Direct-non-list-initializes the contained value of type `T`
with
<code>il, std::forward&lt;Args&gt;(args)...</code>.
</p>
<p>-27- <i>Postconditions</i>: [&hellip;]
</p>
<p>-28- <i>Throws</i>:
Any exception thrown by
<del>the selected constructor of `T`</del>
<ins>the initialization of the contained value</ins>.
</p>
<p>-29- <i>Remarks</i>: [&hellip;]
</p>
</blockquote>

<pre>
template&lt;size_t I, class... Args&gt;
  constexpr explicit variant(in_place_index_t&lt;I&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>-30- <i>Constraints</i>:
<ol style="list-style-type: none">
<li>(30.1) &mdash; `I` is less than `sizeof...(Types)` and</li>
<li>(30.2) &mdash;
<code>is_constructible_v&lt;T<sub>I</sub>, Args...&gt;</code>
is `true`.
</li>
</ol>
</p>
<p>-31- <i>Effects</i>:
Direct-non-list-initializes the contained value of type
<tt>T<sub>I</sub></tt> with <code>std::forward&lt;Args&gt;(args)...</code>.
</p>
<p>-32- <i>Postconditions</i>: `index()` is `I`.</p>
<p>-33- <i>Throws</i>:
Any exception thrown by
<del>the selected constructor of <tt>T<sub>i</sub></tt></del>
<ins>the initialization of the contained value</ins>.
</p>
<p>-34- <i>Remarks</i>:
If <tt>T<sub>I</sub></tt>’s selected constructor is a constexpr constructor,
this constructor is a constexpr constructor.
</p>
</blockquote>

<pre>
template&lt;size_t I, class U, class... Args&gt;
  constexpr explicit variant(in_place_index_t&lt;I&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>-35- <i>Constraints</i>:
<ol style="list-style-type: none">
<li>(35.1) &mdash; `I` is less than `sizeof...(Types)` and</li>
<li>(35.2) &mdash;
<code>is_constructible_v&lt;T<sub>I</sub>, initializer_list&lt;U&gt;&amp;, Args...&gt;</code>
is `true`.
</li>
</ol>
</p>
<p>-36- <i>Effects</i>:
Direct-non-list-initializes the contained value of type
<tt>T<sub>I</sub></tt> with <code>il, std::forward&lt;Args&gt;(args)...</code>.
</p>
<p>-37- <i>Postconditions</i>: `index()` is `I`.</p>
<p><ins>-?- <i>Throws</i>:
Any exception thrown by the initialization of the contained value.
</ins>
</p>
<p>-38- <i>Remarks</i>:
If <tt>T<sub>I</sub></tt>’s selected constructor is a constexpr constructor,
this constructor is a constexpr constructor.
</p>
</blockquote>
</blockquote>
</li>
</ol>

</resolution>

</issue>
