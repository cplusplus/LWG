<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4383" status="New">
<title>`constant_wrapper`'s pseudo-mutators are underconstrained
</title>
<section>
<sref ref="[const.wrap.class]"/>
</section>
<submitter>Hewill Kang</submitter>
<date>24 Sep 2025</date>
<priority>1</priority>

<discussion>
<p>
Unlike other operators, `constant_wrapper`'s pseudo-mutators only require that the wrapped type has
corresponding mutators, but do not require them to be <code>constexpr</code> or to return a sensible value.
This inconsistency loses the SFINAE friendliness (<a href="https://godbolt.org/z/r4z1GGT6f">demo</a>):
</p>
<blockquote><pre>
#include &lt;type_traits&gt;

void test(auto t) {
  if constexpr (requires { +t; })  // ok
    +t;
  if constexpr (requires { -t; })  // ok
    -t;
  if constexpr (requires { ++t; }) // <span style="color:#C80000;font-weight:bold">hard error</span>
    ++t;
  if constexpr (requires { --t; }) // <span style="color:#C80000;font-weight:bold">hard error</span>
    --t;
}

struct S {
  /* constexpr */ int operator+() const { return 0; }
  /* constexpr */ int operator++() { return 0; }
  constexpr void operator-() const { }
  constexpr void operator--() { }
};

int main() {
  test(std::cw&lt;S{}&gt;);
}
</pre></blockquote>
<p>
Since these pseudo-mutators have constraints, it is reasonable to further require constant
expressions.
</p>

<note>2025-10-17; Reflector poll.</note>
<p>
Set priority to 1 after reflector poll.
</p>
<p>
`operator+=` changed between <paper num="P2781R4"/> and <paper num="P2781R5"/>, intent is unclear.
</p>
<superseded>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>

<li><p>Modify <sref ref="[const.wrap.class]"/>, class template <tt>constant_wrapper</tt> synopsis, as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The requires clause follows the form of `constant_wrapper`'s
function call operator.]
</p>
</blockquote>

<blockquote>
<pre>
struct <i>cw-operators</i> {                                                           // <i>exposition only</i>
  [&hellip;]
  // <i>pseudo-mutators</i>
  template&lt;<i>constexpr-param</i> T&gt;
    constexpr auto operator++(this T) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>++x<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto c = T::value; return ++c; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T&gt;
    constexpr auto operator++(this T, int) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x++<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto c = T::value; return c++; }()&gt;{}; }

  template&lt;<i>constexpr-param</i> T&gt;
    constexpr auto operator--(this T) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>--x<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto c = T::value; return --c; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T&gt;
    constexpr auto operator--(this T, int) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x--<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto c = T::value; return c--; }()&gt;{}; }

  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator+=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x += R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v += R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator-=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x -= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v -= R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator*=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x *= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v *= R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator/=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x /= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v /= R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator%=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x %= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v %= R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator&amp;=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x &amp;= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v &amp;= R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator|=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x |= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v |= R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator^=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x ^= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v ^= R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator&lt;&lt;=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x &lt;&lt;= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v &lt;&lt;= R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator&gt;&gt;=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x &gt;&gt;= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v &gt;&gt;= R::value; }()&gt;{}; }
};
</pre>
</blockquote>

</li>

</ol>
</superseded>

<note>2025-11-05; Zach provides improved wording</note>

</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>

<li><p>Modify <sref ref="[const.wrap.class]"/>, class template <tt>constant_wrapper</tt> synopsis, as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The requires clause follows the form of `constant_wrapper`'s
function call operator.]
</p>
</blockquote>

<blockquote>
<pre>
  struct <i>cw-operators</i> {                                                           // <i>exposition only</i>
    [&hellip;]
    // <i>pseudo-mutators</i>
    <del>template&lt;<i>constexpr-param</i> T&gt;
      constexpr auto operator++(this T) noexcept requires requires(T::value_type x) { ++x; }
        { return constant_wrapper&lt;[] { auto c = T::value; return ++c; }()&gt;{}; }
    template&lt;<i>constexpr-param</i> T&gt;
      constexpr auto operator++(this T, int) noexcept requires requires(T::value_type x) { x++; }
        { return constant_wrapper&lt;[] { auto c = T::value; return c++; }()&gt;{}; }

    template&lt;<i>constexpr-param</i> T&gt;
      constexpr auto operator--(this T) noexcept requires requires(T::value_type x) { --x; }
        { return constant_wrapper&lt;[] { auto c = T::value; return --c; }()&gt;{}; }
    template&lt;<i>constexpr-param</i> T&gt;
      constexpr auto operator--(this T, int) noexcept requires requires(T::value_type x) { x--; }
        { return constant_wrapper&lt;[] { auto c = T::value; return c--; }()&gt;{}; }

    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator+=(this T, R) noexcept requires requires(T::value_type x) { x += R::value; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v += R::value; }()&gt;{}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator-=(this T, R) noexcept requires requires(T::value_type x) { x -= R::value; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v -= R::value; }()&gt;{}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator*=(this T, R) noexcept requires requires(T::value_type x) { x *= R::value; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v *= R::value; }()&gt;{}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator/=(this T, R) noexcept requires requires(T::value_type x) { x /= R::value; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v /= R::value; }()&gt;{}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator%=(this T, R) noexcept requires requires(T::value_type x) { x %= R::value; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v %= R::value; }()&gt;{}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator&amp;=(this T, R) noexcept requires requires(T::value_type x) { x &amp;= R::value; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v &amp;= R::value; }()&gt;{}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator|=(this T, R) noexcept requires requires(T::value_type x) { x |= R::value; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v |= R::value; }()&gt;{}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator^=(this T, R) noexcept requires requires(T::value_type x) { x ^= R::value; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v ^= R::value; }()&gt;{}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator&lt;&lt;=(this T, R) noexcept requires requires(T::value_type x) { x &lt;&lt;= R::value; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v &lt;&lt;= R::value; }()&gt;{}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator&gt;&gt;=(this T, R) noexcept requires requires(T::value_type x) { x &gt;&gt;= R::value; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v &gt;&gt;= R::value; }()&gt;{}; }</del>
    <ins>template&lt;<i>constexpr-param</i> T&gt;
      constexpr auto operator++(this T) noexcept -&gt; constant_wrapper&lt;++Y&gt; { return {}; }
    template&lt;<i>constexpr-param</i> T&gt;
      constexpr auto operator++(this T, int) noexcept -&gt; constant_wrapper&lt;Y++&gt; { return {}; }
    template&lt;<i>constexpr-param</i> T&gt;
      constexpr auto operator--(this T) noexcept -&gt; constant_wrapper&lt;--Y&gt; { return {}; }
    template&lt;<i>constexpr-param</i> T&gt;
      constexpr auto operator--(this T, int) noexcept -&gt; constant_wrapper&lt;Y--&gt; { return {}; }

    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator+=(this T, R) noexcept -&gt; constant_wrapper&lt;(T::value += R::value)&gt; { return {}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator-=(this T, R) noexcept -&gt; constant_wrapper&lt;(T::value -= R::value)&gt; { return {}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator*=(this T, R) noexcept -&gt; constant_wrapper&lt;(T::value *= R::value)&gt; { return {}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator/=(this T, R) noexcept -&gt; constant_wrapper&lt;(T::value /= R::value)&gt; { return {}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator%=(this T, R) noexcept -&gt; constant_wrapper&lt;(T::value %= R::value)&gt; { return {}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator&amp;=(this T, R) noexcept -&gt; constant_wrapper&lt;(T::value &amp;= R::value)&gt; { return {}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator|=(this T, R) noexcept -&gt; constant_wrapper&lt;(T::value |= R::value)&gt; { return {}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator^=(this T, R) noexcept -&gt; constant_wrapper&lt;(T::value ^= R::value)&gt; { return {}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator&lt;&lt;=(this T, R) noexcept -&gt; constant_wrapper&lt;(T::value &lt;&lt;= R::value)&gt; { return {}; }
    template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
      constexpr auto operator&gt;&gt;=(this T, R) noexcept -&gt; constant_wrapper&lt;(T::value &gt;&gt;= R::value)&gt; { return {}; }</ins>
  };
}

template&lt;<i>cw-fixed-value</i> X, typename&gt;
struct constant_wrapper: <i>cw-operators</i> {
  static constexpr const auto &amp; value = X.<i>data</i>;
  using type = constant_wrapper;
  using value_type = typename decltype(X)::<i>type</i>;

  <del>template&lt;<i>constexpr-param</i> R&gt;
    constexpr auto operator=(R) const noexcept requires requires(value_type x) { x = R::value; }
      { return constant_wrapper&lt;[] { auto v = value; return v = R::value; }()&gt;{}; }</del>
  <ins>template&lt;<i>constexpr-param</i> R&gt;
    constexpr auto operator=(R) const noexcept -&gt; constant_wrapper&lt;X = R::value&gt; { return {}; }</ins>

  constexpr operator decltype(auto)() const noexcept { return value; }
};

</pre>
</blockquote>

</li>

</ol>

</resolution>

</issue>
