<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4297" status="Voting">
<title>Missing `permutable` constraint for iterator overloads in Parallel Range Algorithms</title>
<section><sref ref="[algorithm.syn]"/><sref ref="[alg.remove]"/><sref ref="[alg.partitions]"/></section>
<submitter>Ruslan Arutyunyan</submitter>
<date>27 Jun 2025</date>
<priority>99</priority>

<discussion>
<p>
The <paper num="P3179R9"/>: Parallel Range Algorithms paper was accepted to C++ working draft for C++ 26. 
Unfortunately, there is an oversight for three algorithms &mdash; `remove`, `remove_if` and `partition` &mdash; 
where the `permutable` constraint is missing. This applies to "Iterator and Sentinel" overloads only. The 
issue exists in <sref ref="[algorithm.syn]"/> as well as in per-algorithm sections: 
<sref ref="[alg.partitions]"/> and <sref ref="[alg.remove]"/>.
</p>

<note>2025-10-21; Reflector poll.</note>
<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>
</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5014"/>.
</p>


<ol>

<li><p>Modify <sref ref="[algorithm.syn]"/>, header <tt>&lt;algorithm&gt;</tt>, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;<i>execution-policy</i> Ep, random_access_iterator I, sized_sentinel_for&lt;I&gt; S,
         class Proj = identity, class T = projected_value_t&lt;I, Proj&gt;&gt;
  requires <ins>permutable&lt;I&gt; &amp;&amp;</ins>
           indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T*&gt;
  subrange&lt;I&gt; remove(Ep&amp; exec, I first, S last, const T&amp; value,
                     Proj proj = {}); <i>// freestanding-deleted</i>
template&lt;<i>execution-policy</i> Ep, <i>sized-random-access-range</i> R, class Proj = identity,
         class T = projected_value_t&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;
  requires permutable&lt;iterator_t&lt;R&gt;&gt; &amp;&amp;
           indirect_binary_predicate&lt;ranges::equal_to,
                                     projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
  borrowed_subrange_t&lt;R&gt;
    remove(Ep&amp;&amp; exec, R&amp;&amp; r, const T&amp; value, Proj proj = {}); <i>// freestanding-deleted</i>                                     
[&hellip;]
template&lt;<i>execution-policy</i> Ep, random_access_iterator I, sized_sentinel_for&lt;I&gt; S,
         class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  <ins>requires permutable&lt;I&gt;</ins>
  subrange&lt;I&gt;
    remove_if(Ep&amp; exec, I first, S last, Pred pred, Proj proj = {}); <i>// freestanding-deleted</i>
template&lt;<i>execution-policy</i> Ep, <i>sized-random-access-range</i> R, class Proj = identity,
         indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
  requires permutable&lt;iterator_t&lt;R&gt;&gt;
  borrowed_subrange_t&lt;R&gt;
    remove_if(Ep&amp; exec, R&amp; r, Pred pred, Proj proj = {}); <i>// freestanding-deleted</i>
[&hellip;]
template&lt;execution-policy Ep, random_access_iterator I, sized_sentinel_for&lt;I&gt; S,
         class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  <ins>requires permutable&lt;I&gt;</ins>
  subrange&lt;I&gt;
    partition(Ep&amp;&amp; exec, I first, S last, Pred pred, Proj proj = {}); <i>// freestanding-deleted</i>
template&lt;<i>execution-policy</i> Ep, <i>sized-random-access-range</i> R, class Proj = identity,
         indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
  requires permutable&lt;iterator_t&lt;R&gt;&gt;
  borrowed_subrange_t&lt;R&gt;
    partition(Ep&amp;&amp; exec, R&amp;&amp; r, Pred pred, Proj proj = {}); <i>// freestanding-deleted</i>
[&hellip;]
</pre>
</blockquote>
</li>


<li><p>Modify <sref ref="[alg.remove]"/> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;<i>execution-policy</i> Ep, random_access_iterator I, sized_sentinel_for&lt;I&gt; S,
         class Proj = identity, class T = projected_value_t&lt;I, Proj&gt;&gt;
  requires <ins>permutable&lt;I&gt; &amp;&amp;</ins>
           indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T*&gt;
  subrange&lt;I&gt; 
    ranges::remove(Ep&amp; exec, I first, S last, const T&amp; value, Proj proj = {});
template&lt;<i>execution-policy</i> Ep, <i>sized-random-access-range</i> R, class Proj = identity,
         class T = projected_value_t&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;
  requires permutable&lt;iterator_t&lt;R&gt;&gt; &amp;&amp;
           indirect_binary_predicate&lt;ranges::equal_to,
                                     projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
  borrowed_subrange_t&lt;R&gt;
    ranges::remove(Ep&amp;&amp; exec, R&amp;&amp; r, const T&amp; value, Proj proj = {});                                  
[&hellip;]
template&lt;<i>execution-policy</i> Ep, random_access_iterator I, sized_sentinel_for&lt;I&gt; S,
         class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  <ins>requires permutable&lt;I&gt;</ins>
  subrange&lt;I&gt;
    ranges::remove_if(Ep&amp; exec, I first, S last, Pred pred, Proj proj = {});
template&lt;<i>execution-policy</i> Ep, <i>sized-random-access-range</i> R, class Proj = identity,
         indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
  requires permutable&lt;iterator_t&lt;R&gt;&gt;
  borrowed_subrange_t&lt;R&gt;
    ranges::remove_if(Ep&amp; exec, R&amp; r, Pred pred, Proj proj = {});
</pre>
<blockquote>
<p>
-1- Let <tt><i>E</i></tt> be [&hellip;]
</p>
</blockquote>
</blockquote>
</li>


<li><p>Modify <sref ref="[alg.partitions]"/> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;execution-policy Ep, random_access_iterator I, sized_sentinel_for&lt;I&gt; S,
         class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  <ins>requires permutable&lt;I&gt;</ins>
  subrange&lt;I&gt;
    ranges::partition(Ep&amp;&amp; exec, I first, S last, Pred pred, Proj proj = {});
template&lt;<i>execution-policy</i> Ep, <i>sized-random-access-range</i> R, class Proj = identity,
         indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
  requires permutable&lt;iterator_t&lt;R&gt;&gt;
  borrowed_subrange_t&lt;R&gt;
    ranges::partition(Ep&amp;&amp; exec, R&amp;&amp; r, Pred pred, Proj proj = {});
</pre>
<blockquote>
<p>
-1- Let `proj` be `identity{}` for the overloads with no parameter named `proj`.
</p>
</blockquote>
</blockquote>
</li>

</ol>
</resolution>

</issue>
