<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4405" status="New">
<title>`mdspan` constructor should disallow derived to base conversions</title>
<section>
<sref ref="[mdspan.mdspan.cons]"/>
</section>
<submitter>Hewill Kang</submitter>
<date>05 Oct 2025</date>
<priority>3</priority>

<discussion>
<p>
Unlike `ranges::subrange` or `span`, `mdspan` syntactically allows a multidimensional
viewing base class via a derived class pointer (<a href="https://godbolt.org/z/c56h9fjs8">demo</a>):
</p>
<blockquote><pre>
#include &lt;span&gt;
#include &lt;ranges&gt;
#include &lt;mdspan&gt;

struct Base {};
struct Derived : Base {};
std::array&lt;Derived, 12&gt; arr;
std::ranges::subrange&lt;Base*&gt; s(arr); // error, slicing
std::span&lt;Base&gt; sp(arr.data(), arr.size()); // error, slicing
std::mdspan&lt;Base, std::dims&lt;1&gt;&gt; msp(arr.data(), arr.size()); // <span  style="color:#C80000;font-weight:bold">ok</span>
</pre></blockquote>
<p>
Given that we intend to reject object slicing for both `default_accessor` and
`aligned_accessor`, there seems no reason not to reject this invalid pointer 
arithmetic for `mdspan`.
</p>

<note>2025-10-23; Reflector poll.</note>
<p>
Set priority to 3 after reflector poll.
</p>
<p>
Even if `data_handle_type` is a pointer to `value_type`, this does not mean
that it points to contiguous range of `value_type` objects. Accessor may
provide different access parttern.
</p>
</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The exposition-only concept <code><i>convertible-to-non-slicing</i></code> comes from 
<sref ref="[range.subrange.general]"/>.]
</p>
</blockquote>

<ol>

<li><p>Modify <sref ref="[mdspan.mdspan.overview]"/> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class ElementType, class Extents, class LayoutPolicy = layout_right,
           class AccessorPolicy = default_accessor&lt;ElementType&gt;&gt;
  class mdspan {
  public:
    using extents_type = Extents;
    using layout_type = LayoutPolicy;
    using accessor_type = AccessorPolicy;
    using mapping_type = typename layout_type::template mapping&lt;extents_type&gt;;
    using element_type = ElementType;
    using value_type = remove_cv_t&lt;element_type&gt;;
    using index_type = typename extents_type::index_type;
    using size_type = typename extents_type::size_type;
    using rank_type = typename extents_type::rank_type;
    using data_handle_type = typename accessor_type::data_handle_type;
    using reference = typename accessor_type::reference;
    [&hellip;]
    template&lt;class... OtherIndexTypes&gt;
      constexpr explicit mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> ptr, OtherIndexTypes... exts);
    template&lt;class OtherIndexType, size_t N&gt;
      constexpr explicit(N != rank_dynamic())
        mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, span&lt;OtherIndexType, N&gt; exts);
    template&lt;class OtherIndexType, size_t N&gt;
      constexpr explicit(N != rank_dynamic())
        mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, const array&lt;OtherIndexType, N&gt;&amp; exts);
    constexpr mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, const extents_type&amp; ext);
    constexpr mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, const mapping_type&amp; m);
    constexpr mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, const mapping_type&amp; m, const accessor_type&amp; a);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify <sref ref="[mdspan.mdspan.cons]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;class... OtherIndexTypes&gt;
  constexpr explicit mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, OtherIndexTypes... exts);
</pre>
<blockquote>
<p>
-4- Let `N` be `sizeof...(OtherIndexTypes)`.
<p/>
-5- <i>Constraints</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class OtherIndexType, size_t N&gt;
  constexpr explicit(N != rank_dynamic())
    mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, span&lt;OtherIndexType, N&gt; exts);
template&lt;class OtherIndexType, size_t N&gt;
  constexpr explicit(N != rank_dynamic())
    mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, const array&lt;OtherIndexType, N&gt;&amp; exts);
</pre>
<blockquote>
<p>
-8- <i>Constraints</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
constexpr mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, const extents_type&amp; ext);
</pre>
<blockquote>
<p>
-11- <i>Constraints</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
constexpr mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, const mapping_type&amp; m);
</pre>
<blockquote>
<p>
-14- <i>Constraints</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
constexpr mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, const mapping_type&amp; m, const accessor_type&amp; a);
</pre>
<blockquote>
<p>
-17- <i>Preconditions</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>

</resolution>

</issue>
