<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4479" status="New">
<title>Missing restrictions on which types can be `tuple` elements</title>
<section><sref ref="[tuple.tuple.general]"/></section>
<submitter>Davis Herring</submitter>
<date>21 Nov 2025</date>
<priority>99</priority>

<discussion>
<p>
We do not say that instantiating types like <code>std::tuple&lt;void&gt;</code>
or <code>std::tuple&lt;int()&gt;</code> won't work.
</p>


<note>2025-11-26; Jonathan comments.</note>
<p>
<sref ref="[res.on.functions]"/> already makes it undefined behaviour to
instantiate `tuple` with an incomplete type, which includes `void` and `int[]`.
It would be better if it was ill-formed not undefined though, and that doesn't
say anything about <code>tuple&lt;int()&gt;</code> or
<code>tuple&lt;AbstractClassType&gt;</code>.
Any restrictions should only apply when `tuple` is instantiated,
not just when it's declared, as that would prevent using it as a typelist.
</p>
<p>
We might need to specify that `tuple_size` and `tuple_element` can be
instantiated with incomplete types that are specializations of `tuple`,
because otherwise <sref ref="[res.on.functions]"/> makes that undefined.
`tuple_size` and `tuple_element` don't need a complete `tuple` type
to give an answer, and they don't need to instantiate a `tuple` type.
So <code>tuple_element_t&lt;0, tuple&lt;void&gt;&gt;</code> should work.
</p>
</discussion>

<resolution>
<p>
</p>
</resolution>

</issue>
