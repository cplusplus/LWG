<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 4060: submdspan preconditions do not forbid creating invalid pointer</title>
<meta property="og:title" content="Issue 4060: submdspan preconditions do not forbid creating invalid pointer">
<meta property="og:description" content="C++ library issue. Status: New">
<meta property="og:url" content="https://cplusplus.github.io/LWG/issue4060.html">
<meta property="og:type" content="website">
<meta property="og:image" content="https://isocpp.org/assets/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<p><em>This page is a snapshot from the LWG issues list, see the <a href="lwg-active.html">Library Active Issues List</a> for more information and the meaning of <a href="lwg-active.html#New">New</a> status.</em></p>
<h3 id="4060"><a href="lwg-active.html#4060">4060</a>. <code>submdspan</code> preconditions do not forbid creating invalid pointer</h3>
<p><b>Section:</b> 24.7.3.7.7 <a href="https://wg21.link/mdspan.submdspan.submdspan">[mdspan.submdspan.submdspan]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Mark Hoemmen <b>Opened:</b> 2024-03-26 <b>Last modified:</b> 2024-03-26</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Oliver Lee and Ryan Wooster pointed out to us that creating a <code>submdspan</code> with zero-length 
tuple-like or <code>strided_slice</code> slice specifiers at the upper extent can cause <code>submdspan</code> 
to access the input <code>mdspan</code>'s mapping out of bounds. The resulting <code>mdspan</code> will have 
zero size and therefore <code>mdspan::operator[]</code> can't be called, but the offset computation is 
nevertheless invalid. In a constexpr context, the result is ill-formed; Clang actually reports a 
build error.
<p/>
Oliver and Ryan offer the following example and analysis.
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
Example 1:
</p>
<blockquote><pre>
auto x = std::array&lt;int, 3&gt;{};
auto A = mdspan{x.data(), extents{3}};
auto B = submdspan(A, pair{3, 3});
</pre></blockquote>
<p>
B is an <code>mdspan</code> with zero elements.
<p/>
Example 2:
</p>
<blockquote><pre>
auto y = std::array&lt;int, 9&gt;{};
auto C = mdspan{y.data(), extents{3, 3}};
auto D = submdspan(C, pair{3, 3}, pair{3, 3});
</pre></blockquote>
<p>
A precondition for each slice specifier is (24.7.3.7.5 <a href="https://wg21.link/mdspan.submdspan.extents">[mdspan.submdspan.extents]</a>):
</p>
<blockquote><pre>
0 &le; <i>first_</i>&lt;index_type, <i>k</i>&gt;(slices...) &le; <i>last_</i>&lt;<i>k</i>&gt;(src.extents(), slices...) &le; src.extent(<i>k</i>).
</pre></blockquote>
<p>
Our understanding is that precondition is satisfied. In the second example, <code><i>first_</i>&lt;0&gt;</code> 
is 3 and <code><i>first_</i>&lt;1&gt;</code> is also 3.
<p/>
However, the submapping offset is defined as <code>(*this)(<i>first_</i>&lt;index_type, P&gt;(slices...)...)</code>, 
which then can result in an invalid data handle of the <code>submdspan</code>, even if the data handle is never 
accessed/dereferenced.
<p/>
<a href="https://godbolt.org/z/zaMTbMEK7">godbolt demo</a>
</p>
</blockquote>
<p>
We comment further to explain why we expect this situation to come up often in practice.
<p/>
Consider the following use case:
<p/>
Suppose we have an <code>N x N</code> mdspan representing a matrix <code>A</code>, and we want to partition it 
into a <code>2 x 2</code> "matrix of matrices" (also called a "block matrix").
<p/>
This partitioning is a common operation in linear algebra algorithms such as matrix factorizations.
Examples of this <code>2 x 2</code> partitioning appear in <a href="https://wg21.link/P2642" title=" Padded mdspan layouts">P2642</a> and <a href="https://wg21.link/P1673" title=" A free function linear algebra interface based on the BLAS">P1673</a>.
</p>
<blockquote><pre>
mdspan A{A_ptr, N, N};
size_t p = partition_point(N); // <i>integer in 0, 1, &hellip;, N (inclusive)</i>
auto A_00 = submdspan(A, tuple{0, p}, tuple{0, p});
auto A_10 = submdspan(A, tuple{p, N}, tuple{0, 0});
auto A_01 = submdspan(A, tuple{0, p}, tuple{p, N});
auto A_11 = submdspan(A, tuple{p, N}, tuple{p, N});
</pre></blockquote>
<p>
Presented in table form:
</p>
<table border="1">
<tr>
  <td><code>A_00</code></td>
  <td><code>A_01</code></td>
</tr>
<tr>
  <td><code>A_10</code></td>
  <td><code>A_11</code></td>
</tr>
</table> 
<p>
It's valid for <code>p</code> to be <code>0</code>. That makes every block but <code>A_11</code> have zero size.
<p/>
Thus, it should also be valid for <code>p</code> to be <code>N</code>.
<p/>
That makes every block but <code>A_00</code> have zero size.
<p/>
However, that leads to the aforementioned UB.
<p/>
It doesn't make sense to change <code><i>first_</i></code> or <code><i>last_</i></code>. The definitions of 
<code><i>first_</i></code> and <code><i>last_</i></code> are meant to turn the slice specifier into a pair of bounds.
Since <code>submdspan(A, tuple{p, N}, tuple{p, N})</code> is valid even if <code>p</code> equals <code>N</code>,
then that strongly suggests that <code><i>first_</i>&lt;0&gt;</code> and <code><i>first_</i>&lt;1&gt;</code> 
should always be <code>p</code>, even if <code>p</code> equals <code>N</code>.
<p/>
The only other thing we can change is the offset. (<code>data_handle_type</code> doesn't have to be a pointer 
or even <code>default_initializable</code>.) If the result of <code>submdspan_extents</code> has <code>size()</code> zero, 
then the offset must also be zero.
<p/>
The offset is one of the return values of <code>submdspan_mapping</code>, which is a customization point.
However, we don't want users to have to remember to handle this case consistently.
Setting offset to zero depends only on the result's extents, not on its mapping, so it makes sense to handle 
it outside of the <code>submdspan_mapping</code> customization point.
</p>


<p id="res-4060"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages â€” C++">N4971</a>.
</p>

<ol>
<li><p>Modify 24.7.3.7.7 <a href="https://wg21.link/mdspan.submdspan.submdspan">[mdspan.submdspan.submdspan]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class ElementType, class Extents, class LayoutPolicy,
         class AccessorPolicy, class... SliceSpecifiers&gt;
  constexpr auto submdspan(
    const mdspan&lt;ElementType, Extents, LayoutPolicy, AccessorPolicy&gt;&amp; src,
    SliceSpecifiers... slices) -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
-1- Let <code>index_type</code> be <code>typename Extents::index_type</code>.
<p/>
-2- Let <code>sub_map_offset</code> be the result of <code>submdspan_mapping(src.mapping(), slices...)</code>.
<p/>
[&hellip;]
<p/>
-3- <i>Constraints</i>: [&hellip;]
<p/>
-4- <i>Mandates</i>: [&hellip;]
<p/>
-5-<i>Preconditions</i>: [&hellip;]
<p/>
-6- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
auto sub_map_offset = submdspan_mapping(src.mapping(), slices...);
<ins>size_t sub_offset = sub_map_offset.mapping.extents().size() == 0 ?
  sub_map_offset.mapping.required_span_size() :
  sub_map_offset.offset;</ins>
return mdspan(src.accessor().offset(src.data(), <ins>sub_offset</ins><del>sub_map_offset.offset</del>),
              sub_map_offset.mapping,
              AccessorPolicy::offset_policy(src.accessor()));
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>





</body>
</html>
