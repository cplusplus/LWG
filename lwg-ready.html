<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</title>
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<h1>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</h1>
<table>
<tr>
<td align="left">Doc. no.</td>
<td align="left">R0165???</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left">Revised 2024-07-31 at 11:17:11 UTC
</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Jonathan Wakely &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</table>
<h2>Ready Issues</h2>
<hr>
<h3 id="3436"><a href="#3436">3436</a><sup><a href="https://cplusplus.github.io/LWG/issue3436">(i)</a></sup>. <code>std::construct_at</code> should support arrays</h3>
<p><b>Section:</b> 27.11.8 <a href="https://wg21.link/specialized.construct">[specialized.construct]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2020-04-29 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#specialized.construct">active issues</a> in [specialized.construct].</p>
<p><b>View all other</b> <a href="lwg-index.html#specialized.construct">issues</a> in [specialized.construct].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>std::construct_at</code> is ill-formed for array types, because the type of the <code>new</code>-expression is <code>T</code> 
not <code>T*</code> so it cannot be converted to the return type.
<p/>
In C++17 <code>allocator_traits::construct</code> did work for arrays, because it returns <code>void</code> so there is no 
ill-formed conversion. On the other hand, in C++17 <code>allocator_traits::destroy</code> didn't work for arrays, 
because <code>p-&gt;~T()</code> isn't valid.
<p/>
In C++20 <code>allocator_traits::destroy</code> does work, because <code>std::destroy_at</code> treats arrays specially, 
but <code>allocator_traits::construct</code> no longer works because it uses <code>std::construct_at</code>.
<p/>
It seems unnecessary and/or confusing to remove support for arrays in <code>construct</code> when we're adding it in <code>destroy</code>.
<p/>
I suggest that <code>std::construct_at</code> should also handle arrays. It might be reasonable to restrict that 
support to the case where <code>sizeof...(Args) == 0</code>, if supporting parenthesized aggregate-initialization 
is not desirable in <code>std::construct_at</code>.
</p>

<p><i>[2020-05-09; Reflector prioritization]</i></p>

<p>
Set priority to 2 after reflector discussions.
</p>

<p><i>[2021-01-16; Zhihao Yuan provides wording]</i></p>


<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4878" title=" Working Draft, Standard for Programming Language C++">N4878</a>. 
</p>

<ol>
<li><p>Modify 27.11.8 <a href="https://wg21.link/specialized.construct">[specialized.construct]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class... Args&gt;
  constexpr T* construct_at(T* location, Args&amp;&amp;... args);

namespace ranges {
  template&lt;class T, class... Args&gt;
    constexpr T* construct_at(T* location, Args&amp;&amp;... args);
}
</pre>
<blockquote>
<p>
-1- <i>Constraints:</i> The expression <code>::new (declval&lt;void*&gt;()) T(declval&lt;Args&gt;()...)</code> is well-formed
when treated as an unevaluated operand.
<p/>
-2- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
<del>return</del><ins>auto ptr =</ins> ::new (<i>voidify</i>(*location)) T(std::forward&lt;Args&gt;(args)...);
<ins>if constexpr (is_array_v&lt;T&gt;)
  return launder(location);
else
  return ptr;</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2021-12-07; Zhihao Yuan comments and provides improved wording]</i></p>

<p>
The previous PR allows constructing arbitrary number of elements when
<code>T</code> is an array of unknown bound:</p>
<blockquote><pre>
extern int a[];
std::construct_at(&amp;a, 0, 1, 2);
</pre></blockquote>
<p>
and leads to a UB.
</p>
<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>. 
</p>

<ol>
<li><p>Modify 27.11.8 <a href="https://wg21.link/specialized.construct">[specialized.construct]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class... Args&gt;
  constexpr T* construct_at(T* location, Args&amp;&amp;... args);

namespace ranges {
  template&lt;class T, class... Args&gt;
    constexpr T* construct_at(T* location, Args&amp;&amp;... args);
}
</pre>
<blockquote>
<p>
-1- <i>Constraints:</i> The expression <code>::new (declval&lt;void*&gt;()) T(declval&lt;Args&gt;()...)</code> is well-formed
when treated as an unevaluated operand (7.2.3 <a href="https://wg21.link/expr.context">[expr.context]</a>) <ins>and <code>is_unbounded_array_v&lt;T&gt;</code> is 
<code>false</code></ins>.
<p/>
-2- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
<del>return</del><ins>auto ptr =</ins> ::new (<i>voidify</i>(*location)) T(std::forward&lt;Args&gt;(args)...);
<ins>if constexpr (is_array_v&lt;T&gt;)
  return launder(location);
else
  return ptr;</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2024-03-18; Jonathan provides new wording]</i></p>

<p>
During Core review in Varna, Hubert suggested creating <code class='backtick'>T[1]</code> for the array case.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>
<li><p>Modify 27.11.8 <a href="https://wg21.link/specialized.construct">[specialized.construct]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class... Args&gt;
  constexpr T* construct_at(T* location, Args&amp;&amp;... args);

namespace ranges {
  template&lt;class T, class... Args&gt;
    constexpr T* construct_at(T* location, Args&amp;&amp;... args);
}
</pre>
<blockquote>
<p>
-1- <i>Constraints:</i>
<ins><code>is_unbounded_array_v&lt;T&gt;</code> is <code>false</code>.</ins>
The expression <code>::new (declval&lt;void*&gt;()) T(declval&lt;Args&gt;()...)</code> is well-formed
when treated as an unevaluated operand (7.2.3 <a href="https://wg21.link/expr.context">[expr.context]</a>).
<p/>
-2- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
<ins>if constexpr (is_array_v&lt;T&gt;)
  return ::new (<i>voidify</i>(*location)) T[1]{{std::forward&lt;Args&gt;(args)...}};
else</ins>
  return ::new (<i>voidify</i>(*location)) T(std::forward&lt;Args&gt;(args)...);
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[St. Louis 2024-06-24; Jonathan provides improved wording]</i></p>

<p>
Why not support unbounded arrays, deducing the bound from <code class='backtick'>sizeof...(Args)</code>?
<br/>
JW: There's no motivation to support that here in <code class='backtick'>construct_at</code>.
It isn't possible to create unbounded arrays via allocators,
nor via any of the <code class='backtick'>uninitialized_xxx</code> algorithms. Extending <code class='backtick'>construct_at</code>
that way seems like a design change, not restoring support for something
that used to work with allocators and then got broken in C++20.
</p>
<p>
Tim observed that the proposed resolution is ill-formed if <code class='backtick'>T</code> has an
explicit default constructor. Value-initialization would work for that case,
and there seems to be little motivation for supplying arguments to
initialize the array. In C++17 the <code class='backtick'>allocator_traits::construct</code> case only
supported value-initialization.
</p>

<p><i>[St. Louis 2024-06-24; move to Ready.]</i></p>



<p id="res-3436"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages — C++">N4981</a>.
</p>

<ol>
<li><p>Modify 27.11.8 <a href="https://wg21.link/specialized.construct">[specialized.construct]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class... Args&gt;
  constexpr T* construct_at(T* location, Args&amp;&amp;... args);

namespace ranges {
  template&lt;class T, class... Args&gt;
    constexpr T* construct_at(T* location, Args&amp;&amp;... args);
}
</pre>
<blockquote>
<p>
-1- <i>Constraints:</i>
<ins><code>is_unbounded_array_v&lt;T&gt;</code> is <code>false</code>.</ins>
The expression <code>::new (declval&lt;void*&gt;()) T(declval&lt;Args&gt;()...)</code> is well-formed
when treated as an unevaluated operand (7.2.3 <a href="https://wg21.link/expr.context">[expr.context]</a>).
</p>
<p>
<ins>-?- <i>Mandates</i>:
If <code>is_array_v&lt;T&gt;</code> is <code class='backtick'>true</code>, <code class='backtick'>sizeof...(Args)</code> is zero.
</ins>
</p>
<p>
-2- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
<ins>if constexpr (is_array_v&lt;T&gt;)
  return ::new (<i>voidify</i>(*location)) T[1]();
else</ins>
  return ::new (<i>voidify</i>(*location)) T(std::forward&lt;Args&gt;(args)...);
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3 id="3899"><a href="#3899">3899</a><sup><a href="https://cplusplus.github.io/LWG/issue3899">(i)</a></sup>. <code>co_yield</code>ing elements of an lvalue <code>generator</code> is unnecessarily inefficient</h3>
<p><b>Section:</b> 26.8.5 <a href="https://wg21.link/coro.generator.promise">[coro.generator.promise]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2023-03-04 <b>Last modified:</b> 2024-06-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#coro.generator.promise">active issues</a> in [coro.generator.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#coro.generator.promise">issues</a> in [coro.generator.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider:
</p>
<blockquote>
<pre>
std::generator&lt;int&gt; f();
std::generator&lt;int&gt; g() {
    auto gen = f();
    auto gen2 = f();
    co_yield std::ranges::elements_of(std::move(gen));   // #1
    co_yield std::ranges::elements_of(gen2);             // #2
    // other stuff
}
</pre>
</blockquote>
<p>
Both #1 and #2 compile. The differences are:
</p>
<ul>
<li>
<p>
#2 is significantly less efficient (it uses the general overload of <code>yield_value</code>,
so it creates a new coroutine frame and doesn't do symmetric transfer into <code>gen2</code>'s coroutine)
</p>
</li>
<li>
<p>
the coroutine frame of <code>gen</code> and <code>gen2</code> are destroyed at different
times: <code>gen</code>'s frame is destroyed at the end of #1, but <code>gen2</code>'s is
not destroyed until the closing brace.
</p>
</li>
</ul>
<p>
But as far as the user is concerned, neither <code>gen</code> nor <code>gen2</code> is
usable after the <code>co_yield</code>. In both cases the only things you can do
with the objects are:
</p>
<ul>
<li><p>destroying them;</p></li>
<li><p>assigning to them;</p></li>
<li><p>call <code>end()</code> on them to get a copy of <code>default_sentinel</code>.</p></li>
</ul>
<p>
We could make #2 ill-formed, but that seems unnecessary: there is no meaningful
difference between <code>generator</code> and any other single-pass input range
(or a <code>generator</code> with a different yielded type that has to go through
the general overload) in this regard. We should just make #2 do the efficient
thing too.
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[St. Louis 2024-06-28; move to Ready]</i></p>




<p id="res-3899"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<ol>

<li><p>Modify 26.8.5 <a href="https://wg21.link/coro.generator.promise">[coro.generator.promise]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std {
  template&lt;class Ref, class V, class Allocator&gt;
  class generator&lt;Ref, V, Allocator&gt;::promise_type {
  public:
    [&hellip;]
    auto yield_value(const remove_reference_t&lt;yielded&gt;&amp; lval)
      requires is_rvalue_reference_v&lt;yielded&gt; &amp;&amp;
        constructible_from&lt;remove_cvref_t&lt;yielded&gt;, const remove_reference_t&lt;yielded&gt;&amp;&gt;;

    template&lt;class R2, class V2, class Alloc2, class Unused&gt;
      requires same_as&lt;typename generator&lt;R2, V2, Alloc2&gt;::yielded, yielded&gt;
        auto yield_value(ranges::elements_of&lt;generator&lt;R2, V2, Alloc2&gt;&amp;&amp;, Unused&gt; g) noexcept;
<ins>    template&lt;class R2, class V2, class Alloc2, class Unused&gt;
      requires same_as&lt;typename generator&lt;R2, V2, Alloc2&gt;::yielded, yielded&gt;
        auto yield_value(ranges::elements_of&lt;generator&lt;R2, V2, Alloc2&gt;&amp;, Unused&gt; g) noexcept;</ins>

    template&lt;ranges::input_range R, class Alloc&gt;
      requires convertible_to&lt;ranges::range_reference_t&lt;R&gt;, yielded&gt;
        auto yield_value(ranges::elements_of&lt;R, Alloc&gt; r) noexcept;
    [&hellip;]
   };
}
</pre>
</blockquote>
[&hellip;]
<pre>
template&lt;class R2, class V2, class Alloc2, class Unused&gt;
  requires same_as&lt;typename generator&lt;R2, V2, Alloc2&gt;::yielded, yielded&gt;
  auto yield_value(ranges::elements_of&lt;generator&lt;R2, V2, Alloc2&gt;&amp;&amp;, Unused&gt; g) noexcept;
<ins>template&lt;class R2, class V2, class Alloc2, class Unused&gt;
  requires same_as&lt;typename generator&lt;R2, V2, Alloc2&gt;::yielded, yielded&gt;
  auto yield_value(ranges::elements_of&lt;generator&lt;R2, V2, Alloc2&gt;&amp;, Unused&gt; g) noexcept;</ins>
</pre>
<blockquote>
<p>
-10- <i>Preconditions</i>: A handle referring to the coroutine whose promise object
is <code>*this</code> is at the top of <code>*<i>active_</i></code> of some generator
object <code>x</code>. The coroutine referred to by <code>g.range.<i>coroutine_</i></code>
is suspended at its initial suspend point.
<p/>
-11- <i>Returns:</i> An awaitable object of an unspecified type (7.6.2.4 <a href="https://wg21.link/expr.await">[expr.await]</a>)
into which <code>g.range</code> is moved, whose member <code>await_ready</code> returns <code>false</code>,
whose member <code>await_suspend</code> pushes <code>g.range.<i>coroutine_</i></code> into <code>*x.<i>active_</i></code>
and resumes execution of the coroutine referred to by <code>g.range.<i>coroutine_</i></code>,
and whose member <code>await_resume</code> evaluates <code>rethrow_exception(<i>except_</i>)</code>
if <code>bool(<i>except_</i>)</code> is <code>true</code>. If <code>bool(<i>except_</i>)</code> is <code>false</code>,
the <code>await_resume</code> member has no effects.
<p/>
-12- <i>Remarks</i>: A <i>yield-expression</i> that calls
<del>this function</del><ins>one of these functions</ins> has type
<code>void</code> (7.6.17 <a href="https://wg21.link/expr.yield">[expr.yield]</a>).
</p>
</blockquote>
</blockquote>

</li>


</ol>





<hr>
<h3 id="3900"><a href="#3900">3900</a><sup><a href="https://cplusplus.github.io/LWG/issue3900">(i)</a></sup>. The <code>allocator_arg_t</code> overloads of <code>generator::promise_type::operator new</code>
should not be constrained</h3>
<p><b>Section:</b> 26.8.5 <a href="https://wg21.link/coro.generator.promise">[coro.generator.promise]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2023-03-04 <b>Last modified:</b> 2024-06-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#coro.generator.promise">active issues</a> in [coro.generator.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#coro.generator.promise">issues</a> in [coro.generator.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When the allocator is not type-erased, the <code>allocator_arg_t</code> overloads of
<code>generator::promise_type::operator new</code> are constrained on
<code>convertible_to&lt;const Alloc&amp;, Allocator&gt;</code>. As a result, if the
the allocator is default-constructible (like <code>polymorphic_allocator</code> is)
but the user accidentally provided a wrong type (say, <code>memory_resource&amp;</code>
instead of <code>memory_resource*</code>), their code will silently fall back to
using a default-constructed allocator. It would seem better to take the tag
as definitive evidence of the user's intent to supply an allocator for the coroutine,
and error out if the supplied allocator cannot be used.
<p/>
This change does mean that the user cannot deliberately pass an incompatible
allocator (preceded by an <code>std::allocator_arg_t</code> tag) for their own use
inside the coroutine, but that sort of API seems fragile and confusing at best,
since the usual case is that allocators so passed <i>will</i> be used by
<code>generator</code>.
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[St. Louis 2024-06-28; move to Ready]</i></p>




<p id="res-3900"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<ol>

<li><p>Modify 26.8.5 <a href="https://wg21.link/coro.generator.promise">[coro.generator.promise]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std {
  template&lt;class Ref, class V, class Allocator&gt;
  class generator&lt;Ref, V, Allocator&gt;::promise_type {
  public:
    [&hellip;]
    void* operator new(size_t size)
      requires same_as&lt;Allocator, void&gt; || default_initializable&lt;Allocator&gt;;

    template&lt;class Alloc, class... Args&gt;
      <del>requires same_as&lt;Allocator, void&gt; || convertible_to&lt;const Alloc&amp;, Allocator&gt;</del>
        void* operator new(size_t size, allocator_arg_t, const Alloc&amp; alloc, const Args&amp;...);

    template&lt;class This, class Alloc, class... Args&gt;
      <del>requires same_as&lt;Allocator, void&gt; || convertible_to&lt;const Alloc&amp;, Allocator&gt;</del>
        void* operator new(size_t size, const This&amp;, allocator_arg_t, const Alloc&amp; alloc,
                           const Args&amp;...);
    [&hellip;]
   };
}
</pre>
</blockquote>
[&hellip;]
<pre>
void* operator new(size_t size)
  requires same_as&lt;Allocator, void&gt; || default_initializable&lt;Allocator&gt;;

template&lt;class Alloc, class... Args&gt;
  <del>requires same_as&lt;Allocator, void&gt; || convertible_to&lt;const Alloc&amp;, Allocator&gt;</del>
  void* operator new(size_t size, allocator_arg_t, const Alloc&amp; alloc, const Args&amp;...);

template&lt;class This, class Alloc, class... Args&gt;
  <del>requires same_as&lt;Allocator, void&gt; || convertible_to&lt;const Alloc&amp;, Allocator&gt;</del>
  void* operator new(size_t size, const This&amp;, allocator_arg_t, const Alloc&amp; alloc,
                     const Args&amp;...);
</pre>
<blockquote>
<p>
-17- Let <code>A</code> be
</p>
<ol style="list-style-type: none">
  <li><p>(17.1) &mdash; <code>Allocator</code>, if it is not <code>void</code>,</p></li>
  <li><p>(17.2) &mdash; <code>Alloc</code> for the overloads with a template parameter <code>Alloc</code>, or</p></li>
  <li><p>(17.3) &mdash; <code>allocator&lt;void&gt;</code> otherwise.</p></li>
</ol>
<p>
Let <code>B</code> be <code>allocator_traits&lt;A&gt;::template rebind_alloc&lt;U&gt;</code>
where <code>U</code> is an unspecified type whose size and alignment are both
<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>.
<p/>
-18- <i>Mandates</i>: <code>allocator_traits&lt;B&gt;::pointer</code> is a pointer type.
<ins>For the overloads with a template parameter <code>Alloc</code>,
<code>same_as&lt;Allocator, void&gt; || convertible_to&lt;const Alloc&amp;, Allocator&gt;</code> is modeled.</ins>
<p/>
-19- <i>Effects</i>: Initializes an allocator <code>b</code> of type <code>B</code> with <code>A(alloc)</code>,
for the overloads with a function parameter <code>alloc</code>, and with <code>A()</code> otherwise.
Uses <code>b</code> to allocate storage for the smallest array of <code>U</code> sufficient
to provide storage for a coroutine state of size <code>size</code>, and unspecified
additional state necessary to ensure that <code>operator delete</code> can later
deallocate this memory block with an allocator equal to <code>b</code>.
<p/>
-20- <i>Returns:</i> A pointer to the allocated storage.
</p>

</blockquote>
</blockquote>


</li>


</ol>





<hr>
<h3 id="3918"><a href="#3918">3918</a><sup><a href="https://cplusplus.github.io/LWG/issue3918">(i)</a></sup>. <code>std::uninitialized_move/_n</code> and guaranteed copy elision</h3>
<p><b>Section:</b> 27.11.6 <a href="https://wg21.link/uninitialized.move">[uninitialized.move]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-04-04 <b>Last modified:</b> 2024-06-26</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently <code>std::move</code> is unconditionally used in <code>std::uninitialized_move</code> and <code>std::uninitialized_move_n</code>, 
which may involve unnecessary move construction if dereferencing the input iterator yields a prvalue.
<p/>
The status quo was mentioned in <a href="https://github.com/cplusplus/papers/issues/975#issuecomment-990323753">paper issue #975</a>, 
but no further process is done since then.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll. Send to LEWG.
</p>
<p>
"<a href="https://wg21.link/P2283" title=" constexpr for specialized memory algorithms">P2283</a> wants to remove guaranteed elision here."
"Poorly motivated, not clear anybody is using these algos with proxy iterators."
"Consider using <code>iter_move</code> in the move algos."
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<ol>
<li>
<p>Modify 27.11.1 <a href="https://wg21.link/specialized.algorithms.general">[specialized.algorithms.general]</a> as indicated:</p>

<blockquote>
<p>
-3- Some algorithms specified in 27.11 <a href="https://wg21.link/specialized.algorithms">[specialized.algorithms]</a> make use of the <ins>following</ins> exposition-only 
function<ins>s</ins> <del><code><i>voidify</i></code></del>:
</p>
<blockquote><pre>
template&lt;class T&gt;
  constexpr void* <i>voidify</i>(T&amp; obj) noexcept {
    return addressof(obj);
  }
  
<ins>template&lt;class I&gt;
  decltype(auto) <i>deref-move</i>(const I&amp; it) {
    if constexpr (is_lvalue_reference_v&lt;decltype(*it)&gt;)
      return std::move(*it);
    else
      return *it;
  }</ins>
</pre></blockquote>
</blockquote>
</li>

<li>
<p>Modify 27.11.6 <a href="https://wg21.link/uninitialized.move">[uninitialized.move]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator, class NoThrowForwardIterator&gt;
  NoThrowForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                            NoThrowForwardIterator result);
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: <code>result + [0, (last - first))</code> does not overlap with <code>[first, last)</code>.
<p/>
-2- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
for (; first != last; (void)++result, ++first)
  ::new (<i>voidify</i>(*result))
    typename iterator_traits&lt;NoThrowForwardIterator&gt;::value_type(<del>std::move(*</del><ins><i>deref-move</i>(</ins>first));
return result;
</pre></blockquote>
</blockquote>
[&hellip;]
<pre>
template&lt;class InputIterator, class Size, class NoThrowForwardIterator&gt;
  pair&lt;InputIterator, NoThrowForwardIterator&gt;
    uninitialized_move_n(InputIterator first, Size n, NoThrowForwardIterator result);
</pre>
<blockquote>
<p>
-6- <i>Preconditions</i>: <code>result + [0, n)</code> does not overlap with <code>first + [0, n)</code>.
<p/>
-7- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
for (; n &gt; 0; ++result,(void) ++first, --n)
  ::new (<i>voidify</i>(*result))
    typename iterator_traits&lt;NoThrowForwardIterator&gt;::value_type(<del>std::move(*</del><ins><i>deref-move</i>(</ins>first));
return {first, result};
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2024-03-22; Tokyo: Jonathan updates wording after LEWG review]</i></p>

<p>
LEWG agrees it would be good to do this.
Using <code class='backtick'>iter_move</code> was discussed, but it was noted that the versions of these
algos in the <code class='backtick'>ranges</code> namespace already use it and introducing
<code class='backtick'>ranges::iter_move</code> into the non-ranges versions wasn't desirable.
It was observed that the proposed <em>deref-move</em> has a
<code>const I&amp;</code> parameter which would be ill-formed for any iterator
with a non-const <code class='backtick'>operator*</code> member. Suggested removing the const and
recommended LWG to accept the proposed resolution.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>
<li>
<p>Modify 27.11.1 <a href="https://wg21.link/specialized.algorithms.general">[specialized.algorithms.general]</a> as indicated:</p>

<blockquote>
<p>
-3- Some algorithms specified in 27.11 <a href="https://wg21.link/specialized.algorithms">[specialized.algorithms]</a> make use of the <ins>following</ins> exposition-only 
function<ins>s</ins> <del><code><i>voidify</i></code></del>:
</p>
<blockquote><pre>
template&lt;class T&gt;
  constexpr void* <i>voidify</i>(T&amp; obj) noexcept {
    return addressof(obj);
  }
  
<ins>template&lt;class I&gt;
  decltype(auto) <i>deref-move</i>(I&amp; it) {
    if constexpr (is_lvalue_reference_v&lt;decltype(*it)&gt;)
      return std::move(*it);
    else
      return *it;
  }</ins>
</pre></blockquote>
</blockquote>
</li>

<li>
<p>Modify 27.11.6 <a href="https://wg21.link/uninitialized.move">[uninitialized.move]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator, class NoThrowForwardIterator&gt;
  NoThrowForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                            NoThrowForwardIterator result);
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: <code>result + [0, (last - first))</code> does not overlap with <code>[first, last)</code>.
<p/>
-2- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
for (; first != last; (void)++result, ++first)
  ::new (<i>voidify</i>(*result))
    typename iterator_traits&lt;NoThrowForwardIterator&gt;::value_type(<del>std::move(*</del><ins><i>deref-move</i>(</ins>first));
return result;
</pre></blockquote>
</blockquote>
[&hellip;]
<pre>
template&lt;class InputIterator, class Size, class NoThrowForwardIterator&gt;
  pair&lt;InputIterator, NoThrowForwardIterator&gt;
    uninitialized_move_n(InputIterator first, Size n, NoThrowForwardIterator result);
</pre>
<blockquote>
<p>
-6- <i>Preconditions</i>: <code>result + [0, n)</code> does not overlap with <code>first + [0, n)</code>.
<p/>
-7- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
for (; n &gt; 0; ++result,(void) ++first, --n)
  ::new (<i>voidify</i>(*result))
    typename iterator_traits&lt;NoThrowForwardIterator&gt;::value_type(<del>std::move(*</del><ins><i>deref-move</i>(</ins>first));
return {first, result};
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[St. Louis 2024-06-24; revert P/R and move to Ready]</i></p>

<p>
Tim observed that the iterator requirements require all iterators to be
const-dereferenceable, so there was no reason to remove the const.
Restore the original resolution and move to Ready.
</p>



<p id="res-3918"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>
<li>
<p>Modify 27.11.1 <a href="https://wg21.link/specialized.algorithms.general">[specialized.algorithms.general]</a> as indicated:</p>

<blockquote>
<p>
-3- Some algorithms specified in 27.11 <a href="https://wg21.link/specialized.algorithms">[specialized.algorithms]</a> make use of the <ins>following</ins> exposition-only 
function<ins>s</ins> <del><code><i>voidify</i></code></del>:
</p>
<blockquote><pre>
template&lt;class T&gt;
  constexpr void* <i>voidify</i>(T&amp; obj) noexcept {
    return addressof(obj);
  }

<ins>template&lt;class I&gt;
  decltype(auto) <i>deref-move</i>(I&amp; it) {
    if constexpr (is_lvalue_reference_v&lt;decltype(*it)&gt;)
      return std::move(*it);
    else
      return *it;
  }</ins>
</pre></blockquote>
</blockquote>
</li>

<li>
<p>Modify 27.11.6 <a href="https://wg21.link/uninitialized.move">[uninitialized.move]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator, class NoThrowForwardIterator&gt;
  NoThrowForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                            NoThrowForwardIterator result);
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: <code>result + [0, (last - first))</code> does not overlap with <code>[first, last)</code>.
<p/>
-2- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
for (; first != last; (void)++result, ++first)
  ::new (<i>voidify</i>(*result))
    typename iterator_traits&lt;NoThrowForwardIterator&gt;::value_type(<del>std::move(*</del><ins><i>deref-move</i>(</ins>first));
return result;
</pre></blockquote>
</blockquote>
[&hellip;]
<pre>
template&lt;class InputIterator, class Size, class NoThrowForwardIterator&gt;
  pair&lt;InputIterator, NoThrowForwardIterator&gt;
    uninitialized_move_n(InputIterator first, Size n, NoThrowForwardIterator result);
</pre>
<blockquote>
<p>
-6- <i>Preconditions</i>: <code>result + [0, n)</code> does not overlap with <code>first + [0, n)</code>.
<p/>
-7- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
for (; n &gt; 0; ++result,(void) ++first, --n)
  ::new (<i>voidify</i>(*result))
    typename iterator_traits&lt;NoThrowForwardIterator&gt;::value_type(<del>std::move(*</del><ins><i>deref-move</i>(</ins>first));
return {first, result};
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4027"><a href="#4027">4027</a><sup><a href="https://cplusplus.github.io/LWG/issue4027">(i)</a></sup>. <code><i>possibly-const-range</i></code> should prefer returning <code>const R&amp;</code></h3>
<p><b>Section:</b> 26.2 <a href="https://wg21.link/ranges.syn">[ranges.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-12-17 <b>Last modified:</b> 2024-06-28</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#ranges.syn">active issues</a> in [ranges.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#ranges.syn">issues</a> in [ranges.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code><i>possibly-const-range</i></code> currently only returns <code>const R&amp;</code> when <code>R</code> does not 
satisfy <code>constant_range</code> and <code>const R</code> satisfies <code>constant_range</code>.
<p/>
Although it's not clear why we need the former condition, this does diverge from the legacy <code>std::cbegin</code> 
(<a href="https://godbolt.org/z/636osY7os">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;

int main() {
  auto r = std::views::single(0)
        | std::views::transform([](int) { return 0; });
  using C1 = decltype(std::ranges::cbegin(r));
  using C2 = decltype(std::cbegin(r));
  static_assert(std::same_as&lt;C1, C2&gt;); // <span style="color:red;font-weight:bolder">failed</span>
}
</pre></blockquote>
<p>
Since <code>R</code> itself is <code>constant_range</code>, so <code><i>possibly-const-range</i></code>, above just returns 
<code>R&amp;</code> and <code>C1</code> is <code>transform_view::<i>iterator</i>&lt;false&gt;</code>; <code>std::cbegin</code> 
specifies to return <code>as_const(r).begin()</code>, which makes that <code>C2</code> is 
<code>transform_view::<i>iterator</i>&lt;true&gt;</code> which is different from <code>C1</code>.
<p/>
I believe <code>const R&amp;</code> should always be returned if it's a range, regardless of whether <code>const R</code> 
or <code>R</code> is a <code>constant_range</code>, just as <code><i>fmt-maybe-const</i></code> in format ranges always prefers 
<code>const R</code> over <code>R</code>.
<p/>
Although it is theoretically possible for <code>R</code> to satisfy <code>constant_range</code> and that <code>const R</code> 
is a mutable range, such nonsense range type should not be of interest.
<p/>
This relaxation of constraints allows for maximum consistency with <code>std::cbegin</code>, and in some cases can 
preserve constness to the greatest extent (<a href="https://godbolt.org/z/3hYToMq35">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;

int main() {
  auto r = std::views::single(0) | std::views::lazy_split(0);
  (*std::ranges::cbegin(r)).front() = 42; // ok
  (*std::cbegin(r)).front() = 42; // <span style="color:red;font-weight:bolder">not ok</span>
}
</pre></blockquote>
<p>
Above, <code>*std::ranges::cbegin</code> returns a range of type <code>const lazy_split_view::<i>outer-iterator</i>&lt;false&gt;::value_type</code>, 
which does not satisfy <code>constant_range</code> because its reference type is <code>int&amp;</code>.
<p/>
However, <code>*std::cbegin(r)</code> returns <code>lazy_split_view::<i>outer-iterator</i>&lt;true&gt;::value_type</code> 
whose reference type is <code>const int&amp;</code> and satisfies <code>constant_range</code>.
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll. Send to SG9.
</p>

<p><i>[St. Louis 2024-06-28; LWG and SG9 joint session: move to Ready]</i></p>




<p id="res-4027"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>

<li><p>Modify 26.2 <a href="https://wg21.link/ranges.syn">[ranges.syn]</a>, header <code>&lt;ranges&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
#include &lt;compare&gt;              // <i>see 17.11.1 <a href="https://wg21.link/compare.syn">[compare.syn]</a></i>
#include &lt;initializer_list&gt;     // <i>see 17.10.2 <a href="https://wg21.link/initializer.list.syn">[initializer.list.syn]</a></i>
#include &lt;iterator&gt;             // <i>see 25.2 <a href="https://wg21.link/iterator.synopsis">[iterator.synopsis]</a></i>

namespace std::ranges {
  [&hellip;]

  // <i>26.7.22 <a href="https://wg21.link/range.as.const">[range.as.const]</a>, as const view</i>
  template&lt;input_range R&gt;
    constexpr auto&amp; <i>possibly-const-range</i>(R&amp; r) noexcept { // <i>exposition only</i>
      if constexpr (<ins>input</ins><del>constant</del>_range&lt;const R&gt;<del> &amp;&amp; !constant_range&lt;R&gt;</del>) {
        return const_cast&lt;const R&amp;&gt;(r);
      } else {
        return r;
      }
    }

  [&hellip;]
}
</pre>
</blockquote>
</li>

</ol>







<hr>
<h3 id="4044"><a href="#4044">4044</a><sup><a href="https://cplusplus.github.io/LWG/issue4044">(i)</a></sup>. Confusing requirements for <code>std::print</code> on POSIX platforms</h3>
<p><b>Section:</b> 31.7.10 <a href="https://wg21.link/print.fun">[print.fun]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2024-01-24 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#print.fun">active issues</a> in [print.fun].</p>
<p><b>View all other</b> <a href="lwg-index.html#print.fun">issues</a> in [print.fun].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The effects for <code>vprintf_unicode</code> say:
</p>

<blockquote>
<p>
If <code>stream</code> refers to a terminal capable of displaying Unicode,
writes <code>out</code> to the terminal using the native Unicode API;
if <code>out</code> contains invalid code units, the behavior is undefined
and implementations are encouraged to diagnose it.
Otherwise writes <code>out</code> to <code>stream</code> unchanged.
If the native Unicode API is used, the function flushes <code>stream</code>
before writing <code>out</code>.
</p>
<p>
[<i>Note 1</i>:
On POSIX and Windows, <code>stream</code> referring to a terminal means that,
respectively, <code>isatty(fileno(stream))</code> and
<code>GetConsoleMode(_get_osfhandle(_fileno(stream)), ...)</code>
return nonzero.
&mdash; <i>end note</i>]
</p>
<p>
[<i>Note 2</i>:
On Windows, the native Unicode API is <code>WriteConsoleW</code>.
&mdash; <i>end note</i>]
</p>
<p>-8-
<i>Throws</i>:  [...]
</p>
<p>-9-
<i>Recommended practice</i>:
If invoking the native Unicode API requires transcoding, implementations
should substitute invalid code units with
<span style="font-variant: small-caps">u+fffd replacement character</span>
per the Unicode Standard, Chapter 3.9
<span style="font-variant: small-caps">u+fffd</span> Substitution in Conversion.
</p>
</blockquote>

<p>
The very explicit mention of <code>isatty</code> for POSIX platforms has
confused at least two implementers into thinking that we're supposed to
use <code>isatty</code>, and supposed to do something differently based
on what it returns. That seems consistent with the nearly identical wording
in 22.14.2.2 <a href="https://wg21.link/format.string.std">[format.string.std]</a> paragraph 12, which says
"Implementations should use either UTF-8, UTF-16, or UTF-32,
on platforms <u>capable of displaying Unicode text in a terminal</u>"
and then has a note explicitly saying this is the case for Windows-based and
many POSIX-based operating systems. So it seems clear that POSIX platforms
are supposed to be considered to have "a terminal capable of displaying
Unicode text", and so <code>std::print</code> should use <code>isatty</code>
and then use a native Unicode API, and diagnose invalid code units.
</p>
<p>
This is a problem however, because <code>isatty</code> needs
to make a system call on Linux, adding 500ns to every <code>std::print</code>
call. This results in a 10x slowdown on Linux, where <code>std::print</code>
can take just 60ns without the <code>isatty</code> check.
</p>
<p>
From discussions with Tom Honermann I learned that the "native Unicode API"
wording is only relevant on Windows. This makes sense, because for POSIX
platforms, writing to a terminal is done using the usual stdio functions,
so there's no need to treat a terminal differently to any other file stream.
And substitution of invalid code units with
<span style="font-variant: small-caps">u+fffd</span>
is recommended for Windows because that's what typical modern terminals do on
POSIX platforms, so requiring the implementation to do that on Windows gives
consistent behaviour. But the implementation doesn't need to do anything to
make that happen with a POSIX terminal, it happens anyway.
So the <code>isatty</code> check is unnecessary for POSIX platforms,
and the note mentioning it just causes confusion and has no benefit.
</p>

<p>
Secondly, there initially seems to be a contradiction between the 
"implementations are encouraged to diagnose it" wording and the later
<i>Recommended practice</i>. In fact, there's no contradiction because
the native Unicode API might accept UTF-8 and therefore require no
transcoding, and so the <i>Recommended practice</i> wouldn't apply.
The intention is that diagnosing invalid UTF-8 is still desirable in this case,
but how should it be diagnosed? By writing an error to the terminal alongside
the formatted string?
Or by substituting <span style="font-variant: small-caps">u+fffd</span> maybe?
If the latter is the intention, why is one suggestion in the middle of the
<i>Effects</i>, and one given as <i>Recommended practice</i>?
</p>

<p>
The proposed resolution attempts to clarify that a "native Unicode API"
is only needed if that's how you display Unicode on the terminal.
It also moves the flushing requirement to be adjacent to the other
requirements for systems using a native Unicode API instead of on its own
later in the paragraph.
And the suggestion to diagnose invalid code units is moved into the
<i>Recommended practice</i> and clarified that it's only relevant if
using a native Unicode API. I'm still not entirely happy with encouragement
to diagnose invalid code units without giving any clue as to how that should
be done. What does it mean to diagnose something at runtime? That's novel
for the C++ standard. The way it's currently phrased seems to imply something
other than <span style="font-variant: small-caps">u+fffd</span> substitution
should be done, although that seems the most obvious implementation to me.
</p>


<p><i>[2024-03-12; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll and send to SG16.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>
<li><p>Modify 31.7.6.3.5 <a href="https://wg21.link/ostream.formatted.print">[ostream.formatted.print]</a> as indicated:</p>
<blockquote>
<pre>
void vprint_unicode(ostream&amp; os, string_view fmt, format_args args);
void vprint_nonunicode(ostream&amp; os, string_view fmt, format_args args);
</pre>
<p>-3-
<i>Effects</i>:
Behaves as a formatted output function
(31.7.6.3.1 <a href="https://wg21.link/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>)
of <code>os</code>, except that:
<ol style="list-style-type: none">
<li>(3.1) &ndash;
failure to generate output is reported as specified below, and
</li>
<li>(3.2) &ndash;
any exception thrown by the call to <code>vformat</code> is propagated without
regard to the value of <code>os.exceptions()</code> and without turning on
<code>ios_base::badbit</code> in the error state of <code>os</code>.
</li>
</ol>
</p>
<p>
After constructing a <code>sentry</code> object,
the function initializes an automatic variable via
<pre><code>  string out = vformat(os.getloc(), fmt, args); </code></pre>
If the function is <code>vprint_unicode</code>
and <code>os</code> is a stream that
refers to a terminal capable of displaying Unicode
<ins>via a native Unicode API,</ins>
which is determined in an implementation-defined manner,
<ins>flushes <code>os</code> and then</ins>
writes <code>out</code> to the terminal using the native Unicode API;
if <code>out</code> contains invalid code units, the behavior is undefined
<del>and implementations are encouraged to diagnose it</del>.
<del>
If the native Unicode API is used, the function flushes <code>os</code>
before writing <code>out</code>.
</del>
Otherwise, (if <code>os</code> is not such a stream or the function is
<code>vprint_nonunicode</code>), inserts the character sequence
[<code>out.begin()</code>,<code>out.end()</code>) into <code>os</code>.
If writing to the terminal or inserting into <code>os</code> fails, calls
<code>os.setstate(ios_base::badbit)</code>
(which may throw <code>ios_base::failure</code>).
</p>
<p>-4-
<i>Recommended practice</i>:
For <code>vprint_unicode</code>,
if invoking the native Unicode API requires transcoding, implementations
should substitute invalid code units with
<span style="font-variant: small-caps">u+fffd replacement character</span>
per the Unicode Standard, Chapter 3.9
<span style="font-variant: small-caps">u+fffd</span> Substitution in Conversion.
<ins>
If invoking the native Unicode API  does not require transcoding,
implementations are encouraged to diagnose invalid code units.
</ins>
</p>
</blockquote>
</li>

<li><p>Modify 31.7.10 <a href="https://wg21.link/print.fun">[print.fun]</a> as indicated:</p>

<blockquote>
<pre>
void vprint_unicode(FILE* stream, string_view fmt, format_args args);
</pre>
<p>-6-
<i>Preconditions</i>:
<code>stream</code> is a valid pointer to an output C stream.
</p>
<p>-7-
<i>Effects</i>:
The function initializes an automatic variable via
<pre><code>  string out = vformat(fmt, args); </code></pre>
If <code>stream</code> refers to a terminal capable of displaying Unicode
<ins>via a native Unicode API</ins>,
<ins>flushes <code>stream</code> and then</ins>
writes <code>out</code> to the terminal using the native Unicode API;
if <code>out</code> contains invalid code units, the behavior is undefined
<del>and implementations are encouraged to diagnose it</del>.
Otherwise writes <code>out</code> to <code>stream</code> unchanged.
<del>
If the native Unicode API is used, the function flushes <code>stream</code>
before writing <code>out</code>.
</del>
</p>
<p>
[<i>Note 1</i>:
On <del>POSIX and</del> Windows<del>,</del>
<ins>the native Unicode API is <code>WriteConsoleW</code> and</ins>
<code>stream</code> referring to a terminal means that<del>,
respectively, <code>isatty(fileno(stream))</code> and</del>
<code>GetConsoleMode(_get_osfhandle(_fileno(stream)), ...)</code>
return nonzero.
&mdash; <i>end note</i>]
</p>
<p>
<del>
[<i>Note 2</i>:
On Windows, the native Unicode API is <code>WriteConsoleW</code>.
&mdash; <i>end note</i>]
</del>
</p>
<p>-8-
<i>Throws</i>:  [...]
</p>
<p>-9-
<i>Recommended practice</i>:
If invoking the native Unicode API requires transcoding, implementations
should substitute invalid code units with
<span style="font-variant: small-caps">u+fffd replacement character</span>
per the Unicode Standard, Chapter 3.9
<span style="font-variant: small-caps">u+fffd</span> Substitution in Conversion.
<ins>
If invoking the native Unicode API  does not require transcoding,
implementations are encouraged to diagnose invalid code units.
</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2024-03-12; Jonathan updates wording based on SG16 feedback]</i></p>

<p>
SG16 reviewed the issue and approved the proposed resolution with
the wording about diagnosing invalid code units removed.
</p>
<p>
SG16 favors removing the following text (both occurrences) from the proposed
wording. This is motivated by a lack of understanding regarding what it means
to diagnose such invalid code unit sequences given that the input is likely
provided at run-time.

<blockquote>
If invoking the native Unicode API does not require transcoding, implementations are encouraged to diagnose invalid code units.
</blockquote>
</p>

<p>
Some concern was expressed regarding how the current wording is structured.
At present, the wording leads with a Windows centric perspective;
if the stream refers to a terminal ... use the native Unicode API ...
otherwise write code units to the stream.
It might be an improvement to structure the wording such that use of the native
Unicode API is presented as a fallback for implementations that require its use
when writing directly to the stream is not sufficient to produce desired
results. In other words, the wording should permit direct writing to the stream
even when the stream is directed to a terminal and a native Unicode API is
available when the implementation has reason to believe that doing so will
produce the correct results. For example, Microsoft's HoloLens has a Windows
based operating system, but it only supports use of UTF-8 as the system code
page and therefore would not require the native Unicode API bypass;
implementations for it could avoid the overhead of checking to see if the
stream is directed to a console.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">


<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>
<li><p>Modify 31.7.6.3.5 <a href="https://wg21.link/ostream.formatted.print">[ostream.formatted.print]</a> as indicated:</p>
<blockquote>
<pre>
void vprint_unicode(ostream&amp; os, string_view fmt, format_args args);
void vprint_nonunicode(ostream&amp; os, string_view fmt, format_args args);
</pre>
<p>-3-
<i>Effects</i>:
Behaves as a formatted output function
(31.7.6.3.1 <a href="https://wg21.link/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>)
of <code>os</code>, except that:
<ol style="list-style-type: none">
<li>(3.1) &ndash;
failure to generate output is reported as specified below, and
</li>
<li>(3.2) &ndash;
any exception thrown by the call to <code>vformat</code> is propagated without
regard to the value of <code>os.exceptions()</code> and without turning on
<code>ios_base::badbit</code> in the error state of <code>os</code>.
</li>
</ol>
</p>
<p>
After constructing a <code>sentry</code> object,
the function initializes an automatic variable via
<pre><code>  string out = vformat(os.getloc(), fmt, args); </code></pre>
If the function is <code>vprint_unicode</code>
and <code>os</code> is a stream that
refers to a terminal <ins>that is only</ins> capable of displaying Unicode
<ins>via a native Unicode API,</ins>
which is determined in an implementation-defined manner,
<ins>flushes <code>os</code> and then</ins>
writes <code>out</code> to the terminal using the native Unicode API;
if <code>out</code> contains invalid code units, the behavior is undefined
<del>and implementations are encouraged to diagnose it</del>.
<del>
If the native Unicode API is used, the function flushes <code>os</code>
before writing <code>out</code>.
</del>
Otherwise, (if <code>os</code> is not such a stream or the function is
<code>vprint_nonunicode</code>), inserts the character sequence
[<code>out.begin()</code>,<code>out.end()</code>) into <code>os</code>.
If writing to the terminal or inserting into <code>os</code> fails, calls
<code>os.setstate(ios_base::badbit)</code>
(which may throw <code>ios_base::failure</code>).
</p>
<p>-4-
<i>Recommended practice</i>:
For <code>vprint_unicode</code>,
if invoking the native Unicode API requires transcoding, implementations
should substitute invalid code units with
<span style="font-variant: small-caps">u+fffd replacement character</span>
per the Unicode Standard, Chapter 3.9
<span style="font-variant: small-caps">u+fffd</span> Substitution in Conversion.
</p>
</blockquote>
</li>

<li><p>Modify 31.7.10 <a href="https://wg21.link/print.fun">[print.fun]</a> as indicated:</p>

<blockquote>
<pre>
void vprint_unicode(FILE* stream, string_view fmt, format_args args);
</pre>
<p>-6-
<i>Preconditions</i>:
<code>stream</code> is a valid pointer to an output C stream.
</p>
<p>-7-
<i>Effects</i>:
The function initializes an automatic variable via
<pre><code>  string out = vformat(fmt, args); </code></pre>
If <code>stream</code> refers to a terminal <ins>that is only</ins>
capable of displaying Unicode
<ins>via a native Unicode API</ins>,
<ins>flushes <code>stream</code> and then</ins>
writes <code>out</code> to the terminal using the native Unicode API;
if <code>out</code> contains invalid code units, the behavior is undefined
<del>and implementations are encouraged to diagnose it</del>.
Otherwise writes <code>out</code> to <code>stream</code> unchanged.
<del>
If the native Unicode API is used, the function flushes <code>stream</code>
before writing <code>out</code>.
</del>
</p>
<p>
[<i>Note 1</i>:
On <del>POSIX and</del> Windows<del>,</del>
<ins>the native Unicode API is <code>WriteConsoleW</code> and</ins>
<code>stream</code> referring to a terminal means that<del>,
respectively, <code>isatty(fileno(stream))</code> and</del>
<code>GetConsoleMode(_get_osfhandle(_fileno(stream)), ...)</code>
return nonzero.
&mdash; <i>end note</i>]
</p>
<p>
<del>
[<i>Note 2</i>:
On Windows, the native Unicode API is <code>WriteConsoleW</code>.
&mdash; <i>end note</i>]
</del>
</p>
<p>-8-
<i>Throws</i>:  [...]
</p>
<p>-9-
<i>Recommended practice</i>:
If invoking the native Unicode API requires transcoding, implementations
should substitute invalid code units with
<span style="font-variant: small-caps">u+fffd replacement character</span>
per the Unicode Standard, Chapter 3.9
<span style="font-variant: small-caps">u+fffd</span> Substitution in Conversion.
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2024-03-19; Tokyo: Jonathan updates wording after LWG review]</i></p>

<p>
Split the <em>Effects</em>: into separate bullets for the "native Unicode API"
and "otherwise" cases. Remove the now-redundant "if <code class='backtick'>os</code> is not such a stream"
parenthesis.
</p>

<p><i>[St. Louis 2024-06-24; move to Ready.]</i></p>



<p id="res-4044"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>
<li><p>Modify 31.7.6.3.5 <a href="https://wg21.link/ostream.formatted.print">[ostream.formatted.print]</a> as indicated:</p>
<blockquote>
<pre>
void vprint_unicode(ostream&amp; os, string_view fmt, format_args args);
void vprint_nonunicode(ostream&amp; os, string_view fmt, format_args args);
</pre>
<p>-3-
<i>Effects</i>:
Behaves as a formatted output function
(31.7.6.3.1 <a href="https://wg21.link/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>)
of <code>os</code>, except that:
<ol style="list-style-type: none">
<li>(3.1) &ndash;
failure to generate output is reported as specified below, and
</li>
<li>(3.2) &ndash;
any exception thrown by the call to <code>vformat</code> is propagated without
regard to the value of <code>os.exceptions()</code> and without turning on
<code>ios_base::badbit</code> in the error state of <code>os</code>.
</li>
</ol>
</p>

<p>
<ins>-?-</ins>
After constructing a <code>sentry</code> object,
the function initializes an automatic variable via
<pre><code>  string out = vformat(os.getloc(), fmt, args); </code></pre>
<ol style="list-style-type: none">
<li><ins>(?.1) &ndash; </ins>
If the function is <code>vprint_unicode</code>
and <code>os</code> is a stream that
refers to a terminal <ins>that is only</ins> capable of displaying Unicode
<ins>via a native Unicode API,</ins>
which is determined in an implementation-defined manner,
<ins>flushes <code>os</code> and then</ins>
writes <code>out</code> to the terminal using the native Unicode API;
if <code>out</code> contains invalid code units, the behavior is undefined
<del>and implementations are encouraged to diagnose it.</del>
<del>
If the native Unicode API is used, the function flushes <code>os</code>
before writing <code>out</code></del>.
</li>
<li><ins>(?.2) &ndash; </ins>
Otherwise,
<del>
(if <code>os</code> is not such a stream or the function is
<code>vprint_nonunicode</code>),
</del>
inserts the character sequence
[<code>out.begin()</code>,<code>out.end()</code>) into <code>os</code>.
</li>
</ol>
</p>
<p>
<ins>-?-</ins>
If writing to the terminal or inserting into <code>os</code> fails, calls
<code>os.setstate(ios_base::badbit)</code>
(which may throw <code>ios_base::failure</code>).
</p>
<p>-4-
<i>Recommended practice</i>:
For <code>vprint_unicode</code>,
if invoking the native Unicode API requires transcoding, implementations
should substitute invalid code units with
<span style="font-variant: small-caps">u+fffd replacement character</span>
per the Unicode Standard, Chapter 3.9
<span style="font-variant: small-caps">u+fffd</span> Substitution in Conversion.
</p>
</blockquote>
</li>

<li><p>Modify 31.7.10 <a href="https://wg21.link/print.fun">[print.fun]</a> as indicated:</p>

<blockquote>
<pre>
void vprint_unicode(FILE* stream, string_view fmt, format_args args);
</pre>
<p>-6-
<i>Preconditions</i>:
<code>stream</code> is a valid pointer to an output C stream.
</p>
<p>-7-
<i>Effects</i>:
The function initializes an automatic variable via
<pre><code>  string out = vformat(fmt, args); </code></pre>
<ol style="list-style-type: none">
<li><ins>(7.1) &ndash; </ins>
If <code>stream</code> refers to a terminal <ins>that is only</ins>
capable of displaying Unicode
<ins>via a native Unicode API</ins>,
<ins>flushes <code>stream</code> and then</ins>
writes <code>out</code> to the terminal using the native Unicode API;
if <code>out</code> contains invalid code units, the behavior is undefined
<del>and implementations are encouraged to diagnose it</del>.
</li>
<li><ins>(7.2) &ndash; </ins>
Otherwise writes <code>out</code> to <code>stream</code> unchanged.
</li>
</ol>
</p>
<p>
<del>
If the native Unicode API is used, the function flushes <code>stream</code>
before writing <code>out</code>.
</del>
</p>
<p>
[<i>Note 1</i>:
On <del>POSIX and</del> Windows<del>,</del>
<ins>the native Unicode API is <code>WriteConsoleW</code> and</ins>
<code>stream</code> referring to a terminal means that<del>,
respectively, <code>isatty(fileno(stream))</code> and</del>
<code>GetConsoleMode(_get_osfhandle(_fileno(stream)), ...)</code>
return<ins>s</ins> nonzero.
&mdash; <i>end note</i>]
</p>
<p>
<del>
[<i>Note 2</i>:
On Windows, the native Unicode API is <code>WriteConsoleW</code>.
&mdash; <i>end note</i>]
</del>
</p>
<p>-8-
<i>Throws</i>:  [...]
</p>
<p>-9-
<i>Recommended practice</i>:
If invoking the native Unicode API requires transcoding, implementations
should substitute invalid code units with
<span style="font-variant: small-caps">u+fffd replacement character</span>
per the Unicode Standard, Chapter 3.9
<span style="font-variant: small-caps">u+fffd</span> Substitution in Conversion.
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4064"><a href="#4064">4064</a><sup><a href="https://cplusplus.github.io/LWG/issue4064">(i)</a></sup>. Clarify that <code>std::launder</code> is not needed when using the result of <code>std::memcpy</code></h3>
<p><b>Section:</b> 23.5.3 <a href="https://wg21.link/cstring.syn">[cstring.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Jan Schultke <b>Opened:</b> 2024-04-05 <b>Last modified:</b> 2024-06-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><pre>
int x = 0;
alignas(int) std::byte y[sizeof(int)];
int z = *static_cast&lt;int*&gt;(std::memcpy(y, &amp;x, sizeof(int)));
</pre></blockquote>
<p>
This example should be well-defined, even without the use of <code>std::launder</code>.
<code>std::memcpy</code> implicitly creates an <code>int</code> inside <code>y</code>, and 
<a href="https://www.iso-9899.info/n3047.html#7.26.2.1p3">https://www.iso-9899.info/n3047.html#7.26.2.1p3</a> 
states that
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
The <code>memcpy</code> function returns the value of [the destination operand].
</p>
</blockquote>
<p>
In conjunction with 23.5.3 <a href="https://wg21.link/cstring.syn">[cstring.syn]</a> p3, this presumably means that <code>std::memcpy</code> 
returns a pointer to the (first) implicitly-created object, and no use of <code>std::launder</code> 
is necessary.
<p/>
The wording should be clarified to clearly support this interpretation or reject it.
</p>

<p><i>[2024-06-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>
<li><p>Modify 23.5.3 <a href="https://wg21.link/cstring.syn">[cstring.syn]</a> as indicated:</p>

<blockquote>
<p>
-3- The functions <code>memcpy</code> and <code>memmove</code> are signal-safe (17.13.5 <a href="https://wg21.link/support.signal">[support.signal]</a>). 
Both functions implicitly create objects (6.7.2 <a href="https://wg21.link/intro.object">[intro.object]</a>) in the destination region of 
storage immediately prior to copying the sequence of characters to the destination. <ins>Both functions 
return a pointer to a suitable created object.</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[St. Louis 2024-06-26; CWG suggested improved wording]</i></p>

<p><i>[St. Louis 2024-06-28; LWG: move to Ready]</i></p>




<p id="res-4064"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages — C++">N4981</a>.
</p>

<ol>
<li><p>Modify 23.5.3 <a href="https://wg21.link/cstring.syn">[cstring.syn]</a> as indicated:</p>

<blockquote>
<p>
-3-
The functions <code>memcpy</code> and <code>memmove</code> are signal-safe
(17.13.5 <a href="https://wg21.link/support.signal">[support.signal]</a>).
<del>Both</del> <ins>Each of these</ins> functions implicitly
<del>create</del> <ins>creates</ins> objects (6.7.2 <a href="https://wg21.link/intro.object">[intro.object]</a>)
in the destination region of storage immediately prior to copying
the sequence of characters to the destination.
<ins>Each of these functions returns a pointer to a suitable created object,
if any, otherwise the value of the first parameter.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4112"><a href="#4112">4112</a><sup><a href="https://cplusplus.github.io/LWG/issue4112">(i)</a></sup>. <code><i>has-arrow</i></code> should required <code>operator-&gt;()</code> to be <code>const</code>-qualified</h3>
<p><b>Section:</b> 26.5.2 <a href="https://wg21.link/range.utility.helpers">[range.utility.helpers]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-06-22 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The helper concept <code><i>has-arrow</i></code> in 26.5.2 <a href="https://wg21.link/range.utility.helpers">[range.utility.helpers]</a> does not 
require that <code>I::operator-&gt;()</code> be <code>const</code>-qualified, which is inconsistent with 
the constraints on <code>reverse_iterator</code> and <code>common_iterator</code>'s <code>operator-&gt;()</code> 
as the latter two both require the underlying iterator has <code>const operator-&gt;()</code> member.
<p/>
We should enhance the semantics of <code><i>has-arrow</i></code> so that
<i>implicit expression variations</i> (18.2 <a href="https://wg21.link/concepts.equality">[concepts.equality]</a>)
prohibit silly games.
</p>

<p><i>[St. Louis 2024-06-24; move to Ready]</i></p>




<p id="res-4112"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages — C++">N4981</a>.
</p>

<ol>
<li><p>Modify 26.5.2 <a href="https://wg21.link/range.utility.helpers">[range.utility.helpers]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]

template&lt;class I&gt;
  concept <i>has-arrow</i> =                                       // <i>exposition only</i>
    input_iterator&lt;I&gt; &amp;&amp; (is_pointer_v&lt;I&gt; || requires(<ins>const</ins> I i) { i.operator-&gt;(); });

[&hellip;]
</pre>
</blockquote>

</li>
</ol>





</body>
</html>
