<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<p>Revised 2025-02-07 at 22:40:38 UTC
</p><h2>Tentative Issues</h2>
<hr>
<h3 id="3578"><a href="#3578">3578</a><sup><a href="https://cplusplus.github.io/LWG/issue3578">(i)</a></sup>. Iterator SCARYness in the context of associative container merging</h3>
<p><b>Section:</b> 23.2.7.1 <a href="https://wg21.link/associative.reqmts.general">[associative.reqmts.general]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Joaqu&iacute;n M L&oacute;pez Mu&ntilde;oz <b>Opened:</b> 2021-08-04 <b>Last modified:</b> 2024-12-09</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts.general">active issues</a> in [associative.reqmts.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts.general">issues</a> in [associative.reqmts.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For the expression <code>a.merge(a2)</code>, postconditions say that "iterators referring to the transferred elements 
[&hellip;] now behave as iterators into <code>a</code> [&hellip;]". When <code>a</code> and <code>a2</code> are of different 
types, this seems to imply, under the widest interpretation for "behaving as", that <code>a</code>-iterators and 
<code>a2</code>-iterators are actually of the same type, that is, that associative containers have SCARY iterators,
 which is, to the best of my knowledge, not currently mandated by the standard.
<p/>
There are (at least) three possible resolutions to this ambiguity, ordered by intrusiveness:
</p>
<ul>
<li><p>Indicate that "behaving as" only applies to the case where <code>a</code> and <code>a2</code> are of the same type.</p></li>
<li><p>Clarify what "behaving as" means. A non-SCARY interpretation is that an <code>a2</code>-iterator to a transferred 
element can still be dereferenced, incremented (if not past the last element of <code>a</code>) and decremented (if 
not pointing to the first element of <code>a</code>), while comparison with <code>a</code>-iterators and use in the 
interface of <code>a</code> is not guaranteed.</p></li>
<li><p>Mandate SCARY iterators by, for instance, requiring that associative containers with compatible nodes 
(23.2.5.1 <a href="https://wg21.link/container.node.overview">[container.node.overview]</a>/1) have the same iterator types.</p></li>
</ul>
<p>
Note that this issue does not extend to unordered associative containers, as there (23.2.8.1 <a href="https://wg21.link/unord.req.general">[unord.req.general]</a>) 
iterators to transferred elements are invalidated, which makes the point of SCARYness irrelevant. That said, 
if SCARY iterators are finally required for associative containers, it makes much sense to extend the requirement 
to unordered associative containers as well.
</p>

<p><i>[2021-08-20; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[2024-12-04; Jonathan provides wording]</i></p>

<p>
If we want to require <a href="https://www.stroustrup.com/SCARY.pdf">SCARY</a>
iterators then that should be a proposal that goes through LEWG design review.
I propose an almost minimal change to make the spec consistent without
imposing any new requirements on implementations.
</p>
<p>
The minimal change would be to say that iterators remain valid if <code class='backtick'>a</code> and <code class='backtick'>a2</code>
have the same type, which is the minimum portable guarantee that always holds.
However what matters in practice is whether the iterator types are the same.
That would not be a portable guarantee, because it depends on whether the
implementation uses SCARY iterators for its maps and sets, so users could
write code that works on one implementation and fails to compile when moved
to a different implementation. But that portability trap would be present
even if we only say iterators remain valid when <code class='backtick'>a</code> and <code class='backtick'>a2</code> are the same type.
If the code compiles and works on an implementation with SCARY iterators,
then users will rely on that, even if unintentionally. Leaving that case
unspecified or undefined in the standard doesn't prevent users from relying
on it. It doesn't seem to serve any benefit to pretend it doesn't work when
it actually does on some implementations.
</p>
<p>
N.B. Libstdc++ associative container iterators are SCARY by default,
but non-SCARY when <code class='backtick'>-D_GLIBCXX_DEBUG</code> is used to enable Debug Mode
(see <a href="https://gcc.gnu.org/PR62169">Bug 62169</a>).
I believe libc++ iterators are SCARY even when
<code class='backtick'>-D_LIBCPP_HARDENING_MODE=_LIBCPP_HARDENING_MODE_DEBUG</code> is used,
and MSVC STL iterators are SCARY even when <code class='backtick'>/D_ITERATOR_DEBUG_LEVEL</code> is used.
</p>


<p><i>[2024-12-09; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p id="res-3578"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4993" title=" Working Draft, Programming Languages — C++">N4993</a>.
</p>

<ol>
<li>
<p>
Modify 23.2.7.1 <a href="https://wg21.link/associative.reqmts.general">[associative.reqmts.general]</a> as indicated:
</p>

<blockquote>
<pre><code>a.merge(a2)</code></pre>
<p>-112-
<i>Result</i>: <code class='backtick'>void</code>
</p>
<p>-113-
<i>Preconditions</i>:
<code class='backtick'>a.get_allocator() == a2.get_allocator()</code><ins> is <code class='backtick'>true</code></ins>.
</p>
<p>-114-
<i>Effects</i>:
Attempts to extract each element in <code class='backtick'>a2</code> and insert it into <code class='backtick'>a</code>
using the comparison object of <code class='backtick'>a</code>.
In containers with unique keys,
if there is an element in <code class='backtick'>a</code> with key equivalent to
the key of an element from <code class='backtick'>a2</code>,
then that element is not extracted from <code class='backtick'>a2</code>.
</p>
<p>-115-
<i>Postconditions</i>:
Pointers and references to the transferred elements of <code class='backtick'>a2</code>
refer to those same elements but as members of <code class='backtick'>a</code>.
<ins>If <code class='backtick'>a.begin()</code> and <code class='backtick'>a2.begin()</code> have the same type, iterators</ins>
<del>Iterators</del>
referring to the transferred elements will continue to refer to their elements,
but they now behave as iterators into <code class='backtick'>a</code>, not into <code class='backtick'>a2</code>.
</p>
<p>-116-
<i>Throws</i>:
Nothing unless the comparison objects throws.
</p>
<p>-117-
<i>Complexity</i>:
<i>N</i> log(<code class='backtick'>a.size()</code>+<i>N</i>), where <i>N</i> has the value <code class='backtick'>a2.size()</code>.
</p>

</blockquote>
</li>
</ol>






<hr>
<h3 id="3908"><a href="#3908">3908</a><sup><a href="https://cplusplus.github.io/LWG/issue3908">(i)</a></sup>. <code>enumerate_view::<i>iterator</i></code> constructor is explicit</h3>
<p><b>Section:</b> 25.7.24.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2023-03-23 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.enumerate.iterator">active issues</a> in [range.enumerate.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.enumerate.iterator">issues</a> in [range.enumerate.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>enumerate_view::<i>iterator</i></code> has this constructor:
</p>
<blockquote>
<pre><code>    constexpr explicit
      <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);  <i>// exposition only</i>
</code></pre>
</blockquote>

<p>
In <a href="https://wg21.link/P2164R9" title=" views::enumerate">P2164R9</a> the detailed description of the function showed a
default argument for the second parameter, which would justify it being
explicit. However, that default argument was not present in the class synopsis
and was removed from the detailed description when applying the paper to the
draft.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after four votes in favour during reflector poll.
The constructor is exposition-only, it doesn't make any difference to anything
whether it's explicit or not.
</p>



<p id="res-3908"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>
<ol>
<li>
<p>
Modify the class synopsis in 25.7.24.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a>
as shown:
</p>
<blockquote><pre><code>
    constexpr <del>explicit</del>
      <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);  <i>// exposition only</i>
</code></pre></blockquote>
</li>

<li>
<p>
Modify the detailed description in 25.7.24.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a>
as shown:
</p>
<blockquote>
<pre><code>  constexpr <del>explicit</del> <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);
</code></pre>
<p>-2-
<i>Effects</i>: Initializes <code><i>current_</i></code>
with <code>std::move(current)</code> and <code><i>pos_</i></code> with
<code>pos</code>.
</p>
</blockquote>
</li>

</ol>






<hr>
<h3 id="3909"><a href="#3909">3909</a><sup><a href="https://cplusplus.github.io/LWG/issue3909">(i)</a></sup>. Issues about <code>viewable_range</code></h3>
<p><b>Section:</b> 99 [ranges.refinements], 25.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-27 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After LWG <a href="lwg-defects.html#3724" title="decay-copy should be constrained (Status: C++23)">3724</a><sup><a href="https://cplusplus.github.io/LWG/issue3724" title="Latest snapshot">(i)</a></sup>, <code>views::all</code> is well-constrained for view types,
and the constraints are stronger than <code>viewable_range</code>.
The difference is that given an expression such that <code>decltype</code> gives <code>R</code>,
when <code>decay_t&lt;R&gt;</code> is a view type and the implicit conversion of <code>R</code>
to <code>decay_t&lt;R&gt;</code> is forbidden, <code>views::all</code> rejects the expression,
but <code>viewable_range</code> may accept <code>R</code>.
So I think we should remove the additional constraints on <code>views::all_t</code>.
</p>
<p>
While <code>viewable_range</code> is probably not introducing any additional constraint within the standard library,
I think it is still useful to express the constraints on <code>views::all</code>,
so it should be slightly adjusted to match <code>views::all</code>.
</p>
<p>
Furthermore, <code>viewable_range</code> is currently used in 25.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a>,
but given <a href="https://wg21.link/P2378R3">P2378R3</a> relaxed the requirements for range adaptor closure objects,
I think we should also apply similar relaxation for range adaptor objects.
This should have no impact on standard range adaptor objects.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after three votes in favour during reflector poll.
</p>
<p>
"First change is pointless. Second change is a duplicate of <a href="lwg-active.html#3896" title="The definition of viewable_range is not quite right (Status: New)">3896</a><sup><a href="https://cplusplus.github.io/LWG/issue3896" title="Latest snapshot">(i)</a></sup>.
Range adaptors return a view over their first argument, so they need to
require it's a <code>viewable_range</code>."
</p>



<p id="res-3909"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<ol>
<li>
<p>
Change the definition of <code>views::all_t</code> in 25.2 <a href="https://wg21.link/ranges.syn">[ranges.syn]</a> as indicated:
</p>
<blockquote><pre><code>
   template&lt;<del>viewable_range</del><ins>class</ins> R&gt;
      using all_t = decltype(all(declval&lt;R&gt;()));          // freestanding
</code></pre>
</blockquote>
</li>
<li>
<p>
Change the definition of <code>viewable_range</code> in 25.4.5 <a href="https://wg21.link/range.refinements">[range.refinements]</a> as indicated:
</p>
<blockquote>
<p>-6-
The <code>viewable_range</code> concept specifies the requirements of a <code>range</code> type
that can be converted to a view safely.
</p>
<pre><code>
template&lt;class T&gt;
  concept viewable_range =
    range&lt;T&gt; &amp;&amp;
    ((view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp; <del>constructible_from&lt;remove_cvref_t&lt;T&gt;, T&gt;</del> <ins>convertible_to&lt;T, remove_cvref_t&lt;T&gt;&gt;</ins>) ||
     (!view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp;
      (is_lvalue_reference_v&lt;T&gt; || (movable&lt;remove_reference_t&lt;T&gt;&gt; &amp;&amp; !<i>is-initializer-list</i>&lt;T&gt;))));
</code></pre>
</blockquote>
</li>
<li>
<p>
Change 25.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> as indicated:
</p>
<blockquote>
<p>-6-
A <i>range adaptor object</i> is a customization point object (16.3.3.3.5 <a href="https://wg21.link/customization.point.object">[customization.point.object]</a>)
that accepts a <code><del>viewable_range</del><ins>range</ins></code> as its first argument
and returns a view.
</p>
<p>
[&hellip;]
</p>
<p>-8-
If a range adaptor object <code>adaptor</code> accepts more than one argument,
then let <code>range</code> be an expression such that <code>decltype((range))</code>
models <code><del>viewable_range</del><ins>range</ins></code>,
let <code>args...</code> be arguments such that <code>adaptor(range, args...)</code>
is a well-formed expression as specified in the rest of subclause 25.7 <a href="https://wg21.link/range.adaptors">[range.adaptors]</a>,
and let <code>BoundArgs</code> be a pack that denotes <code>decay_t&lt;decltype((args))&gt;...</code>.
The expression <code>adaptor(args...)</code> produces a range adaptor closure object
<code>f</code> that is a perfect forwarding call wrapper (22.10.4 <a href="https://wg21.link/func.require">[func.require]</a>)
with the following properties: [...]
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3956"><a href="#3956">3956</a><sup><a href="https://cplusplus.github.io/LWG/issue3956">(i)</a></sup>. <code>chrono::parse</code> uses <code>from_stream</code> as a customization point</h3>
<p><b>Section:</b> 30.13 <a href="https://wg21.link/time.parse">[time.parse]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2023-07-15 <b>Last modified:</b> 2024-12-09</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.parse">active issues</a> in [time.parse].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.parse">issues</a> in [time.parse].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.13 <a href="https://wg21.link/time.parse">[time.parse]</a> says: "Each <code>parse</code> overload specified
in this subclause calls <code>from_stream</code> unqualified,
so as to enable argument dependent lookup (6.5.4 <a href="https://wg21.link/basic.lookup.argdep">[basic.lookup.argdep]</a>)."
That name should be added to 16.4.2.2 <a href="https://wg21.link/contents">[contents]</a> along with
<code>swap</code>,
<code>make_error_code</code>, and
<code>make_error_condition</code>.
</p>

<p>
We should decide whether calls to <code>from_stream</code> should use normal
lookup (i.e. unqualified lookup plus ADL) or just ADL, as was done for
<code>make_error_code</code> and <code>make_error_condition</code>
(see LWG <a href="lwg-defects.html#3629" title="make_error_code and make_error_condition are customization points (Status: C++23)">3629</a><sup><a href="https://cplusplus.github.io/LWG/issue3629" title="Latest snapshot">(i)</a></sup>).
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[2024-12-02; Jonathan provides wording]</i></p>

<p>
I suggest that <code class='backtick'>from_stream</code> should only be found via ADL,
not unqualified lookup. This is consistent with what we did for
<code class='backtick'>make_error_code</code> and <code class='backtick'>make_error_condition</code>, and more recently for
<code class='backtick'>submdspan_mapping</code>.  I see no reason to treat <code class='backtick'>from_stream</code> differently.
This implies that implementations might need a poison poll in <code class='backtick'>std::chrono</code>
so that unqualified lookup stops as soon as those are found.
</p>


<p><i>[2024-12-09; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-3956"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4993" title=" Working Draft, Programming Languages — C++">N4993</a>.
</p>

<ol>
<li><p>Modify 16.4.2.2 <a href="https://wg21.link/contents">[contents]</a> as indicated:</p>

<blockquote>
<p>
-3-
Whenever an unqualified name other than
<code class='backtick'>swap</code>, <code class='backtick'>make_error_code</code>, <code class='backtick'>make_error_condition</code>,
<ins><code class='backtick'>from_stream</code>,</ins>
or <code class='backtick'>submdspan_mapping</code>
is used in the specification of a declaration <code class='backtick'>D</code>
in Clause 17 through Clause 33 or Annex D,
its meaning is established as-if by performing unqualified name lookup
(6.5.3 <a href="https://wg21.link/basic.lookup.unqual">[basic.lookup.unqual]</a>)
in the context of <code class='backtick'>D</code>.
</p>
<p>
[<i>Note 1</i>:
Argument-dependent lookup is not performed. &mdash; <i>end note</i>]
</p>
<p>
Similarly, the meaning of a <i>qualified-id</i> is established as-if
by performing qualified name lookup (6.5.5 <a href="https://wg21.link/basic.lookup.qual">[basic.lookup.qual]</a>)
in the context of <code class='backtick'>D</code>.
</p>
<p>
[<i>Example 1</i>:
The reference to <code class='backtick'>is_array_v</code> in the specification of <code class='backtick'>std::to_array</code>
(23.3.3.6 <a href="https://wg21.link/array.creation">[array.creation]</a>) refers to <code class='backtick'>::std::is_array_v</code>.
&mdash; <i>end example</i>]
</p>
<p>
[<i>Note 2</i>: Operators in expressions (12.2.2.3 <a href="https://wg21.link/over.match.oper">[over.match.oper]</a>)
are not so constrained; see 16.4.6.4 <a href="https://wg21.link/global.functions">[global.functions]</a>.
&mdash; <i>end note</i>]
</p>
<p>
The meaning of the unqualified name <code class='backtick'>swap</code> is established
in an overload resolution context for swappable values
(16.4.4.3 <a href="https://wg21.link/swappable.requirements">[swappable.requirements]</a>).
The meanings of the unqualified names
<code class='backtick'>make_error_code</code>, <code class='backtick'>make_error_condition</code>,
<ins><code class='backtick'>from_stream</code>,</ins>
and <code class='backtick'>submdspan_mapping</code>
are established as-if by performing argument-dependent lookup
(6.5.4 <a href="https://wg21.link/basic.lookup.argdep">[basic.lookup.argdep]</a>).
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3958"><a href="#3958">3958</a><sup><a href="https://cplusplus.github.io/LWG/issue3958">(i)</a></sup>. <code>ranges::to</code> should prioritize the "<code>reserve</code>" branch</h3>
<p><b>Section:</b> 25.5.7.2 <a href="https://wg21.link/range.utility.conv.to">[range.utility.conv.to]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-07-17 <b>Last modified:</b> 2024-01-29</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.utility.conv.to">active issues</a> in [range.utility.conv.to].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.utility.conv.to">issues</a> in [range.utility.conv.to].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When the constructed range object has no range version constructor, <code>ranges::to</code> falls into a 
branch designed specifically for C++17-compliant containers, which calls the legacy constructor that 
accepts an iterator pair with <code>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</code>.    
<p/>
However, this kind of initialization may bring some performance issues, because we split the original 
range into pairs of iterators, which may lose information contained in the original range, for example:
</p>
<blockquote><pre>
#include &lt;boost/container/vector.hpp&gt;
#include &lt;sstream&gt;
#include &lt;ranges&gt;

int main() {
  std::istringstream ints("1 2 3 4 5");
  std::ranges::subrange s(std::istream_iterator&lt;int&gt;(ints),
                          std::istream_iterator&lt;int&gt;(),
                          5);
  auto r = std::ranges::to&lt;boost::container::vector&gt;(s); // <span style="color:red;font-weight:bolder">discard size info</span>
}
</pre></blockquote>
<p>
Above, <code>subrange</code> saves the size information of the stream, but <code>ranges::to</code> only extracts 
its iterator pair to create the object, so that the original size information is discarded, resulting in 
unnecessary allocations.
<p/>
I believe we should prefer to use the "<code>reserve</code>" branch here because it is really designed for this situation.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after reflector poll.
"This optimizes exotic cases at the expense of realistic cases."
</p>



<p id="res-3958"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>

<li><p>Modify 25.5.7.2 <a href="https://wg21.link/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
  constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: <code>C</code> is a cv-unqualified class type.
</p>
<p>
-2- <i>Returns</i>: An object of type <code>C</code> constructed from the elements of <code>r</code> in the following manner:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <code>C</code> does not satisfy <code>input_range</code> or <code>convertible_to&lt;range_reference_t&lt;R&gt;, 
range_value_t&lt;C&gt;&gt;</code> is <code>true</code>:</p>
<ol style="list-style-type: none">
<li><p>(2.1.1) &mdash; If <code>constructible_from&lt;C, R, Args...&gt;</code> is <code>true</code>:</p>
<blockquote><code>C(std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</code></blockquote></li>
<li><p>(2.1.2) &mdash; Otherwise, if <code>constructible_from&lt;C, from_range_t, R, Args...&gt;</code> is <code>true</code>:</p>
<blockquote><code>C(from_range, std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</code></blockquote></li>
<li><p><del>(2.1.3) &mdash; Otherwise, if</del></p>
<ol style="list-style-type: none">
<li><p><del>(2.1.3.1) &mdash; <code>common_range&lt;R&gt;</code> is <code>true</code>,</del></p></li>
<li><p><del>(2.1.3.2) &mdash; the <i>qualified-id</i>  
<code>iterator_traits&lt;iterator_t&lt;R&gt;&gt;::iterator_category</code> is valid and denotes a type that models 
<code>derived_from&lt;input_iterator_tag&gt;</code>, and</del></p></li>
<li><p><del>(2.1.3.3) &mdash; <code>constructible_from&lt;C, iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, Args...&gt;</code> 
is <code>true</code>:</del></p>
<blockquote><pre><del>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</del></pre></blockquote></li>
</ol>
</li>
<li><p>(2.1.4) &mdash; Otherwise, if</p>
<ol style="list-style-type: none">
<li><p>(2.1.4.1) &mdash; <code>constructible_from&lt;C, Args...&gt;</code> is <code>true</code>, and</p></li>
<li><p>(2.1.4.2) &mdash; <code><i>container-insertable</i>&lt;C, range_reference_t&lt;R&gt;&gt;</code> is <code>true</code>:</p>
<blockquote><pre>
C c(std::forward&lt;Args&gt;(args)...);
if constexpr (sized_range&lt;R&gt; &amp;&amp; <i>reservable-container</i>&lt;C&gt;)
  c.reserve(static_cast&lt;range_size_t&lt;C&gt;&gt;(ranges::size(r)));
ranges::copy(r, <i>container-inserter</i>&lt;range_reference_t&lt;R&gt;&gt;(c));
</pre></blockquote></li>
</ol>
</li>
<li><p><ins>(?.?.?) &mdash; Otherwise, if</ins></p>
<ol style="list-style-type: none">
<li><p><ins>(?.?.?.?) &mdash; <code>common_range&lt;R&gt;</code> is <code>true</code>,</ins></p></li>
<li><p><ins>(?.?.?.?) &mdash; the <i>qualified-id</i> <code>iterator_traits&lt;iterator_t&lt;R&gt;&gt;::iterator_category</code> 
is valid and denotes a type that models <code>derived_from&lt;input_iterator_tag&gt;</code>, and</ins></p></li>
<li><p><ins>(?.?.?.?) &mdash; <code>constructible_from&lt;C, iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, Args...&gt;</code> 
is <code>true</code>:</ins></p>
<blockquote><pre><ins>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</ins></pre></blockquote></li>
</ol>
</li>
</ol>
</li>
<li><p>(2.2) &mdash; Otherwise, if <code>input_range&lt;range_reference_t&lt;R&gt;&gt;</code> is <code>true</code>:</p>
<blockquote><pre>
to&lt;C&gt;(r | views::transform([](auto&amp;&amp; elem) {
  return to&lt;range_value_t&lt;C&gt;&gt;(std::forward&lt;decltype(elem)&gt;(elem));
}), std::forward&lt;Args&gt;(args)...);
</pre></blockquote></li>
<li><p>(2.3) &mdash; Otherwise, the program is ill-formed.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3980"><a href="#3980">3980</a><sup><a href="https://cplusplus.github.io/LWG/issue3980">(i)</a></sup>. The read exclusive ownership of an atomic read-modify-write operation and whether its read and write are two operations are unclear</h3>
<p><b>Section:</b> 32.5.4 <a href="https://wg21.link/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> jim x <b>Opened:</b> 2023-08-22 <b>Last modified:</b> 2023-11-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Such two questions are sourced from StackOverflow:
</p>
<ol>
<li><p><a href="https://stackoverflow.com/questions/77126045/can-the-read-operations-in-compare-exchange-strong-in-different-two-thread-rea/77126363?noredirect=1#comment135968355_77126363">Can the read operations in <code>compare_exchange_strong</code> in different two thread read the same value?</a></p></li>
<li><p><a href="https://stackoverflow.com/questions/65568185/for-purposes-of-ordering-is-atomic-read-modify-write-one-operation-or-two">For purposes of ordering, is atomic read-modify-write one operation or two?</a></p></li>
</ol>
<p>
Given this example:
</p>
<blockquote>
<pre>
#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;

struct SpinLock{
  std::atomic&lt;bool&gt; atomic_;
  void lock(){
    bool expected = false;
    while (!atomic_.compare_exchange_strong(expected,true,std::memory_order_release,std::memory_order_relaxed)) {
    }
  }
  void unlock(){
    atomic_.store(false, std::memory_order_release);
  }
};

int main(){
  SpinLock spin{false};
  auto t1 = std::thread([&amp;](){
    spin.lock();
    spin.unlock();
  });
  auto t2 = std::thread([&amp;](){
    spin.lock();
    spin.unlock();
  });
  t1.join();
  t2.join();
}
</pre>
</blockquote>
<p>
In the current draft, the relevant phrasing that can interpret that only one read-modify-write operation reads the initial 
value false is 32.5.4 <a href="https://wg21.link/atomics.order">[atomics.order]</a> p10:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
Atomic read-modify-write operations shall always read the last value (in the modification order) written before the write 
associated with the read-modify-write operation.
</p></blockquote>
<p>
However, the wording can have two meanings, each kind of read can result in different explanations for the example
</p>
<ol>
<li><p>The check of the violation is done before the side effect of the RMW is in the modification order, i.e. the rule is 
just checked at the read point.</p></li>
<li><p>The check of the violation is done after the side effect of the RMW is in the modification order, i.e. the rule is 
checked when <code>RMW</code> tries to add the side effect that is based on the read-value to the modification order, and that 
side effect wouldn't be added to the modification order if the rule was violated.</p></li>
</ol>
<p>
With the first interpretation, the two RMW operations can read the same initial value because that value is indeed the last value 
in the modification order before such two RMW operations produce the side effect to the modification order.
<p/>
With the second interpretation, there is only one RMW operation that can read the initial value because the latter one in 
the modification order would violate the rule if it read the initial value.
<p/>
Such two interpretations arise from that the wording doesn't clearly specify when that check is performed.
<p/>
So, my proposed wording is:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
Atomic read-modify-write operations shall always read the value from a side effect <code>X</code>, where <code>X</code> 
immediately precedes the side effect of the read-modify-write operation in the modification order.
</p></blockquote>
<p>
This wording keeps a similar utterance to 6.9.2.2 <a href="https://wg21.link/intro.races">[intro.races]</a>, and it can clearly convey the meaning 
that we say the value read by <code>RWM</code> is associated with the side effect of <code>RMW</code> in the modification order.
<p/>
Relevant discussion can be seen <a href="https://github.com/cplusplus/CWG/issues/423">CWG/issues/423</a> here.
</p>

<p><i>[2023-11-03; Reflector poll]</i></p>

<p>NAD. The first reading isn't plausible. </p>



<p id="res-3980"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages — C++">N4958</a>.
</p>

<ol>

<li><p>Modify 32.5.4 <a href="https://wg21.link/atomics.order">[atomics.order]</a> as indicated:</p>

<blockquote>
<p>
-10- Atomic read-modify-write operations shall always read the <del>last</del> value <ins>from a side effect <i>X</i>, 
where <i>X</i> immediately precedes the side effect of the read-modify-write operation</ins> <del>(</del>in the 
modification order<del>) written before the write associated with the read-modify-write operation</del>.
<p/>
-11- Implementations should make atomic stores visible to atomic loads within a reasonable amount of time.
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3981"><a href="#3981">3981</a><sup><a href="https://cplusplus.github.io/LWG/issue3981">(i)</a></sup>. Range adaptor closure object is underspecified for its return type</h3>
<p><b>Section:</b> 25.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-22 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.adaptor.object">active issues</a> in [range.adaptor.object].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.adaptor.object">issues</a> in [range.adaptor.object].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In order to provide pipe support for user-defined range adaptors, <a href="https://wg21.link/P2387R3" title=" Pipe support for user-defined range adaptors">P2387R3</a> 
removed the specification that the adaptor closure object returns a view, which conforms to the wording of <code>ranges::to</code>.
<p/>
However, the current wording seems to be too low-spec so that the range adaptor closure object can return any type 
or even <code>void</code>. This makes it possible to break the previous specification when returning types that don't make sense, 
<a href="https://godbolt.org/z/Y4nvjY3xj">for example</a>:
</p>
<blockquote>
<pre>
#include &lt;ranges&gt;

struct Closure : std::ranges::range_adaptor_closure&lt;Closure&gt; {
  struct NonCopyable {
    NonCopyable(const NonCopyable&amp;) = delete;
  };

  const NonCopyable&amp; operator()(std::ranges::range auto&amp;&amp;);
};

auto r = std::views::iota(0) | Closure{}; // <span style="color:red;font-weight:bolder">hard error in libstdc++ and MSVC-STL</span>
</pre></blockquote>
<p>
Above, since the return type of the pipeline operator is declared as <code>auto</code>, this causes the deleted 
copy constructor to be invoked in the function body and produces a hard error.
<p/>
The proposed resolution adds a specification for the range adaptor closure object to return a <i>cv</i>-unqualified class type.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD.
"The wording says <code>R | C</code> is equivalent to <code>C(R)</code>,
not <code>auto(C(R))</code>."
</p>



<p id="res-3981"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages — C++">N4958</a>.
</p>

<ol>

<li><p>Modify 25.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> as indicated:</p>

<blockquote>
<p>
-1- A <i>range adaptor closure object</i> is a unary function object that accepts a range argument. For a range adaptor
closure object <code>C</code> and an expression <code>R</code> such that <code>decltype((R))</code> models <code>range</code>, the 
following expressions are equivalent:
</p>
<p>[&hellip;]</p>
<p>
-2- Given an object <code>t</code> of type <code>T</code>, where
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <code>t</code> is a unary function object that accepts a range argument <ins>and returns a 
<i>cv</i>-unqualified class object</ins>,</p></li>
<li><p>[&hellip;]</p></li>
</ol>
<p>
then the implementation ensures that <code>t</code> is a range adaptor closure object.
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3982"><a href="#3982">3982</a><sup><a href="https://cplusplus.github.io/LWG/issue3982">(i)</a></sup>. <code><i>is-derived-from-view-interface</i></code> should require that <code>T</code> is derived from <code>view_interface&lt;T&gt;</code></h3>
<p><b>Section:</b> 25.4.4 <a href="https://wg21.link/range.view">[range.view]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-22 <b>Last modified:</b> 2023-10-30</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.view">issues</a> in [range.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the wording of <code><i>is-derived-from-view-interface</i></code> only detects whether type <code>T</code> is unambiguously 
derived from one base class <code>view_interface&lt;U&gt;</code> where <code>U</code> is not required to be <code>T</code>, which is not 
the intention of CRTP.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>Set status to Tentatively NAD.
The wording correctly handles the case where T derives from <code>Base</code>
which derives from <code>view_interface&lt;Base&gt;</code>.
We don't want it to only be satisfied for direct inheritance from
<code>view_interface&lt;T&gt;</code>, but from any specialization of
<code>view_interface</code>.
Previously the concept only checked for inheritance from <code>view_base</code>
but it was changed when <code>view_interface</code> stopped inheriting from
<code>view_base</code>.
</p>



<p id="res-3982"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages — C++">N4958</a>.
</p>

<ol>

<li><p>Modify 25.4.4 <a href="https://wg21.link/range.view">[range.view]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr bool <i>is-derived-from-view-interface</i> = <i>see below</i>;            // exposition only
template&lt;class T&gt;
  constexpr bool enable_view =
    derived_from&lt;T, view_base&gt; || <i>is-derived-from-view-interface</i>&lt;T&gt;;
</pre>
<blockquote>
<p>
-6- For a type <code>T</code>, <code><i>is-derived-from-view-interface</i>&lt;T&gt;</code>
is <code>true</code> if and only if <code>T</code> has exactly one public base class
<code>view_interface&lt;<ins>T</ins><del>U</del>&gt;</code> <del>for some type <code>U</code></del> and
<code>T</code> has no base classes of type <code>view_interface&lt;<ins>U</ins><del>V</del>&gt;</code> for any
other type <code><ins>U</ins><del>V</del></code>.
<p/>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4003"><a href="#4003">4003</a><sup><a href="https://cplusplus.github.io/LWG/issue4003">(i)</a></sup>. <code>view_interface::back</code> is overconstrained</h3>
<p><b>Section:</b> 25.5.3 <a href="https://wg21.link/view.interface">[view.interface]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-10-28 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#view.interface">issues</a> in [view.interface].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code>view_interface</code> only provides the <code>back</code> member when the derived class satisfies both 
<code>bidirectional_range</code> and <code>common_range</code>, which ensures that <code>ranges::prev</code> can act its sentinel.
<p/>
However, requiring <code>common_range</code> seems to be too strict because when the derived class satisfies both 
<code>random_access_range</code> and <code>sized_range</code>, its end iterator can still be calculated in constant time, 
which is what some range adaptors currently do to greedily become common ranges.
<p/>
I think we should follow similar rules to eliminate this inconsistency (<a href="https://godbolt.org/z/1oEf58Krh">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;

constexpr auto r = std::ranges::subrange(std::views::iota(0), 5);
constexpr auto z = std::views::zip(r);
static_assert(r.back() == 4); // <span style="color:red;font-weight:bolder">ill-formed</span>
static_assert(std::get&lt;0&gt;(z.back()) == 4); // ok
</pre></blockquote>

<p><i>[2023-11-07; Reflector poll]</i></p>

<p>NAD. "During the <code>concat</code> discussion LEWG decided not to
support the corner case of random-access sized but not-common ranges."
"If we did want to address such ranges, would be better to enforce commonness
for random-access sized ranges by having <code>ranges::end</code> return
<code>ranges::begin(r) + ranges::size(r)</code>."
</p>


<p id="res-4003"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages — C++">N4964</a>.
</p>

<ol>

<li><p>Modify 25.5.3 <a href="https://wg21.link/view.interface">[view.interface]</a>, class template <code>view_interface</code> synopsis, as indicated:</p>

<blockquote><pre>
namespace std::ranges {
  template&lt;class D&gt;
    requires is_class_v&lt;D&gt; &amp;&amp; same_as&lt;D, remove_cv_t&lt;D&gt;&gt;
  class view_interface {
    [&hellip;]
  public:
    [&hellip;]
    constexpr decltype(auto) back() requires <ins>(</ins>bidirectional_range&lt;D&gt; &amp;&amp; common_range&lt;D&gt;<ins>) ||</ins>
                                             <ins>(random_access_range&lt;D&gt; &amp;&amp; sized_range&lt;D&gt;)</ins>;
    constexpr decltype(auto) back() const
      requires <ins>(</ins>bidirectional_range&lt;const D&gt; &amp;&amp; common_range&lt;const D&gt;<ins>) ||</ins>
               <ins>(random_access_range&lt;const D&gt; &amp;&amp; sized_range&lt;const D&gt;)</ins>;
    [&hellip;]
  };
}
</pre></blockquote>

</li>

<li><p>Modify 25.5.3.2 <a href="https://wg21.link/view.interface.members">[view.interface.members]</a> as indicated:</p>

<blockquote>
<pre>
constexpr decltype(auto) back() requires <ins>(</ins>bidirectional_range&lt;D&gt; &amp;&amp; common_range&lt;D&gt;<ins>) ||</ins>
                                         <ins>(random_access_range&lt;D&gt; &amp;&amp; sized_range&lt;D&gt;)</ins>;
constexpr decltype(auto) back() const
  requires <ins>(</ins>bidirectional_range&lt;const D&gt; &amp;&amp; common_range&lt;const D&gt;<ins>) ||</ins>
           <ins>(random_access_range&lt;const D&gt; &amp;&amp; sized_range&lt;const D&gt;)</ins>;
</pre>
<blockquote>
<p>
-3- <i>Preconditions</i>: <code>!empty()</code> is <code>true</code>.
<p/>
-4- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
<ins>auto <i>common-arg-end</i> = []&lt;class R&gt;(R&amp; r) {
  if constexpr (common_range&lt;R&gt;) {
    return ranges::end(r);
  } else {
    return ranges::begin(r) + ranges::distance(r);
  }
};</ins>
return *ranges::prev(<ins><i>common-arg-end</i></ins><del>ranges::end</del>(<i>derived</i>()));
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4006"><a href="#4006">4006</a><sup><a href="https://cplusplus.github.io/LWG/issue4006">(i)</a></sup>. <code>chunk_view::<i>outer-iterator</i>::value_type</code> should provide <code>empty</code></h3>
<p><b>Section:</b> 25.7.29.4 <a href="https://wg21.link/range.chunk.outer.value">[range.chunk.outer.value]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-11-05 <b>Last modified:</b> 2024-03-11</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.chunk.outer.value">issues</a> in [range.chunk.outer.value].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>chunk_view::<i>outer-iterator</i>::value_type</code> can determine whether it is empty by simply checking whether the 
<code>chunk_view</code>'s <code><i>remainder_</i></code> is <code>0</code>, which makes it valuable to explicitly provide a 
<code>noexcept empty</code> member.
<p/>
Otherwise, the <code>view_interface::empty</code> is synthesized only through the <code>size</code> member when the original 
sentinel and iterator type model <code>sized_sentinel_for</code>, <a href="https://godbolt.org/z/v3MbzfT9G">which seems overkill</a>:
</p>
<blockquote><pre>
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;ranges&gt;

int main() {
  auto ints = std::istringstream{"1 2 3 4 5 6 7 8 9 10"};
  for (auto chunk : std::views::istream&lt;int&gt;(ints) | std::views::chunk(3)) {
    for (auto elem : chunk) {
      assert(!chunk.empty()); // <span style="color:red;font-weight:bolder">no matching function for call to 'empty()'</span>
      std::cout &lt;&lt; elem &lt;&lt; " ";
    }
    assert(chunk.empty()); // <span style="color:red;font-weight:bolder">ditto</span>
    std::cout &lt;&lt; "\n";
  }
}
</pre></blockquote>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after reflector poll in November 2023.
</p>
<p>
"The example shows you could use it if it existed, but not why that would be useful."
</p>
<p>
"This is a bad idea - the fact that the chunk 'shrinks' as it is iterated over
is an implementation detail and not supposed to be observable."
</p>



<p id="res-4006"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages — C++">N4964</a>.
</p>

<ol>

<li><p>Modify 25.7.29.4 <a href="https://wg21.link/range.chunk.outer.value">[range.chunk.outer.value]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
  namespace std::ranges {
    template&lt;view V&gt;
      requires input_range&lt;V&gt;
    struct chunk_view&lt;V&gt;::<i>outer-iterator</i>::value_type : view_interface&lt;value_type&gt; {
    private:
      chunk_view* <i>parent_</i>;                                        // <i>exposition only</i>

      constexpr explicit value_type(chunk_view&amp; parent);          // <i>exposition only</i>

    public:
      constexpr <i>inner-iterator</i> begin() const noexcept;
      constexpr default_sentinel_t end() const noexcept;

      <ins>constexpr bool empty() const noexcept;</ins>
      constexpr auto size() const
        requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
    };
  }
</pre>
</blockquote>
[&hellip;]
<pre>
constexpr default_sentinel_t end() const noexcept;
</pre>
<blockquote>
<p>
-3- <i>Returns</i>: <code>default_sentinel</code>.
</p>
</blockquote>
<pre>
<ins>constexpr bool empty() const noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Equivalent to: <code>return <i>parent_</i>-&gt;<i>remainder_</i> == 0;</code></ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4095"><a href="#4095">4095</a><sup><a href="https://cplusplus.github.io/LWG/issue4095">(i)</a></sup>. <code>ranges::fold_<i>meow</i></code> should explicitly spell out the return type</h3>
<p><b>Section:</b> 26.4 <a href="https://wg21.link/algorithm.syn">[algorithm.syn]</a>, 26.6.18 <a href="https://wg21.link/alg.fold">[alg.fold]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-05-03 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithm.syn">issues</a> in [algorithm.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unlike other algorithms, the return types of <code>ranges::fold_<i>meow</i></code> are specified in terms of
<code>auto</code> and <code><i>see below</i></code>, and its implementation details depend on the return types of 
other overloads through <code>decltype(fold_<i>meow</i>(...))</code>.
<p/>
This makes determining the return type of a certain overload (such as <code>fold_right_last</code>) 
extremely difficult even for experts, requiring several trips back and forth to different overloads 
to finally understand what the actual return type is. The situation is even worse for newbies because 
such a form of specifying the return type makes it impossible for the IDE to deduce the real return type, 
which is extremely user-unfriendly.
<p/>
I think that explicitly specifying the return type for these overloads not only greatly improves 
readability but also offloads the compiler from deducing the return type, which can definitely be 
considered an improvement.
<p/>
The proposed resolution does not touch the <i>Effects</i> clause and only changes the function signature 
to seek minimal changes.
</p>

<p><i>[2024-06-24; Reflector poll: NAD]</i></p>

<p>Implementations are free to spell this out if desired.</p>



<p id="res-4095"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages — C++">N4981</a>.
</p>

<ol>

<li><p>Modify 26.4 <a href="https://wg21.link/algorithm.syn">[algorithm.syn]</a>, header <code>&lt;algorithm&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
#include &lt;initializer_list&gt;     // <i>see 17.10.2 <a href="https://wg21.link/initializer.list.syn">[initializer.list.syn]</a></i>

namespace std {
  [&hellip;]
  namespace ranges {
    [&hellip;]
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T = iter_value_t&lt;I&gt;,
             <i>indirectly-binary-left-foldable</i>&lt;T, I&gt; F&gt;
      constexpr auto fold_left(I first, S last, T init, F f) <ins>-&gt;
        decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;</ins>;

    template&lt;input_range R, class T = range_value_t&lt;R&gt;,
             <i>indirectly-binary-left-foldable</i>&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
      constexpr auto fold_left(R&amp;&amp; r, T init, F f) <ins>-&gt;
        decay_t&lt;invoke_result_t&lt;F&amp;, T, range_reference_t&lt;R&gt;&gt;&gt;</ins>;

    template&lt;input_iterator I, sentinel_for&lt;I&gt; S,
             <i>indirectly-binary-left-foldable</i>&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
      requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
      constexpr auto fold_left_first(I first, S last, F f) <ins>-&gt;
        optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;&gt;&gt;</ins>;

    template&lt;input_range R, <i>indirectly-binary-left-foldable</i>&lt;range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; F&gt;
      requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
      constexpr auto fold_left_first(R&amp;&amp; r, F f) <ins>-&gt;
        optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;&gt;&gt;</ins>;

    template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S, class T = iter_value_t&lt;I&gt;,
             <i>indirectly-binary-right-foldable</i>&lt;T, I&gt; F&gt;
      constexpr auto fold_right(I first, S last, T init, F f) <ins>-&gt;
        decay_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt;&gt;</ins>;

    template&lt;bidirectional_range R, class T = range_value_t&lt;R&gt;,
             <i>indirectly-binary-right-foldable</i>&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
      constexpr auto fold_right(R&amp;&amp; r, T init, F f) <ins>-&gt;
        decay_t&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;R&gt;, T&gt;&gt;</ins>;

    template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S,
             <i>indirectly-binary-right-foldable</i>&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
      requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
    constexpr auto fold_right_last(I first, S last, F f) <ins>-&gt;
      optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, iter_value_t&lt;I&gt;&gt;&gt;&gt;</ins>;

    template&lt;bidirectional_range R,
             <i>indirectly-binary-right-foldable</i>&lt;range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; F&gt;
      requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
    constexpr auto fold_right_last(R&amp;&amp; r, F f) <ins>-&gt;
      optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;R&gt;, range_value_t&lt;R&gt;&gt;&gt;&gt;</ins>;

    template&lt;class I, class T&gt;
      using fold_left_with_iter_result = in_value_result&lt;I, T&gt;;
    template&lt;class I, class T&gt;
      using fold_left_first_with_iter_result = in_value_result&lt;I, T&gt;;

    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T = iter_value_t&lt;I&gt;,
             <i>indirectly-binary-left-foldable</i>&lt;T, I&gt; F&gt;
      constexpr <del><i>see below</i></del><ins>auto</ins> fold_left_with_iter(I first, S last, T init, F f) <ins>-&gt;
        fold_left_with_iter_result&lt;I, decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt;</ins>;

    template&lt;input_range R, class T = range_value_t&lt;R&gt;,
             <i>indirectly-binary-left-foldable</i>&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
      constexpr <del><i>see below</i></del><ins>auto</ins> fold_left_with_iter(R&amp;&amp; r, T init, F f) <ins>-&gt;
        fold_left_with_iter_result&lt;borrowed_iterator_t&lt;R&gt;,
                                   decay_t&lt;invoke_result_t&lt;F&amp;, T, range_reference_t&lt;R&gt;&gt;&gt;&gt;</ins>;

    template&lt;input_iterator I, sentinel_for&lt;I&gt; S,
             <i>indirectly-binary-left-foldable</i>&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
      requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
      constexpr <del><i>see below</i></del><ins>auto</ins> fold_left_first_with_iter(I first, S last, F f) <ins>-&gt;
        fold_left_first_with_iter_result&lt;
          I, optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;&gt;&gt;&gt;</ins>;

    template&lt;input_range R,
             <i>indirectly-binary-left-foldable</i>&lt;range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; F&gt;
      requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
      constexpr <del><i>see below</i></del><ins>auto</ins> fold_left_first_with_iter(R&amp;&amp; r, F f) <ins>-&gt;
        fold_left_first_with_iter_result&lt;
          borrowed_iterator_t&lt;R&gt;,
          optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;&gt;&gt;&gt;</ins>;
  }
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 26.6.18 <a href="https://wg21.link/alg.fold">[alg.fold]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T = iter_value_t&lt;I&gt;,
         <i>indirectly-binary-left-foldable</i>&lt;T, I&gt; F&gt;
constexpr auto ranges::fold_left(I first, S last, T init, F f) <ins>-&gt;
  decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;</ins>;

template&lt;input_range R, class T = range_value_t&lt;R&gt;,
         <i>indirectly-binary-left-foldable</i>&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
constexpr auto ranges::fold_left(R&amp;&amp; r, T init, F f) <ins>-&gt;
  decay_t&lt;invoke_result_t&lt;F&amp;, T, range_reference_t&lt;R&gt;&gt;&gt;</ins>;
</pre>
<blockquote>
<p>
-1- <i>Returns</i>:
</p>
<blockquote><pre>
ranges::fold_left_with_iter(std::move(first), last, std::move(init), f).value
</pre></blockquote>
</blockquote>
<pre>
template&lt;input_iterator I, sentinel_for&lt;I&gt; S,
         <i>indirectly-binary-left-foldable</i>&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
  requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
  constexpr auto ranges::fold_left_first(I first, S last, F f) <ins>-&gt;
    optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;&gt;&gt;</ins>;

template&lt;input_range R, <i>indirectly-binary-left-foldable</i>&lt;range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; F&gt;
  requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
  constexpr auto ranges::fold_left_first(R&amp;&amp; r, F f) <ins>-&gt;
    optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;&gt;&gt;</ins>;
</pre>
<blockquote>
<p>
-2- <i>Returns</i>:
</p>
<blockquote><pre>
ranges::fold_left_first_with_iter(std::move(first), last, f).value
</pre></blockquote>
</blockquote>
<pre>
template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S, class T = iter_value_t&lt;I&gt;,
         <i>indirectly-binary-right-foldable</i>&lt;T, I&gt; F&gt;
  constexpr auto ranges::fold_right(I first, S last, T init, F f) <ins>-&gt;
    decay_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt;&gt;</ins>;

template&lt;bidirectional_range R, class T = range_value_t&lt;R&gt;,
        <i>indirectly-binary-right-foldable</i>&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
  constexpr auto ranges::fold_right(R&amp;&amp; r, T init, F f) <ins>-&gt;
    decay_t&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;R&gt;, T&gt;&gt;</ins>;  
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
using U = decay_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt;&gt;;
if (first == last)
  return U(std::move(init));
I tail = ranges::next(first, last);
U accum = invoke(f, *--tail, std::move(init));
while (first != tail)
  accum = invoke(f, *--tail, std::move(accum));
return accum;
</pre></blockquote>
</blockquote>
<pre>
template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S,
        <i>indirectly-binary-right-foldable</i>&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
  requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
constexpr auto ranges::fold_right_last(I first, S last, F f) <ins>-&gt;
  optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, iter_value_t&lt;I&gt;&gt;&gt;&gt;</ins>;

template&lt;bidirectional_range R,
         <i>indirectly-binary-right-foldable</i>&lt;range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; F&gt;
 requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
constexpr auto ranges::fold_right_last(R&amp;&amp; r, F f) <ins>-&gt;
  optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;R&gt;, range_value_t&lt;R&gt;&gt;&gt;&gt;</ins>;
</pre>
<blockquote>
<p>
-4- Let <code>U</code> be <code>decltype(ranges::fold_right(first, last, iter_value_t&lt;I&gt;(*first), f))</code>.
<p/>
-5- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (first == last)
  return optional&lt;U&gt;();
I tail = ranges::prev(ranges::next(first, std::move(last)));
return optional&lt;U&gt;(in_place,
  ranges::fold_right(std::move(first), tail, iter_value_t&lt;I&gt;(*tail), std::move(f)));
</pre></blockquote>
</blockquote>
<pre>
template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T = iter_value_t&lt;I&gt;,
         <i>indirectly-binary-left-foldable</i>&lt;T, I&gt; F&gt;
  constexpr <del><i>see below</i></del><ins>auto</ins> ranges::fold_left_with_iter(I first, S last, T init, F f) <ins>-&gt;
    fold_left_with_iter_result&lt;I, decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt;</ins>;

template&lt;input_range R, class T = range_value_t&lt;R&gt;,
         <i>indirectly-binary-left-foldable</i>&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
  constexpr <del><i>see below</i></del><ins>auto</ins> ranges::fold_left_with_iter(R&amp;&amp; r, T init, F f) <ins>-&gt;
    fold_left_with_iter_result&lt;borrowed_iterator_t&lt;R&gt;,
                               decay_t&lt;invoke_result_t&lt;F&amp;, T, range_reference_t&lt;R&gt;&gt;&gt;&gt;</ins>;
</pre>
<blockquote>
<p>
-6- Let <code>U</code> be <code>decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;</code>.
<p/>
-7- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (first == last)
  return {std::move(first), U(std::move(init))};
U accum = invoke(f, std::move(init), *first);
for (++first; first != last; ++first)
  accum = invoke(f, std::move(accum), *first);
return {std::move(first), std::move(accum)};
</pre></blockquote>
<p>
<del>-8- <i>Remarks</i>: The return type is <code>fold_left_with_iter_result&lt;I, U&gt;</code>
for the first overload and <code>fold_left_with_iter_result&lt;borrowed_iterator_t&lt;R&gt;, U&gt;</code> 
for the second overload.</del>
</p>
</blockquote>
<pre>
template&lt;input_iterator I, sentinel_for&lt;I&gt; S,
         <i>indirectly-binary-left-foldable</i>&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
  requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
  constexpr <del><i>see below</i></del><ins>auto</ins> ranges::fold_left_first_with_iter(I first, S last, F f) <ins>-&gt;
    fold_left_first_with_iter_result&lt;
      I, optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;&gt;&gt;&gt;</ins>;

template&lt;input_range R,
         <i>indirectly-binary-left-foldable</i>&lt;range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; F&gt;
  requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
  constexpr <del><i>see below</i></del><ins>auto</ins> ranges::fold_left_first_with_iter(R&amp;&amp; r, F f) <ins>-&gt;
    fold_left_first_with_iter_result&lt;
      borrowed_iterator_t&lt;R&gt;,
      optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;&gt;&gt;&gt;</ins>;
</pre>
<blockquote>
<p>
-9- Let <code>U</code> be
</p>
<blockquote><pre>
decltype(ranges::fold_left(std::move(first), last, iter_value_t&lt;I&gt;(*first), f))
</pre></blockquote>
<p>
-10- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (first == last)
  return {std::move(first), optional&lt;U&gt;()};
optional&lt;U&gt; init(in_place, *first);
for (++first; first != last; ++first)
  *init = invoke(f, std::move(*init), *first);
return {std::move(first), std::move(init)};
</pre></blockquote>
<p>
<del>-11- <i>Remarks</i>: The return type is <code>fold_left_first_with_iter_result&lt;I, optional&lt;U&gt;&gt;</code>
for the first overload and <code>fold_left_first_with_iter_result&lt;borrowed_iterator_t&lt;R&gt;,
  optional&lt;U&gt;&gt;</code> for the second overload.</del>
</p>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3 id="4163"><a href="#4163">4163</a><sup><a href="https://cplusplus.github.io/LWG/issue4163">(i)</a></sup>. Can the overload of <code>std::num_get::do_get</code> for <code>bool</code> call the overload for <code>long</code>?</h3>
<p><b>Section:</b> 28.3.4.3.2.3 <a href="https://wg21.link/facet.num.get.virtuals">[facet.num.get.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-09-29 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.3.4.3.2.3 <a href="https://wg21.link/facet.num.get.virtuals">[facet.num.get.virtuals]</a>/6 currently says:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<i>Effects</i>: If <code>(str.flags()&amp;ios_base::boolalpha) == 0</code> then input proceeds as it would for a 
<code>long</code> except that if a value is being stored into <code>val</code>, [&hellip;]
</p>
</blockquote>
<p>
It is unclear whether an implementation is allowed to call the overload for <code>long</code> in this case. 
Currently, libc++'s version calls that overload, while libstdc++ and MSVC STL's don't 
(<a href="https://godbolt.org/z/83M1hKThv">example</a>).
<p/>
As the divergence implementation strategies is observable, perhaps we should clarify on this.
</p>

<p><i>[2025-02-07; Reflector poll: NAD]</i></p>

<p>
I think this is just a libc++ bug.
The wording says it "proceeds as it would for <code class='backtick'>long</code>", which is not the same as
actually making a virtual call to <code class='backtick'>do_get</code> for <code class='backtick'>long</code>. It can either duplicate
the code from <code class='backtick'>do_get</code> for <code class='backtick'>long</code>, or make a non-virtual (i.e. qualified) call
to <code class='backtick'>num_get::do_get</code>.
</p>



<p id="res-4163"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4172"><a href="#4172">4172</a><sup><a href="https://cplusplus.github.io/LWG/issue4172">(i)</a></sup>. unique_lock self-move-assignment is broken</h3>
<p><b>Section:</b> 32.6.5.4.2 <a href="https://wg21.link/thread.lock.unique.cons">[thread.lock.unique.cons]</a>, 32.6.5.5.2 <a href="https://wg21.link/thread.lock.shared.cons">[thread.lock.shared.cons]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2024-11-13 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.lock.unique.cons">issues</a> in [thread.lock.unique.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The postconditions in 32.6.5.4.2 <a href="https://wg21.link/thread.lock.unique.cons">[thread.lock.unique.cons]</a> paragraph 19:

<blockquote>
<i>Postconditions</i>:
<code class='backtick'>pm == u_p.pm</code> and <code class='backtick'>owns == u_p.owns</code>
(where <code class='backtick'>u_p</code> is the state of <code class='backtick'>u</code> just prior to this construction),
<code class='backtick'>u.pm == 0</code> and <code class='backtick'>u.owns == false</code>.
</blockquote>

contradict themselves if <code class='backtick'>*this</code> and the parameter <code class='backtick'>u</code> refer to the same object.
(Presumably "this construction" means the assignment, and it is copy-pasta from
the move constructor postconditions.) Apparently
<code class='backtick'>unique_lock</code> didn't get the memo that we require well-defined behavior
from self-move-assignment as of LWG <a href="lwg-defects.html#2839" title="Self-move-assignment of library types, again (Status: C++23)">2839</a><sup><a href="https://cplusplus.github.io/LWG/issue2839" title="Latest snapshot">(i)</a></sup>.
</p>
<p>
Also, the move assignment operator doesn't specify what it returns.
</p>

<p><i>[2024-11-18; Casey expands the PR to cover <code class='backtick'>shared_lock</code>]</i></p>

<p>
<code class='backtick'>shared_lock</code> has the same problems, and can be fixed in the same way.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>
<p>
"Should use parentheses not braces for the initializations."
Jonathan volunteers to do that editorially after this gets approved.
</p>



<p id="res-4172"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4993" title=" Working Draft, Programming Languages — C++">N4993</a>.
</p>

<blockquote class="note">
Drafting Note: I've chosen to use the move-into-temporary-and-swap idiom here
to keep things short and sweet.
Since move construction, swap, and destruction are all <code class='backtick'>noexcept</code>,
I've promoted move assignment from "<i>Throws</i>: Nothing" to <code class='backtick'>noexcept</code> as well.
This is consistent with eliminating the implicit narrow contract condition
that <code class='backtick'>*this</code> and <code class='backtick'>u</code> refer to distinct objects.
</blockquote>

<ol>
<li>
<p>
In the class synopsis in 32.6.5.4.1 <a href="https://wg21.link/thread.lock.unique.general">[thread.lock.unique.general]</a>,
annotate the move assignment operator as <code class='backtick'>noexcept</code>:
</p>

<blockquote><pre><code>
  namespace std {
    template&lt;class Mutex&gt;
    class unique_lock {
      [...]
      unique_lock&amp; operator=(unique_lock&amp;&amp; u) <ins>noexcept</ins>;
      [...]
    };
  }
</code></pre></blockquote>
</li>

<li>
<p>
Modify 32.6.5.4.2 <a href="https://wg21.link/thread.lock.unique.cons">[thread.lock.unique.cons]</a> as follows:
</p>

<blockquote>
<pre><code>
unique_lock&amp; operator=(unique_lock&amp;&amp; u) <ins>noexcept</ins>;
</code></pre>
<p>
-18- <i>Effects</i>:
<del>If <code class='backtick'>owns</code> calls <code class='backtick'>pm-&gt;unlock()</code>.</del>
<ins>Equivalent to: <code class='backtick'>unique_lock{std::move(u)}.swap(*this)</code>.</ins>
</p>
<p>
<ins>-?- <i>Returns</i>: <code class='backtick'>*this</code>.</ins>
</p>
<p>
<del>-19- <i>Postconditions</i>:
<code class='backtick'>pm == u_p.pm</code> and <code class='backtick'>owns == u_p.owns</code>
(where <code class='backtick'>u_p</code> is the state of <code class='backtick'>u</code> just prior to this construction),
<code class='backtick'>u.pm == 0</code> and <code class='backtick'>u.owns == false</code>.
</del>
</p>
<p>
<del>-20- [<i>Note 1</i>:
With a recursive mutex it is possible for both <code class='backtick'>*this</code> and u to own
the same mutex before the assignment.
In this case, *this will own the mutex after the assignment and u will not.
&mdash; <i>end note</i>]</del>
</p>
<p>
<del>-21- Throws: Nothing.</del>
</p>
</blockquote>
</li>

<li>
<p>
Modify 32.6.5.5.2 <a href="https://wg21.link/thread.lock.shared.cons">[thread.lock.shared.cons]</a> as follows:
</p>

<blockquote>
<pre><code>
shared_lock&amp; operator=(shared_lock&amp;&amp; sl) noexcept;
</code></pre>
<p>
-17- <i>Effects</i>:
<del>If <code class='backtick'>owns</code> calls <code class='backtick'>pm-&gt;unlock_shared()</code>.</del>
<ins>Equivalent to: <code class='backtick'>shared_lock{std::move(sl)}.swap(*this)</code>.</ins>
</p>
<p>
<ins>-?- <i>Returns</i>: <code class='backtick'>*this</code>.</ins>
</p>
<p>
<del>-18- <i>Postconditions</i>:
<code class='backtick'>pm == sl_p.pm</code> and <code class='backtick'>owns == sl_p.owns</code>
(where <code class='backtick'>sl_p</code> is the state of <code class='backtick'>sl</code> just prior to this assignment),
<code class='backtick'>sl.pm == nullptr</code> and <code class='backtick'>sl.owns == false</code>.
</del>
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4175"><a href="#4175">4175</a><sup><a href="https://cplusplus.github.io/LWG/issue4175">(i)</a></sup>. <code class='backtick'>get_env()</code> specified in terms of <code class='backtick'>as_const()</code> but this doesn't work with rvalue senders</h3>
<p><b>Section:</b> 33.5.2 <a href="https://wg21.link/exec.get.allocator">[exec.get.allocator]</a>, 33.5.3 <a href="https://wg21.link/exec.get.stop.token">[exec.get.stop.token]</a>, 33.5.4 <a href="https://wg21.link/exec.get.env">[exec.get.env]</a>, 33.5.5 <a href="https://wg21.link/exec.get.domain">[exec.get.domain]</a>, 33.5.6 <a href="https://wg21.link/exec.get.scheduler">[exec.get.scheduler]</a>, 33.5.7 <a href="https://wg21.link/exec.get.delegation.scheduler">[exec.get.delegation.scheduler]</a>, 33.5.8 <a href="https://wg21.link/exec.get.fwd.progress">[exec.get.fwd.progress]</a>, 33.5.9 <a href="https://wg21.link/exec.get.compl.sched">[exec.get.compl.sched]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2024-11-10 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current specification of <code class='backtick'>std::execution::get_env()</code> defines <code class='backtick'>get_env(o)</code> as <code class='backtick'>as_const(o).get_env()</code>. 
However, the <code class='backtick'>as_const()</code> function has a deleted rvalue-taking overload, meaning that you cannot pass temporaries to it.  
<p/>
This means that several uses of <code class='backtick'>get_env()</code> which pass expressions which are either potentially rvalues 
(e.g. in definition of <code class='backtick'>connect(sndr, rcvr)</code> it uses the expression <code class='backtick'>get_env(rcvr)</code>, but <code class='backtick'>rcvr</code> could be, 
and usually is, a prvalue) or always rvalues (e.g. <code class='backtick'>scheduler</code> concept has the expression 
<code>get_env(schedule(std::forward&lt;Sch&gt;(sch)))</code>).  
<p/>
The intent here was that <code class='backtick'>get_env()</code> is a function that takes as an argument a <code>const T&amp;</code> and thus 
allows prvalues to bind to it. We basically just want to require that <code class='backtick'>get_env()</code> finds a const-qualified 
member-function. The use of <code class='backtick'>as_const()</code> does not seem to mirror the semantics of a function with a 
<code>const T&amp;</code> parameter, so I suggest we change it to something else that expresses the intent.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>
<p>
This could use the "reified object" idea from 25.3 <a href="https://wg21.link/range.access">[range.access]</a>.
</p>



<p id="res-4175"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4993" title=" Working Draft, Programming Languages — C++">N4993</a>.
</p>

<ol>
<li><p>Add to the end of 33.1 <a href="https://wg21.link/exec.general">[exec.general]</a> as indicated:</p>

<blockquote>
<p>
<ins>-?- For a subexpression <code class='backtick'>expr</code>, let <code><i>AS-CONST</i>(expr)</code> be expression-equivalent to</ins> 
</p>
<blockquote><pre>
<ins>[](const auto&amp; x) noexcept -&gt; const auto&amp; { return x; }(expr)</ins>
</pre></blockquote>
</blockquote>

</li>

<li><p>Modify 33.5.2 <a href="https://wg21.link/exec.get.allocator">[exec.get.allocator]</a> as indicated:</p>

<blockquote>
<p>
-1- <code class='backtick'>get_allocator</code> asks a queryable object for its associated allocator.
<p/>
-2- The name <code class='backtick'>get_allocator</code> denotes a query object. For a subexpression <code class='backtick'>env</code>, <code class='backtick'>get_allocator(env)</code> is
expression-equivalent to <code><i>MANDATE-NOTHROW</i>(<del>as_const</del><ins><i>AS-CONST</i></ins>(env).query(get_allocator))</code>.
</p>
</blockquote>

</li>

<li><p>Modify 33.5.3 <a href="https://wg21.link/exec.get.stop.token">[exec.get.stop.token]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code class='backtick'>get_stop_token</code> denotes a query object. For a subexpression <code class='backtick'>env</code>, <code class='backtick'>get_stop_token(env)</code> is
expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <code><i>MANDATE-NOTHROW</i>(<del>as_const</del><ins><i>AS-CONST</i></ins>(env).query(get_stop_token))</code> 
if that expression is well-formed.</p></li>
</ol>
</blockquote>

</li>

<li><p>Modify 33.5.4 <a href="https://wg21.link/exec.get.env">[exec.get.env]</a> as indicated:</p>

<blockquote>
<p>
-1- <code class='backtick'>execution::get_env</code> is a customization point object. For a subexpression <code class='backtick'>o</code>, <code class='backtick'>execution::get_env(o)</code> is
expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; <code><i>MANDATE-NOTHROW</i>(<del>as_const</del><ins><i>AS-CONST</i></ins>(o).get_env())</code> 
if that expression is well-formed.</p></li>
</ol>
</blockquote>

</li>

<li><p>Modify 33.5.5 <a href="https://wg21.link/exec.get.domain">[exec.get.domain]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code class='backtick'>get_domain</code> denotes a query object. For a subexpression <code class='backtick'>env</code>, <code class='backtick'>get_domain(env)</code> is expression-equivalent
to <code><i>MANDATE-NOTHROW</i>(<del>as_const</del><ins><i>AS-CONST</i></ins>(env).query(get_domain))</code>.
</p>

</blockquote>

</li>

<li><p>Modify 33.5.6 <a href="https://wg21.link/exec.get.scheduler">[exec.get.scheduler]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code class='backtick'>get_scheduler</code> denotes a query object. For a subexpression <code class='backtick'>env</code>, <code class='backtick'>get_scheduler(env)</code> is
expression-equivalent to <code><i>MANDATE-NOTHROW</i>(<del>as_const</del><ins><i>AS-CONST</i></ins>(env).query(get_scheduler))</code>.
</p>
</blockquote>

</li>

<li><p>Modify 33.5.7 <a href="https://wg21.link/exec.get.delegation.scheduler">[exec.get.delegation.scheduler]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code class='backtick'>get_delegation_scheduler</code> denotes a query object. For a subexpression <code class='backtick'>env</code>, 
<code class='backtick'>get_delegation_scheduler(env)</code> is expression-equivalent to 
<code><i>MANDATE-NOTHROW</i>(<del>as_const</del><ins><i>AS-CONST</i></ins>(env).query(get_delegation_scheduler))</code>.
</p>
</blockquote>

</li>

<li><p>Modify 33.5.8 <a href="https://wg21.link/exec.get.fwd.progress">[exec.get.fwd.progress]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code class='backtick'>get_forward_progress_guarantee</code> denotes a query object. For a subexpression <code class='backtick'>sch</code>, let 
<code class='backtick'>Sch</code> be <code class='backtick'>decltype((sch))</code>. If <code class='backtick'>Sch</code> does not satisfy <code class='backtick'>scheduler</code>, <code class='backtick'>get_forward_progress_guarantee</code> is ill-formed.
Otherwise, <code class='backtick'>get_forward_progress_guarantee(sch)</code> is expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <code><i>MANDATE-NOTHROW</i>(<del>as_const</del><ins><i>AS-CONST</i></ins>(sch).query(get_forward_progress_guarantee))</code> 
if that expression is well-formed.</p></li>
</ol>
</blockquote>

</li>

<li><p>Modify 33.5.9 <a href="https://wg21.link/exec.get.compl.sched">[exec.get.compl.sched]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code class='backtick'>get_completion_scheduler</code> denotes a query object template. For a subexpression <code class='backtick'>q</code>, the expression
<code>get_completion_scheduler&lt;<i>completion-tag</i>&gt;(q)</code> is ill-formed if <code><i>completion-tag</i></code> 
is not one of <code class='backtick'>set_value_t</code>, <code class='backtick'>set_error_t</code>, or <code class='backtick'>set_stopped_t</code>. Otherwise, 
<code>get_completion_scheduler&lt;<i>completion-tag</i>&gt;(q)</code> is expression-equivalent to
</p>
<blockquote><pre>
<i>MANDATE-NOTHROW</i>(<del>as_const</del><ins><i>AS-CONST</i></ins>(q).query(get_completion_scheduler&lt;<i>completion-tag</i>&gt;))
</pre></blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4179"><a href="#4179">4179</a><sup><a href="https://cplusplus.github.io/LWG/issue4179">(i)</a></sup>. Wrong range in [alg.search]</h3>
<p><b>Section:</b> 26.6.15 <a href="https://wg21.link/alg.search">[alg.search]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Oscar Slotosch <b>Opened:</b> 2024-12-05 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.search">issues</a> in [alg.search].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Originally reported as editorial request <a href="https://github.com/cplusplus/draft/issues/7474">#7474</a>:
<p/>
During the qualification of the C++ STL Validas has pointed me to the following issue:
<p/>
The specification of 26.6.15 <a href="https://wg21.link/alg.search">[alg.search]</a> has a wrong range. Currently the range is 
"<code>[first1, last1 - (last2 - first2))</code>" (exclusive) but should be 
"<code>[first1, last1 - (last2 - first2)]</code>" (inclusive). So please correct the closing ")" to "]". 
Otherwise the last occurrence will not be found. We observed the issue in C++14 and C++17 
and cppreference.com.
<p/>
The implementations do the right thing and work correctly and find even the last occurrence.
<p/>
For example in the list <code class='backtick'>{1, 2, 3, 4, 5}</code> the pattern <code class='backtick'>{4, 5}</code> should be found (obviously).
In the case the last element is not included it will not be found.
<p/>
<a href="https://godbolt.org/z/daMa5nTY9">Demonstration on godbolt</a> shows that the implementation 
is working and finds the pattern.
</p>

<p><i>[2024-12-07; Daniel comments and provides wording]</i></p>

<p>
The mentioned wording issue is present in all previous standard versions, including the 
<a href="https://sgistl.github.io/search.html">SGI STL</a>. It needs to be fixed in all search 
variants specified in 26.6.15 <a href="https://wg21.link/alg.search">[alg.search]</a> (except for the form using a <code class='backtick'>Searcher</code>).
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after ten votes in favour during reflector poll.
</p>



<p id="res-4179"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4993" title=" Working Draft, Programming Languages — C++">N4993</a>.
</p>

<ol>
<li><p>Modify 26.6.15 <a href="https://wg21.link/alg.search">[alg.search]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class ForwardIterator1, class ForwardIterator2&gt;
  constexpr ForwardIterator1
    search(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2);
[&hellip;]
template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate&gt;
ForwardIterator1
  search(ExecutionPolicy&amp;&amp; exec,
         ForwardIterator1 first1, ForwardIterator1 last1,
         ForwardIterator2 first2, ForwardIterator2 last2,
         BinaryPredicate pred);
</pre>
<blockquote>
<p>
-1- <i>Returns</i>: The first iterator <code class='backtick'>i</code> in the range <code>[first1, last1 - (last2 - first2)<ins>]</ins><del>)</del></code> 
such that for every nonnegative integer <code class='backtick'>n</code> less than <code class='backtick'>last2 - first2</code> the following 
corresponding conditions hold: <code class='backtick'>*(i + n) == *(first2 + n), pred(*(i + n)</code>, <code class='backtick'>*(first2 + n)) != false</code>. 
Returns <code class='backtick'>first1</code> if <code class='backtick'>[first2, last2)</code> is empty, otherwise returns <code class='backtick'>last1</code> if no such iterator is found.
<p/>
-2- [&hellip;]
</p>
</blockquote>
<pre>
template&lt;forward_iterator I1, sentinel_for&lt;I1&gt; S1, forward_iterator I2,
         sentinel_for&lt;I2&gt; S2, class Pred = ranges::equal_to,
         class Proj1 = identity, class Proj2 = identity&gt;
  requires indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
  constexpr subrange&lt;I1&gt;
    ranges::search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                   Proj1 proj1 = {}, Proj2 proj2 = {});
template&lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to,
         class Proj1 = identity, class Proj2 = identity&gt;
  requires indirectly_comparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
  constexpr borrowed_subrange_t&lt;R1&gt;
    ranges::search(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
                   Proj1 proj1 = {}, Proj2 proj2 = {});
</pre>
<blockquote>
<p>
-3- <i>Returns</i>:
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; <code class='backtick'>{i, i + (last2 - first2)}</code>, where <code class='backtick'>i</code> is the first iterator in the range 
<code>[first1, last1 - (last2 - first2)<ins>]</ins><del>)</del></code> such that for every non-negative integer <code class='backtick'>n</code> 
less than <code class='backtick'>last2 - first2</code> the condition</p>
<blockquote><pre>
bool(invoke(pred, invoke(proj1, *(i + n)), invoke(proj2, *(first2 + n))))
</pre></blockquote>
<p>is <code class='backtick'>true</code>.</p>
</li>
<li><p>(3.2) &mdash; Returns <code class='backtick'>{last1, last1}</code> if no such iterator exists.</p></li>
</ol>
<p>
-4- [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class ForwardIterator, class Size, class T = iterator_traits&lt;ForwardIterator&gt;::value_type&gt;
  constexpr ForwardIterator
    search_n(ForwardIterator first, ForwardIterator last,
             Size count, const T&amp; value);
[&hellip;]
template&lt;class ExecutionPolicy, class ForwardIterator, class Size,
         class T = iterator_traits&lt;ForwardIterator&gt;::value_type,
         class BinaryPredicate&gt;
  ForwardIterator
    search_n(ExecutionPolicy&amp;&amp; exec,
             ForwardIterator first, ForwardIterator last,
             Size count, const T&amp; value,
             BinaryPredicate pred);
</pre>
<blockquote>
<p>
-5- [&hellip;]
<p/>
-6- [&hellip;]
<p/>
-7- <i>Returns</i>: The first iterator <code class='backtick'>i</code> in the range <code>[first, last-count<ins>]</ins><del>)</del></code> 
such that for every non-negative integer <code class='backtick'>n</code> less than <code class='backtick'>count</code> the condition <code><i>E</i></code> is <code class='backtick'>true</code>. 
Returns <code class='backtick'>last</code> if no such iterator is found.
<p/>
-8- [&hellip;]
</p>
</blockquote>
<pre>
template&lt;forward_iterator I, sentinel_for&lt;I&gt; S,
         class Pred = ranges::equal_to, class Proj = identity,
         class T = projected_value_t&lt;I, Proj&gt;&gt;
  requires indirectly_comparable&lt;I, const T*, Pred, Proj&gt;
  constexpr subrange&lt;I&gt;
    ranges::search_n(I first, S last, iter_difference_t&lt;I&gt; count,
                     const T&amp; value, Pred pred = {}, Proj proj = {});
template&lt;forward_range R, class Pred = ranges::equal_to,
         class Proj = identity, class T = projected_value_t&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;
  requires indirectly_comparable&lt;iterator_t&lt;R&gt;, const T*, Pred, Proj&gt;
  constexpr borrowed_subrange_t&lt;R&gt;
    ranges::search_n(R&amp;&amp; r, range_difference_t&lt;R&gt; count,
                     const T&amp; value, Pred pred = {}, Proj proj = {});
</pre>
<blockquote>
<p>
-9- <i>Returns</i>: <code class='backtick'>{i, i + count}</code> where <code class='backtick'>i</code> is the first iterator in the range 
<code>[first, last - count<ins>]</ins><del>)</del></code> such that for every non-negative integer 
<code class='backtick'>n</code> less than <code class='backtick'>count</code>, the following condition holds: <code class='backtick'>invoke(pred, invoke(proj, *(i + n)), value)</code>. 
Returns <code class='backtick'>{last, last}</code> if no such iterator is found.
<p/>
-10- [&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4184"><a href="#4184">4184</a><sup><a href="https://cplusplus.github.io/LWG/issue4184">(i)</a></sup>. Domain of <code>ranges::c<i>meow</i></code> doesn't match <code>ranges::<i>meow</i></code></h3>
<p><b>Section:</b> 25.3 <a href="https://wg21.link/range.access">[range.access]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-12-17 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>ranges::begin/rbegin/data</code> can be used on non-ranges as long as the object has a
<code class='backtick'>begin/rbegin/data</code> member, this is also true for their const versions before C++23.
<p/>
However, in C++23 the const version always applied <code><i>possibly-const-range</i></code> to the object,
which no longer worked for non-ranges due to this function requiring <code class='backtick'>input_range</code>, 
which seems to be a breaking change (<a href="https://godbolt.org/z/KKe4nG9W8">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;

struct NotRange {
        int* begin();
  const int* begin() const;
        int* rbegin();
  const int* rbegin() const;
        int* data();
  const int* data() const;
};

int main() {
  NotRange r;

  (void) std::ranges::begin(r);
  (void) std::ranges::rbegin(r);
  (void) std::ranges::data(r);

  // <span  style="color:#C80000;font-weight:bold">The following works in C++20, fails in C++23</span>
  (void) std::ranges::cbegin(r);
  (void) std::ranges::crbegin(r);
  (void) std::ranges::cdata(r);
}
</pre></blockquote>

<p><i>[2025-02-07; Reflector poll: NAD]</i></p>

<p>
"We don't need to support <code class='backtick'>ranges::cbegin</code> on non-ranges."
</p>
<p>
"Seems to be very similar to LWG <a href="lwg-closed.html#3913" title="ranges::const_iterator_t&lt;range R&gt; fails to accept arrays of unknown bound (Status: NAD)">3913</a><sup><a href="https://cplusplus.github.io/LWG/issue3913" title="Latest snapshot">(i)</a></sup> which LWG closed as NAD."
</p>



<p id="res-4184"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4186"><a href="#4186">4186</a><sup><a href="https://cplusplus.github.io/LWG/issue4186">(i)</a></sup>. <code class='backtick'>regex_traits::transform_primary</code> mistakenly detects <code class='backtick'>typeid</code> of a function</h3>
<p><b>Section:</b> 28.6.6 <a href="https://wg21.link/re.traits">[re.traits]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-12-18 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.traits">active issues</a> in [re.traits].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.traits">issues</a> in [re.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.6.6 <a href="https://wg21.link/re.traits">[re.traits]</a>/7 currently says <code>typeid(use_facet&lt;collate&lt;charT&gt;&gt;) == 
typeid(collate_byname&lt;charT&gt;)</code>, which is always <code class='backtick'>false</code> because 
<code>use_facet&lt;collate&lt;charT&gt;&gt;</code> is a function template specialization while 
<code>collate_byname&lt;charT&gt;</code> is a class template specialization. This looks like 
misuse, and has been present in TR1 (<a href="https://wg21.link/N1836" title=" Draft Technical Report on C++ Library Extensions">N1836</a>).
<p/>
Presumably the intended operand is <code>use_facet&lt;collate&lt;charT&gt;&gt;(getloc())</code>.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-4186"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001">N5001</a>.
</p>

<ol>
<li><p>Modify 28.6.6 <a href="https://wg21.link/re.traits">[re.traits]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class ForwardIterator&gt;
  string_type transform_primary(ForwardIterator first, ForwardIterator last) const;
</pre>
<blockquote>
<p>
-7- <i>Effects</i>: If
</p>
<blockquote><pre>
typeid(use_facet&lt;collate&lt;charT&gt;&gt;<ins>(getloc())</ins>) == typeid(collate_byname&lt;charT&gt;)
</pre></blockquote>
<p>
and the form of the sort key returned by <code>collate_byname&lt;charT&gt;::transform(first, last)</code> 
is known and can be converted into a primary sort key then returns that key, otherwise returns an empty
string.
</p>
</blockquote>
</blockquote>


</li>

</ol>





<hr>
<h3 id="4189"><a href="#4189">4189</a><sup><a href="https://cplusplus.github.io/LWG/issue4189">(i)</a></sup>. <code class='backtick'>cache_latest_view</code> should be freestanding</h3>
<p><b>Section:</b> 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a>, 25.2 <a href="https://wg21.link/ranges.syn">[ranges.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-12-23 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#version.syn">active issues</a> in [version.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#version.syn">issues</a> in [version.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>cache_latest_view</code> can be freestanding, but this never comes up in the discussion, which seems to be an oversight.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5001">N5001</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a> as indicated:</p>

<blockquote><pre>
#define __cpp_lib_ranges_cache_latest 202411L // <ins><i>freestanding</i>,</ins> <i>also in</i> &lt;ranges&gt;
</pre></blockquote>

</li>

<li><p>Modify 25.2 <a href="https://wg21.link/ranges.syn">[ranges.syn]</a> as indicated:</p>

<blockquote><pre>
#include &lt;compare&gt;              // <i>see 17.11.1 <a href="https://wg21.link/compare.syn">[compare.syn]</a></i>
#include &lt;initializer_list&gt;     // <i>see 17.10.2 <a href="https://wg21.link/initializer.list.syn">[initializer.list.syn]</a></i>
#include &lt;iterator&gt;             // <i>see 24.2 <a href="https://wg21.link/iterator.synopsis">[iterator.synopsis]</a></i>

namespace std::ranges {
  [&hellip;]
  // <i>25.7.34 <a href="https://wg21.link/range.cache.latest">[range.cache.latest]</a>, cache latest view</i>
  template&lt;input_range V&gt;
    requires view&lt;V&gt;
  class cache_latest_view;                                                                <ins>// <i>freestanding</i></ins>
  
  namespace views { inline constexpr <i>unspecified</i> cache_latest = <i>unspecified</i>; }            <ins>// <i>freestanding</i></ins>
  [&hellip;]
}
</pre></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2025-01-04; Tim Song suggests alternative wording]</i></p>

<p>
While we are here, we can use the new convention from <a href="https://wg21.link/P2407" title=" Freestanding Library: Partial Classes">P2407</a> to dramatically simplify 
<code>&lt;ranges&gt;</code>. Most future additions to this header should have no problem being freestanding, 
so that is the right default.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after nine votes in favour during reflector poll.
</p>



<p id="res-4189"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001">N5001</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a> as indicated:</p>

<blockquote><pre>
#define __cpp_lib_ranges_cache_latest 202411L // <ins><i>freestanding</i>,</ins> <i>also in</i> &lt;ranges&gt;
</pre></blockquote>

</li>

<li><p>Delete all "// <i>freestanding</i>" comments in 25.2 <a href="https://wg21.link/ranges.syn">[ranges.syn]</a>, header <code>&lt;ranges&gt;</code> 
synopsis, and then modify as indicated:</p>

<blockquote><pre>
<ins>// <i>mostly freestanding</i></ins>
#include &lt;compare&gt;              // <i>see 17.11.1 <a href="https://wg21.link/compare.syn">[compare.syn]</a></i>
#include &lt;initializer_list&gt;     // <i>see 17.10.2 <a href="https://wg21.link/initializer.list.syn">[initializer.list.syn]</a></i>
#include &lt;iterator&gt;             // <i>see 24.2 <a href="https://wg21.link/iterator.synopsis">[iterator.synopsis]</a></i>

[&hellip;]
namespace std::ranges {
  // <i>25.5.6 <a href="https://wg21.link/range.elementsof">[range.elementsof]</a>, class template elements_of</i>
  template&lt;range R, class Allocator = allocator&lt;byte&gt;&gt;
    struct elements_of;  <ins>// <i>hosted</i></ins>
  [&hellip;]

  // <i>25.6.6 <a href="https://wg21.link/range.istream">[range.istream]</a>, istream view</i>
  template&lt;movable Val, class CharT, class Traits = char_traits&lt;CharT&gt;&gt;
    requires <i>see below</i>
  class basic_istream_view;  <ins>// <i>hosted</i></ins>
  template&lt;class Val&gt;
    using istream_view = basic_istream_view&lt;Val, char&gt;;   <ins>// <i>hosted</i></ins>
  template&lt;class Val&gt;
    using wistream_view = basic_istream_view&lt;Val, wchar_t&gt;;   <ins>// <i>hosted</i></ins>

  namespace views {
    template&lt;class T&gt; constexpr <i>unspecified</i> istream = <i>unspecified</i>; <ins>// <i>hosted</i></ins>
  }
  [&hellip;]
}
[&hellip;]
</pre></blockquote>
</li>
</ol>






<hr>
<h3 id="4191"><a href="#4191">4191</a><sup><a href="https://cplusplus.github.io/LWG/issue4191">(i)</a></sup>. P1467 changed the return type of <code>pow(complex&lt;float&gt;, int)</code></h3>
<p><b>Section:</b> 29.4.10 <a href="https://wg21.link/cmplx.over">[cmplx.over]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2025-01-10 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#cmplx.over">active issues</a> in [cmplx.over].</p>
<p><b>View all other</b> <a href="lwg-index.html#cmplx.over">issues</a> in [cmplx.over].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Before C++20, 29.4.10 <a href="https://wg21.link/cmplx.over">[cmplx.over]</a> says that this produces a <code>complex&lt;double&gt;</code>. 
This was confirmed by LWG <a href="lwg-defects.html#844" title="complex pow return type is ambiguous (Status: CD1)">844</a><sup><a href="https://cplusplus.github.io/LWG/issue844" title="Latest snapshot">(i)</a></sup> and consistent with C99.
<p/>
<a href="https://wg21.link/P1467" title=" Extended floating-point types and standard names">P1467</a> changed the return type to <code>complex&lt;common_type_t&lt;float, int&gt;&gt;</code>, 
which is <code>complex&lt;float&gt;</code>. This is a breaking change that does not appear to have been 
intentional.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p id="res-4191"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001">N5001</a>.
</p>

<ol>

<li><p>Modify 29.4.10 <a href="https://wg21.link/cmplx.over">[cmplx.over]</a> as indicated:</p>

<blockquote><p>
-3- Function template <code class='backtick'>pow</code> has additional constexpr overloads sufficient to ensure, for a call with one argument of
type <code>complex&lt;T1&gt;</code> and the other argument of type <code class='backtick'>T2</code> or <code>complex&lt;T2&gt;</code>, both arguments 
are effectively cast to <code>complex&lt;common_type_t&lt;T1, <ins>T3</ins><del>T2</del>&gt;&gt;</code><ins>, where 
<code class='backtick'>T3</code> is <code class='backtick'>double</code> if <code class='backtick'>T2</code> is an integer type and <code class='backtick'>T2</code> otherwise</ins>. If <code>common_type_t&lt;T1, <ins>T3</ins><del>T2</del>&gt;</code> 
is not well-formed, then the program is ill-formed.
</p></blockquote>
</li>
</ol>






<hr>
<h3 id="4194"><a href="#4194">4194</a><sup><a href="https://cplusplus.github.io/LWG/issue4194">(i)</a></sup>. <code>atomic&lt;void*&gt;</code> should use generic class template</h3>
<p><b>Section:</b> 32.5.8.5 <a href="https://wg21.link/atomics.types.pointer">[atomics.types.pointer]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Gonzalo Brito <b>Opened:</b> 2025-01-16 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.pointer">active issues</a> in [atomics.types.pointer].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.pointer">issues</a> in [atomics.types.pointer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
32.5.8.5 <a href="https://wg21.link/atomics.types.pointer">[atomics.types.pointer]</a> p1 states (emphasis mine):
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
There is a partial specialization of the <code class='backtick'>atomic</code> class template for <b>pointers</b>.
</p>
</blockquote>
<p>
which requires <code>atomic&lt;void*&gt;</code> to use the <code class='backtick'>atomic</code> class template for pointers.
However, the <code class='backtick'>fetch_add</code>/<code class='backtick'>_sub</code> member functions add a <code class='backtick'>difference_type</code> to a <code class='backtick'>T*</code> 
which requires a pointer-to-object type (these member functions are <code class='backtick'>constexpr</code>, 
so trying to support this seems unimplementable).
<p/>
For <code class='backtick'>atomic_ref</code>, the 32.5.7.5 <a href="https://wg21.link/atomics.ref.pointer">[atomics.ref.pointer]</a> p1 states (emphasis mine):
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
There are specializations of the <code class='backtick'>atomic_ref</code>`  class template for all <b>pointer-to-object types</b>.
</p>
</blockquote>
<p>
which avoids this issue and applying the same form to 32.5.8.5 <a href="https://wg21.link/atomics.types.pointer">[atomics.types.pointer]</a> would make 
<code>atomic&lt;void*&gt;</code> and <code>atomic_ref&lt;void*&gt;</code> consistent.
<p/>
Technically this would be a breaking change, but all C++ standard library implementations surveyed are broken, 
and the proposed fix would make them compliant: see libstdc++, libc++ and MSVC STL errors 
<a href="https://godbolt.org/z/dso3P6fKf">here</a>. These standard libraries require a 
pointer-to-object type, <code>atomic&lt;void*&gt;</code> uses the general template. Therefore, no user 
code seems to be impacted.
</p>

<p><i>[2025-02-07; Reflector poll: NAD]</i></p>

<p>
The <code class='backtick'>fetch_OP</code> members have "<i>Mandates</i>: <code class='backtick'>T</code> is a complete object type."
and a note explaining that this means arithmetic on <code class='backtick'>void*</code> is ill-formed.
So implementations are expected to use the partial specialization for <code class='backtick'>void*</code>
but to reject attempts at arithmetic. They all do this correctly today.
</p>


<p id="res-4194"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001">N5001</a>.
</p>

<ol>

<li><p>Modify 32.5.8.5 <a href="https://wg21.link/atomics.types.pointer">[atomics.types.pointer]</a> as indicated:</p>

<blockquote><p>
-1- There is a partial specialization of the <code class='backtick'>atomic</code> class template for 
<del>pointers</del><ins>pointer-to-object types</ins>. Specializations of this partial
specialization are standard-layout structs. They each have a trivial destructor.
</p></blockquote>
</li>

</ol>





<hr>
<h3 id="4196"><a href="#4196">4196</a><sup><a href="https://cplusplus.github.io/LWG/issue4196">(i)</a></sup>. Complexity of <code class='backtick'>inplace_merge()</code> is incorrect</h3>
<p><b>Section:</b> 26.8.6 <a href="https://wg21.link/alg.merge">[alg.merge]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Stephen Howe <b>Opened:</b> 2025-01-22 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.merge">active issues</a> in [alg.merge].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.merge">issues</a> in [alg.merge].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For <a href="https://wg21.link/N5001">N5001</a>, section 26.8.6 <a href="https://wg21.link/alg.merge">[alg.merge]</a> p5, it says for <code class='backtick'>merge()</code> <i>Complexity</i> (emphasis mine):
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
For the overloads with no <code class='backtick'>ExecutionPolicy</code>, <b>at most</b> <code><i>N</i> - 1</code> comparisons and applications of each
projection
</p>
</blockquote>
<p>
For <a href="https://wg21.link/N5001">N5001</a>, section 26.8.6 <a href="https://wg21.link/alg.merge">[alg.merge]</a> p11, it says from <code class='backtick'>inplace_merge()</code> <i>Complexity</i> (emphasis mine):
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<i>Complexity</i>: Let <code><i>N</i> = last - first</code>:
</p>
<ol style="list-style-type: none">
<li><p>(11.1) &mdash; For the overloads with no <code class='backtick'>ExecutionPolicy</code>, and if enough additional memory is available, <b>exactly</b>
<code><i>N</i> - 1</code> comparisons.</p></li>
<li><p>(11.2) &mdash; Otherwise, <code>&#x1d4aa;(<i>N</i> log <i>N</i>)</code> comparisons.</p></li>
</ol>
</blockquote>
<p>
This wording should be (emphasis mine)
</p>
<blockquote>
<p>
<i>Complexity</i>: Let <code><i>N</i> = last - first</code>:
</p>
<ol style="list-style-type: none">
<li><p>(11.1) &mdash; For the overloads with no <code class='backtick'>ExecutionPolicy</code>, and if enough additional memory is available, <b>at most</b>
<code><i>N</i> - 1</code> comparisons.</p></li>
<li><p>(11.2) &mdash; Otherwise, <code>&#x1d4aa;(<i>N</i> log <i>N</i>)</code> comparisons.</p></li>
</ol>
</blockquote>
<p>
Consider the 2 sequences in a <code class='backtick'>std::vector</code> of <code class='backtick'>int</code>s and assume that <code class='backtick'>inplace_merge</code> has enough memory:
</p>
<blockquote><pre>
{ 1 }, { 2, 3, 4, 5, 6, 7 )
</pre></blockquote>
<p>
<code><i>N</i></code> is <code class='backtick'>7</code>, 7 elements. So <code><i>N</i> - 1</code> is <code class='backtick'>6</code>
<p/>
If you <code class='backtick'>inplace_merge()</code> the two sequences, the <code class='backtick'>1</code> is compared with <code class='backtick'>2</code> and <code class='backtick'>1</code> is output. But now the 1st 
sequence is over, so the 2nd sequence is copied. Only 1 comparison is done, not 6.
</p>

<p><i>[2025-01-25; Daniel comments]</i></p>

<p>
The <a href="https://sgistl.github.io/inplace_merge.html">SGI STL archive</a> correctly says "at most" as well.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
There were nine votes for P0 (Tentatively Ready), but also several for
NAD Editorial, because 16.3.2.4 <a href="https://wg21.link/structure.specifications">[structure.specifications]</a>/7 explicitly
says that all complexity requirements are upper bounds and it's conforming to
do less work. The consensus was that this is still a clarifying improvement.
</p>



<p id="res-4196"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001">N5001</a>.
</p>

<ol>

<li><p>Modify 26.8.6 <a href="https://wg21.link/alg.merge">[alg.merge]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class BidirectionalIterator&gt;
  constexpr void inplace_merge(BidirectionalIterator first,
                               BidirectionalIterator middle,
                               BidirectionalIterator last);
template&lt;class ExecutionPolicy, class BidirectionalIterator&gt;
  void inplace_merge(ExecutionPolicy&amp;&amp; exec,
                     BidirectionalIterator first,
                     BidirectionalIterator middle,
                     BidirectionalIterator last);
template&lt;class BidirectionalIterator, class Compare&gt;
  constexpr void inplace_merge(BidirectionalIterator first,
                               BidirectionalIterator middle,
                               BidirectionalIterator last, Compare comp);
template&lt;class ExecutionPolicy, class BidirectionalIterator, class Compare&gt;
  void inplace_merge(ExecutionPolicy&amp;&amp; exec,
                     BidirectionalIterator first,
                     BidirectionalIterator middle,
                     BidirectionalIterator last, Compare comp);
template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S, class Comp = ranges::less,
         class Proj = identity&gt;
  requires sortable&lt;I, Comp, Proj&gt;
  constexpr I ranges::inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {});
</pre>
<blockquote>
<p>
-7- [&hellip;]
<p/>
-8- <i>Preconditions</i>: [&hellip;]
<p/>
-9- <i>Effects</i>: Merges two sorted consecutive ranges <code class='backtick'>[first, middle)</code> and <code class='backtick'>[middle, last)</code>, 
putting the result of the merge into the range <code class='backtick'>[first, last)</code>. The resulting range is sorted 
with respect to <code class='backtick'>comp</code> and <code class='backtick'>proj</code>.
<p/>
-10- <i>Returns</i>: <code class='backtick'>last</code> for the overload in namespace <code class='backtick'>ranges</code>.
<p/>
-11- <i>Complexity</i>: Let <code><i>N</i> = last - first</code>:
</p>
<ol style="list-style-type: none">
<li><p>(11.1) &mdash; For the overloads with no <code class='backtick'>ExecutionPolicy</code>, and if enough additional memory is available, 
<del>exactly</del><ins>at most</ins> <code><i>N</i> - 1</code> comparisons.</p></li>
<li><p>(11.2) &mdash; Otherwise, <code>&#x1d4aa;(<i>N</i> log <i>N</i>)</code> comparisons.</p></li>
</ol>
<p>
In either case, twice as many projections as comparisons.
</p>
</blockquote>
</blockquote>
</li>
</ol>





</body>
</html>
