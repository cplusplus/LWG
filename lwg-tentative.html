<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<p><p>Revised 2023-06-03 at 13:26:31 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="2457" href="#2457">2457</a><sup><a href="https://cplusplus.github.io/LWG/issue2457">(i)</a></sup>. <tt>std::begin()</tt> and <tt>std::end()</tt> do not support multi-dimensional arrays correctly</h3>
<p><b>Section:</b> 25.7 <a href="https://wg21.link/iterator.range">[iterator.range]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Janez &#x17d;emva <b>Opened:</b> 2014-11-16 <b>Last modified:</b> 2023-04-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.range">active issues</a> in [iterator.range].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in [iterator.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following code:
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;

int main() 
{
  int a[2][3][4] = { { { 1,  2,  3,  4}, { 5,  6,  7,  8}, { 9, 10, 11, 12} },
                     { {13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24} } };
  int b[2][3][4];

  assert(std::distance(std::begin(a), std::end(a)) == 2 * 3 * 4);
  std::copy(std::begin(a), std::end(a), std::begin(b));
  std::copy(std::begin(b), std::end(b), std::ostream_iterator&lt;int&gt;(std::cout, ","));
}
</pre></blockquote>
<p>
does not compile. 
<p/>
A possible way to remedy this would be to add the following overloads of
<tt>begin</tt>, <tt>end</tt>, <tt>rbegin</tt>, and <tt>rend</tt> to 25.7 <a href="https://wg21.link/iterator.range">[iterator.range]</a>, 
relying on recursive evaluation:
</p>
<blockquote><pre>
namespace std {

  template &lt;typename T, size_t M, size_t N&gt;
  constexpr remove_all_extents_t&lt;T&gt;*
  begin(T (&amp;array)[M][N])
  {
    return begin(*array);
  }
  
  template &lt;typename T, size_t M, size_t N&gt;
  constexpr remove_all_extents_t&lt;T&gt;*
  end(T (&amp;array)[M][N])
  {
    return end(array[M - 1]);
  }

  template &lt;typename T, size_t M, size_t N&gt;
  reverse_iterator&lt;remove_all_extents_t&lt;T&gt;*&gt;
  rbegin(T (&amp;array)[M][N])
  {
    return decltype(rbegin(array))(end(array[M - 1]));
  }
  
  template &lt;typename T, size_t M, size_t N&gt;
  reverse_iterator&lt;remove_all_extents_t&lt;T&gt;*&gt;
  rend(T (&amp;array)[M][N])
  {
    return decltype(rend(array))(begin(*array));
  }

}
</pre></blockquote>

<p><i>[2023-04-06; LWG reflector poll in November 2021]</i></p>

<p>
Changed to Tentatively NAD after 12 votes in favour.
Use <code>views::join</code> or <code>mdspan</code> instead.
</p>



<p id="res-2457"><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2994" href="#2994">2994</a><sup><a href="https://cplusplus.github.io/LWG/issue2994">(i)</a></sup>. Needless UB for <tt>basic_string</tt> and <tt>basic_string_view</tt></h3>
<p><b>Section:</b> 23.2 <a href="https://wg21.link/char.traits">[char.traits]</a>, 23.4.3.2 <a href="https://wg21.link/string.require">[string.require]</a>, 23.3.3 <a href="https://wg21.link/string.view.template">[string.view.template]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Gennaro Prota <b>Opened:</b> 2017-07-03 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#char.traits">issues</a> in [char.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>basic_string</tt> and <tt>basic_string_view</tt> involve undefined behavior in a few cases where it's 
simple for the implementation to add a <tt>static_assert</tt> and make the program ill-formed.
<p/>
With regards to basic_string, 23.2 <a href="https://wg21.link/char.traits">[char.traits]</a>/3 states:
</p>
<blockquote><p>
<tt>Traits::char_type</tt> shall be the same as <tt>CharT</tt>.
</p></blockquote>
<p>
Here, the implementation can add a <tt>static_assert</tt> using the <tt>is_same</tt>
type trait. Similar issues exist in 23.4.3.2 <a href="https://wg21.link/string.require">[string.require]</a> and, for
<tt>basic_string_view</tt>, in 23.3.3 <a href="https://wg21.link/string.view.template">[string.view.template]</a>/1. 
</p>

<p><i>[2017-07 Toronto Tuesday PM issue prioritization]</i></p>

<p>Priority 3; need to check general container requirements</p>

<p>Partially by the adoption of <a href="https://wg21.link/P1148">P1148</a> in San Diego.</p>
<p>Tim opines: "the remainder deals with allocator value type mismatch, which I think is NAD."</p>
<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/n4659">N4659</a>.
</p>

<ol>
<li><p>Edit 23.2 <a href="https://wg21.link/char.traits">[char.traits]</a> as indicated:</p>

<blockquote>
<p>
-3- To specialize those templates to generate a string or iostream class to handle a particular character container
type <tt>CharT</tt>, that and its related character traits class <tt>Traits</tt> are passed as a pair of parameters to 
the string or iostream template as parameters <tt>charT</tt> and <tt>traits</tt>. <ins>If</ins> <tt>Traits::char_type</tt> 
<del>shall be the same</del> <ins>is not the same type</ins> as <tt>CharT</tt><ins>, the program is ill-formed</ins>.
</p>
</blockquote>
</li>

<li><p>Edit 23.4.3.2 <a href="https://wg21.link/string.require">[string.require]</a> as indicated:</p>

<blockquote>
<p>
-3- In every specialization <tt>basic_string&lt;charT, traits, Allocator&gt;</tt>, <ins>if</ins> <del>the type</del> 
<tt>allocator_traits&lt;Allocator&gt;::value_type</tt> <del>shall name the same type</del> <ins>is not the 
same type</ins> as <tt>charT</tt><ins>, the program is ill-formed</ins>. 
Every object of type <tt>basic_string&lt;charT, traits, Allocator&gt;</tt> shall use an object of type 
<tt>Allocator</tt> to allocate and free storage for the contained <tt>charT</tt> objects as needed. The 
<tt>Allocator</tt> object used shall be obtained as described in 24.2.2.1 <a href="https://wg21.link/container.requirements.general">[container.requirements.general]</a>. 
In every specialization <tt>basic_string&lt;charT, traits, Allocator&gt;</tt>, the type <tt>traits</tt> 
shall satisfy the character traits requirements (23.2 <a href="https://wg21.link/char.traits">[char.traits]</a>)<ins>. If</ins><del>, and the type</del> 
<tt>traits::char_type</tt> <del>shall name the same type</del> <ins>is not the same type</ins> as <tt>charT</tt><ins>, 
the program is ill-formed</ins>.
</p>
</blockquote>
</li>

<li><p>Edit 23.3.3 <a href="https://wg21.link/string.view.template">[string.view.template]</a> as indicated:</p>

<blockquote>
<p>
-1- In every specialization <tt>basic_string_view&lt;charT, traits&gt;</tt>, the type <tt>traits</tt> shall satisfy the character
traits requirements (23.2 <a href="https://wg21.link/char.traits">[char.traits]</a>)<ins>. If</ins><del>, and the type</del> <tt>traits::char_type</tt> <del>shall 
name the same type</del> <ins>is not the same type</ins> as <tt>charT</tt><ins>, the program is ill-formed</ins>.
</p>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2023-05-15; Jonathan Wakely provides improved wording]</i></p>

<p>
As noted above, most of this issue was resolved by <a href="https://wg21.link/P1148R0">P1148R0</a>.
The remainder is the change to make it ill-formed if the allocator has the wrong
<code>value_type</code>, but since <a href="https://wg21.link/P1463R1">P1463R1</a> that is already part of
the Allocator-aware container requirements, which apply to <code>basic_string</code>.
</p>


<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>
<p>
There was a request to editorially move the added text in <i>Note 1</i> into
<i>Note 2</i> after this is approved.
</p>



<p id="res-2994"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950">N4950</a>.
</p>

<ol>
<li><p>Edit 23.4.3.2 <a href="https://wg21.link/string.require">[string.require]</a> as indicated:</p>

<blockquote>
<p>
-3- <del>In every specialization <tt>basic_string&lt;charT, traits, Allocator&gt;</tt>, the type
<tt>allocator_traits&lt;Allocator&gt;::value_type</tt> shall name the same type as <tt>charT</tt>.</del>
Every object of type <tt>basic_string&lt;charT, traits, Allocator&gt;</tt> shall use an object of type
<tt>Allocator</tt> to allocate and free storage for the contained <tt>charT</tt> objects as needed. The
In every specialization <tt>basic_string&lt;charT, traits, Allocator&gt;</tt>, the type <tt>traits</tt>
shall satisfy the character traits requirements (23.2 <a href="https://wg21.link/char.traits">[char.traits]</a>).
</p>
<p>
[<i>Note 1</i>:
Every specialization <code>basic_string&lt;charT, traits, Allocator&gt;</code>
is an allocator-aware container, but does not use the allocator’s
<code>construct</code> and <code>destroy</code> member functions
(24.2.2.1 <a href="https://wg21.link/container.requirements.general">[container.requirements.general]</a>).
<ins>
The program is ill-formed if <code>Allocator::value_type</code>
is not the same type as <code>charT</code>.
</ins>
&mdash; <i>end note</i>]
</p>
<p>
[<i>Note 2</i>:
The program is ill-formed if <code>traits::char_type</code>
is not the same type as <code>charT</code>.
&mdash; <i>end note</i>]
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3635" href="#3635">3635</a><sup><a href="https://cplusplus.github.io/LWG/issue3635">(i)</a></sup>. Add <tt>__cpp_lib_deduction_guides</tt> to feature test macros</h3>
<p><b>Section:</b> 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Konstantin Varlamov <b>Opened:</b> 2021-11-09 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#version.syn">active issues</a> in [version.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#version.syn">issues</a> in [version.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P0433R2">P0433R2</a>, the proposal for adding deduction guides to the standard library, contained a 
recommendation to use <tt>__cpp_lib_deduction_guides</tt> as a feature test macro. However, it appears that this feature test macro has been accidentally omitted from the Standard when the paper was applied and probably needs to be added back.
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4901">N4901</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_coroutine          201902L  <i>// also in &lt;coroutine&gt;</i>
<ins>#define __cpp_lib_deduction_guides   201703L
  <i>// also in &lt;deque&gt;, &lt;forward_list&gt;, &lt;list&gt;, &lt;map&gt;, &lt;queue&gt;, &lt;set&gt;, &lt;stack&gt;,
  // &lt;unordered_map&gt;, &lt;unordered_set&gt;, &lt;vector&gt;</i></ins>
#define __cpp_lib_destroying_delete  201806L  <i>// also in &lt;new&gt;</i>
[&hellip;]
</pre>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2021-11-16; Konstantin Varlamov comments and improves wording]</i></p>

<p>
One potential topic of discussion is whether the new feature test macro needs to be defined in every library 
header that contains an explicit deduction guide. While this would be consistent with the current approach, 
no other macro is associated with such a large set of headers (20 headers in total, whereas the current 
record-holder is <tt>__cpp_lib_nonmember_container_access</tt> with 12 headers). For this reason, it should 
be considered whether perhaps the new macro should only be defined in <tt>&lt;version&gt;</tt> (which would, 
however, make it an outlier). The proposed wording currently contains an exhaustive list (note that the 
deduction guides for <tt>&lt;mutex&gt;</tt> were removed by LWG <a href="lwg-defects.html#2981">2981</a>).
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Several votes for NAD as it's too late to be useful, and code which needs
to be portable to pre-CTAD compilers can just not use CTAD.
</p>

<p><i>[2023-04-21; Reflector poll for 'Tentatively NAD']</i></p>

<p><i>[
"We keep changing the deduction guides, and different libraries might be
conformant in some headers and not others. The status cannot be represented
by a single number."
]</i></p>




<p id="res-3635"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901">N4901</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_coroutine          201902L  <i>// also in &lt;coroutine&gt;</i>
<ins>#define __cpp_lib_deduction_guides   201703L
  <i>// also in &lt;array&gt;, &lt;deque&gt;, &lt;forward_list&gt;, &lt;functional&gt;, &lt;list&gt;, &lt;map&gt;,
  // &lt;memory&gt;, &lt;optional&gt;, &lt;queue&gt;, &lt;regex&gt;, &lt;scoped_allocator&gt;, &lt;set&gt;, &lt;stack&gt;,
  // &lt;string&gt;, &lt;tuple&gt;, &lt;unordered_map&gt;, &lt;unordered_set&gt;, &lt;utility&gt;, &lt;valarray&gt;,
  // &lt;vector&gt;</i></ins>
#define __cpp_lib_destroying_delete  201806L  <i>// also in &lt;new&gt;</i>
[&hellip;]
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="3714" href="#3714">3714</a><sup><a href="https://cplusplus.github.io/LWG/issue3714">(i)</a></sup>. Non-single-argument constructors for range adaptors should not be <tt>explicit</tt></h3>
<p><b>Section:</b> 26.7.25.2 <a href="https://wg21.link/range.zip.transform.view">[range.zip.transform.view]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-06-10 <b>Last modified:</b> 2023-01-24</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
All C++20 range adaptors' non-single-argument constructors are not declared as <tt>explicit</tt>, which makes 
the following initialization well-formed:
</p>
<blockquote><pre>
std::vector v{42};
std::ranges::take_view r1 = {v, 1};
std::ranges::filter_view r2 = {v, [](int) { return true; }};
</pre></blockquote>
<p>
However, the non-single-argument constructors of C++23 range adaptors, except for <tt>join_with_view</tt>, 
are all <tt>explicit</tt>, which makes us no longer able to
</p>
<blockquote><pre>
std::ranges::chunk_view r1 = {v, 1}; // <span style="color:red;font-weight:bolder">ill-formed</span>
std::ranges::chunk_by_view r2 = {v, [](int, int) { return true; }}; // <span style="color:red;font-weight:bolder">ill-formed</span>
</pre></blockquote>
<p>
This seems unnecessary since I don't see the observable benefit of preventing this. In the standard, 
non-single-argument constructors are rarely specified as <tt>explicit</tt> unless it is really undesirable, 
I think the above initialization is what the user expects since it's clearly intentional, and I don't see 
any good reason to reject it from C++23.
</p>
<p><i>[2022-06-11; Daniel comments]</i></p>

<p>
Another possible candidate could be 26.7.11.3 <a href="https://wg21.link/range.take.while.sentinel">[range.take.while.sentinel]</a>'s
</p>
<blockquote><pre>
constexpr explicit <i>sentinel</i>(sentinel_t&lt;<i>Base</i>&gt; end, const Pred* pred);
</pre></blockquote>

<p><i>[2022-06-21; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll. Send to LEWG.
</p>

<p><i>[2023-01-24; LEWG in Kona]</i></p>

<p>Use alternative approach in <a href="https://wg21.link/P2711">P2711</a> instead.</p>



<p id="res-3714"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 26.7.25.2 <a href="https://wg21.link/range.zip.transform.view">[range.zip.transform.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;copy_constructible F, input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
              regular_invocable&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt; &amp;&amp;
              <i>can-reference</i>&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt;&gt;
  class zip_transform_view : public view_interface&lt;zip_transform_view&lt;F, Views...&gt;&gt; {
    <i>copyable-box</i>&lt;F&gt; <i>fun_</i>;                   <i>// exposition only</i>
    zip_view&lt;Views...&gt; <i>zip_</i>;                <i>// exposition only</i>
    [&hellip;]
  public:
    zip_transform_view() = default;

    constexpr <del>explicit</del> zip_transform_view(F fun, Views... views);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> zip_transform_view(F fun, Views... views);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <tt><i>fun_</i></tt> with <tt>std::move(fun)</tt> and <tt><i>zip_</i></tt> 
with <tt>std::move(views)...</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.27.2 <a href="https://wg21.link/range.adjacent.transform.view">[range.adjacent.transform.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, copy_constructible F, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, <i>REPEAT</i>(range_reference_t&lt;V&gt;, N)...&gt; &amp;&amp;
             <i>can-reference</i>&lt;invoke_result_t&lt;F&amp;, <i>REPEAT</i>(range_reference_t&lt;V&gt;, N)...&gt;&gt;
  class adjacent_transform_view : public view_interface&lt;adjacent_transform_view&lt;V, F, N&gt;&gt; {
    <i>copyable-box</i>&lt;F&gt; <i>fun_</i>;                       <i>// exposition only</i>
    adjacent_view&lt;V, N&gt; <i>inner_</i>;                 <i>// exposition only</i>
    [&hellip;]
  public:
    adjacent_transform_view() = default;
    constexpr <del>explicit</del> adjacent_transform_view(V base, F fun);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> adjacent_transform_view(V base, F fun);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <tt><i>fun_</i></tt> with <tt>std::move(fun)</tt> and 
<tt><i>inner_</i></tt> with <tt>std::move(base)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.28.2 <a href="https://wg21.link/range.chunk.view.input">[range.chunk.view.input]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class chunk_view : public view_interface&lt;chunk_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                                        <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;                         <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Preconditions:</i> <tt>n &gt; 0</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>n_</i></tt> with <tt>n</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.28.6 <a href="https://wg21.link/range.chunk.view.fwd">[range.chunk.view.fwd]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;view V&gt;
    requires forward_range&lt;V&gt;
  class chunk_view&lt;V&gt; : public view_interface&lt;chunk_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                      <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;       <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Preconditions:</i> <tt>n &gt; 0</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>n_</i></tt> with <tt>n</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.29.2 <a href="https://wg21.link/range.slide.view">[range.slide.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;forward_range V&gt;
    requires view&lt;V&gt;
  class slide_view : public view_interface&lt;slide_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                      <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;       <i>// exposition only</i>
    [&hellip;]
  public:
    slide_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> slide_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> slide_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>n_</i></tt> with <tt>n</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.30.2 <a href="https://wg21.link/range.chunk.by.view">[range.chunk.by.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, indirect_binary_predicate&lt;iterator_t&lt;V&gt;, iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class chunk_by_view : public view_interface&lt;chunk_by_view&lt;V, Pred&gt;&gt; {
    V <i>base_</i> = V();                                <i>// exposition only</i>
    <i>copyable-box</i>&lt;Pred&gt; <i>pred_</i> = Pred();            <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_by_view() requires default_initializable&lt;V&gt; &amp;&amp; default_initializable&lt;Pred&gt; = default;
    constexpr <del>explicit</del> chunk_by_view(V base, Pred pred);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_by_view(V base, Pred pred);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>pred_</i></tt> with <tt>std::move(pred)</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3884" href="#3884">3884</a><sup><a href="https://cplusplus.github.io/LWG/issue3884">(i)</a></sup>. <tt>flat_<i>foo</i></tt> is missing allocator-extended copy/move constructors</h3>
<p><b>Section:</b> 24.6.9 <a href="https://wg21.link/flat.map">[flat.map]</a>, 24.6.10 <a href="https://wg21.link/flat.multimap">[flat.multimap]</a>, 24.6.11 <a href="https://wg21.link/flat.set">[flat.set]</a>, 24.6.12 <a href="https://wg21.link/flat.multiset">[flat.multiset]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Arthur O'Dwyer <b>Opened:</b> 2023-02-06 <b>Last modified:</b> 2023-03-23</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#flat.map">active issues</a> in [flat.map].</p>
<p><b>View all other</b> <a href="lwg-index.html#flat.map">issues</a> in [flat.map].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue is part of the "<tt>flat_<i>foo</i></tt>" sequence, LWG <a href="lwg-defects.html#3786">3786</a>, <a href="lwg-active.html#3802">3802</a>,
<a href="lwg-defects.html#3803">3803</a>, <a href="lwg-active.html#3804">3804</a>. <tt>flat_set</tt>, <tt>flat_multiset</tt>, <tt>flat_map</tt>, and
<tt>flat_multimap</tt> all have implicitly defaulted copy and move constructors, but they lack
allocator-extended versions of those constructors. This means that the following code is broken:
</p>
<blockquote><pre>
// <a href="https://godbolt.org/z/qezv5rTrW">https://godbolt.org/z/qezv5rTrW</a>
#include &lt;cassert&gt;
#include &lt;flat_set&gt;
#include &lt;memory_resource&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template&lt;class T, class Comp = std::less&lt;T&gt;&gt;
using pmr_flat_set = std::flat_set&lt;T, Comp, std::pmr::vector&lt;T&gt;&gt;;

int main() {
  std::pmr::vector&lt;pmr_flat_set&lt;int&gt;&gt; vs = {
    {1,2,3},
    {4,5,6},
  };
  std::pmr::vector&lt;int&gt; v = std::move(vs[0]).extract();
  assert(v.get_allocator().resource() == std::pmr::get_default_resource());
}
</pre></blockquote>
<p>
<tt>pmr_flat_set&lt;int&gt;</tt> advertises that it "<tt>uses_allocator</tt>" <tt>std::pmr::polymorphic_allocator&lt;int&gt;</tt>,
but in fact it lacks the allocator-extended constructor overload set necessary to interoperate with <tt>std::pmr::vector</tt>.
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-3884"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928">N4928</a>.
</p>

<ol>
<li><p>Modify 24.6.9.2 <a href="https://wg21.link/flat.map.defn">[flat.map.defn]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Key, class T, class Compare = less&lt;Key&gt;,
  class KeyContainer = vector&lt;Key&gt;, class MappedContainer = vector&lt;T&gt;&gt;
  class flat_map {
  public:
    [&hellip;]
    // <i>24.6.9.3 <a href="https://wg21.link/flat.map.cons">[flat.map.cons]</a>, construct/copy/destroy</i>
    flat_map() : flat_map(key_compare()) { }

    <ins>template&lt;class Allocator&gt;
      flat_map(const flat_map&amp;, const Allocator&amp; a);
    template&lt;class Allocator&gt;
      flat_map(flat_map&amp;&amp;, const Allocator&amp; a);</ins>

    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 24.6.9.3 <a href="https://wg21.link/flat.map.cons">[flat.map.cons]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: As a drive-by fix, a missing closing <tt>&gt;</tt> is inserted in p11.]
</p>
</blockquote>

<blockquote>
<pre>
<ins>template&lt;class Allocator&gt;
  flat_map(const flat_map&amp;, const Allocator&amp; a);
template&lt;class Allocator&gt;
  flat_map(flat_map&amp;&amp;, const Allocator&amp; a);</ins>
template&lt;class Allocator&gt;
  flat_map(const key_compare&amp; comp, const Allocator&amp; a);
template&lt;class Allocator&gt;
  explicit flat_map(const Allocator&amp; a);
template&lt;class InputIterator, class Allocator&gt;
  flat_map(InputIterator first, InputIterator last, const key_compare&amp; comp, const Allocator&amp; a);
template&lt;class InputIterator, class Allocator&gt;
  flat_map(InputIterator first, InputIterator last, const Allocator&amp; a);
[&hellip;]
</pre>
<blockquote>
<p>
-11- <i>Constraints</i>: <tt>uses_allocator_v&lt;key_container_type, Allocator<ins>&gt;</ins></tt> is <tt>true</tt> and
<tt>uses_allocator_v&lt;mapped_container_type, Allocator&gt;</tt> is <tt>true</tt>.
<p/>
-12- <i>Effects</i>: Equivalent to the corresponding non-allocator constructors except that <tt>c.keys</tt> and
<tt>c.values</tt> are constructed with uses-allocator construction (20.2.8.2 <a href="https://wg21.link/allocator.uses.construction">[allocator.uses.construction]</a>).
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 24.6.10.2 <a href="https://wg21.link/flat.multimap.defn">[flat.multimap.defn]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Key, class T, class Compare = less&lt;Key&gt;,
  class KeyContainer = vector&lt;Key&gt;, class MappedContainer = vector&lt;T&gt;&gt;
  class flat_multimap {
  public:
    [&hellip;]
    // <i>24.6.10.3 <a href="https://wg21.link/flat.multimap.cons">[flat.multimap.cons]</a>, construct/copy/destroy</i>
    flat_multimap() : flat_multimap(key_compare()) { }

    <ins>template&lt;class Allocator&gt;
      flat_multimap(const flat_multimap&amp;, const Allocator&amp; a);
    template&lt;class Allocator&gt;
      flat_multimap(flat_multimap&amp;&amp;, const Allocator&amp; a);</ins>

    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 24.6.10.3 <a href="https://wg21.link/flat.multimap.cons">[flat.multimap.cons]</a> as indicated:</p>

<blockquote>
<pre>
<ins>template&lt;class Allocator&gt;
  flat_multimap(const flat_multimap&amp;, const Allocator&amp; a);
template&lt;class Allocator&gt;
  flat_multimap(flat_multimap&amp;&amp;, const Allocator&amp; a);</ins>
template&lt;class Allocator&gt;
  flat_multimap(const key_compare&amp; comp, const Allocator&amp; a);
[&hellip;]
</pre>
<blockquote>
<p>
-11- <i>Constraints</i>: <tt>uses_allocator_v&lt;key_container_type, Allocator&gt;</tt> is <tt>true</tt> and
<tt>uses_allocator_v&lt;mapped_container_type, Allocator&gt;</tt> is <tt>true</tt>.
<p/>
-12- <i>Effects</i>: Equivalent to the corresponding non-allocator constructors except that <tt>c.keys</tt> and
<tt>c.values</tt> are constructed with uses-allocator construction (20.2.8.2 <a href="https://wg21.link/allocator.uses.construction">[allocator.uses.construction]</a>).
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 24.6.11.2 <a href="https://wg21.link/flat.set.defn">[flat.set.defn]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Key, class Compare = less&lt;Key&gt;, class KeyContainer = vector&lt;Key&gt;&gt;
  class flat_set {
  public:
    [&hellip;]
    // <i>24.6.11.3 <a href="https://wg21.link/flat.set.cons">[flat.set.cons]</a>, constructors</i>
    flat_set() : flat_set(key_compare()) { }

    <ins>template&lt;class Allocator&gt;
      flat_set(const flat_set&amp;, const Allocator&amp; a);
    template&lt;class Allocator&gt;
      flat_set(flat_set&amp;&amp;, const Allocator&amp; a);</ins>

    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 24.6.11.3 <a href="https://wg21.link/flat.set.cons">[flat.set.cons]</a> as indicated:</p>

<blockquote>
<pre>
<ins>template&lt;class Allocator&gt;
  flat_set(const flat_set&amp;, const Allocator&amp; a);
template&lt;class Allocator&gt;
  flat_set(flat_set&amp;&amp;, const Allocator&amp; a);</ins>
template&lt;class Allocator&gt;
  flat_set(const key_compare&amp; comp, const Allocator&amp; a);
[&hellip;]
</pre>
<blockquote>
<p>
-9- <i>Constraints</i>: <tt>uses_allocator_v&lt;container_type, Allocator&gt;</tt> is <tt>true</tt>.
<p/>
-10- <i>Effects</i>: Equivalent to the corresponding non-allocator constructors except that <tt><i>c</i></tt> is
constructed with uses-allocator construction (20.2.8.2 <a href="https://wg21.link/allocator.uses.construction">[allocator.uses.construction]</a>).
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 24.6.12.2 <a href="https://wg21.link/flat.multiset.defn">[flat.multiset.defn]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Key, class Compare = less&lt;Key&gt;, class KeyContainer = vector&lt;Key&gt;&gt;
  class flat_multiset {
  public:
    [&hellip;]
    // <i>24.6.12.3 <a href="https://wg21.link/flat.multiset.cons">[flat.multiset.cons]</a>, constructors</i>
    flat_multiset() : flat_multiset(key_compare()) { }

    <ins>template&lt;class Allocator&gt;
      flat_multiset(const flat_multiset&amp;, const Allocator&amp; a);
    template&lt;class Allocator&gt;
      flat_multiset(flat_multiset&amp;&amp;, const Allocator&amp; a);</ins>

    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 24.6.12.3 <a href="https://wg21.link/flat.multiset.cons">[flat.multiset.cons]</a> as indicated:</p>

<blockquote>
<pre>
<ins>template&lt;class Allocator&gt;
  flat_multiset(const flat_multiset&amp;, const Allocator&amp; a);
template&lt;class Allocator&gt;
  flat_multiset(flat_multiset&amp;&amp;, const Allocator&amp; a);</ins>
template&lt;class Allocator&gt;
  flat_multiset(const key_compare&amp; comp, const Allocator&amp; a);
[&hellip;]
</pre>
<blockquote>
<p>
-9- <i>Constraints</i>: <tt>uses_allocator_v&lt;container_type, Allocator&gt;</tt> is <tt>true</tt>.
<p/>
-10- <i>Effects</i>: Equivalent to the corresponding non-allocator constructors except that <tt><i>c</i></tt> is
constructed with uses-allocator construction (20.2.8.2 <a href="https://wg21.link/allocator.uses.construction">[allocator.uses.construction]</a>).
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3885" href="#3885">3885</a><sup><a href="https://cplusplus.github.io/LWG/issue3885">(i)</a></sup>. '<tt>op</tt>' should be in [zombie.names]</h3>
<p><b>Section:</b> 16.4.5.3.2 <a href="https://wg21.link/zombie.names">[zombie.names]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2023-02-11 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
C++98 and C++11 defined a protected member <tt>std::bind1st::op</tt> so '<tt>op</tt>' should still be a reserved name, 
just like '<tt>bind1st</tt>' itself.
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-3885"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928">N4928</a>.
</p>

<ol>
<li><p>Modify 16.4.5.3.2 <a href="https://wg21.link/zombie.names">[zombie.names]</a> as indicated:</p>

<blockquote>
<p>
-2- The following names are reserved as members for previous standardization, and may not be used as a name
for object-like macros in portable code:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <tt>argument_type</tt>,</p></li>
<li><p>[&hellip;]</p></li>
<li><p>(2.3) &mdash; <tt>io_state</tt>,</p></li>
<li><p><ins>(2.?) &mdash; <tt>op</tt>,</ins></p></li>
<li><p>(2.4) &mdash; <tt>open_mode</tt>,</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3887" href="#3887">3887</a><sup><a href="https://cplusplus.github.io/LWG/issue3887">(i)</a></sup>. Version macro for <tt>allocate_at_least</tt></h3>
<p><b>Section:</b> 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2023-02-14 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#version.syn">active issues</a> in [version.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#version.syn">issues</a> in [version.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Issaquah, we just adopted <a href="https://wg21.link/P2652R0">P2652R0</a>, forbidding user specialization of <tt>allocator_traits</tt>. 
<p/>
It looks like we did not deem that worthy of a feature macro.
<p/>
However, it also changed the interface of the C++23 addition, <tt>allocate_at_least</tt>, which is covered by the macro 
<tt>__cpp_lib_allocate_at_least</tt>.
<p/>
I believe we should have updated that macro for this significant change in how that function is accessed 
(from free function to a member of <tt>allocator_traits</tt>). Unfortunately, there are no more meetings 
to process a comment to that effect, and I suspect this rises beyond the purview of an editorial change, 
although I live in hope (as the original paper left the value of the macro to the editor, although we 
approved existing working papers where that macro does have a value, i.e., status quo).
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
But "if we don’t get the editors to do it for C++23 there doesn’t seem to be
any point doing it."
</p>



<p id="res-3887"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928">N4928</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a>, header <tt>&lt;version&gt;</tt> synopsis, as indicated and replace
the placeholder <tt>YYYYMM</tt> by the year and month of adoption of <a href="https://wg21.link/P2652R0">P2652R0</a>:</p>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_algorithm_iterator_requirements  202207L
  // <i>also in &lt;algorithm&gt;, &lt;numeric&gt;, &lt;memory&gt;</i>
#define __cpp_lib_allocate_at_least                <del>202106</del><ins>YYYYMM</ins>L // <i>also in &lt;memory&gt;</i>
#define __cpp_lib_allocator_traits_is_always_equal 201411L
  // <i>also in [&hellip;]</i>
[&hellip;]
</pre>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3893" href="#3893">3893</a><sup><a href="https://cplusplus.github.io/LWG/issue3893">(i)</a></sup>. LWG 3661 broke <tt>atomic&lt;shared_ptr&lt;T&gt;&gt; a; a = nullptr;</tt></h3>
<p><b>Section:</b> 33.5.8.7.2 <a href="https://wg21.link/util.smartptr.atomic.shared">[util.smartptr.atomic.shared]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Zachary Wassall <b>Opened:</b> 2023-02-22 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.atomic.shared">issues</a> in [util.smartptr.atomic.shared].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="lwg-defects.html#3661">3661</a>, "<tt>constinit atomic&lt;shared_ptr&lt;T&gt;&gt; a(nullptr);</tt> should work" 
added the following to <tt>atomic&lt;shared_ptr&lt;T&gt;&gt;</tt>:
</p>
<blockquote><pre>
constexpr atomic(nullptr_t) noexcept : atomic() { }
</pre></blockquote>
<p>
I believe that doing so broke the following example:
</p>
<blockquote><pre>
atomic&lt;shared_ptr&lt;T&gt;&gt; a;
a = nullptr;
</pre></blockquote>
<p>
For reference, <tt>atomic&lt;shared_ptr&lt;T&gt;&gt;</tt> provides two assignment operator overloads:
</p>
<blockquote><pre>
void operator=(const atomic&amp;) = delete;          // #1
void operator=(shared_ptr&lt;T&gt; desired) noexcept;  // #2
</pre></blockquote>
<p>
Prior to LWG <a href="lwg-defects.html#3661">3661</a>, the assignment in the example unambiguously matches #2. #1 is not viable because 
<tt>nullptr_t</tt> is not convertible to <tt>atomic&lt;shared_ptr&lt;T&gt;&gt;</tt>. After LWG 3611, #1 is viable 
and the assignment is ambiguous between #1 and #2.
<p/>
I believe this could be remedied easily enough by adding an assignment operator to match the added 
<tt>nullptr_t</tt> constructor:
</p>
<blockquote><pre>
void operator=(nullptr_t) noexcept;
</pre></blockquote>

<p><i>[2023-02-25; Daniel comments and provides wording]</i></p>

<p>
The suggested delegation below to <tt>store(nullptr)</tt> is not ambiguous and calls the constructor
<tt>shared_ptr(nullptr_t)</tt>, which is guaranteed to be no-throwing.
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-3893"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928">N4928</a>.
</p>

<ol>

<li><p>Modify 33.5.8.7.2 <a href="https://wg21.link/util.smartptr.atomic.shared">[util.smartptr.atomic.shared]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std {
  template&lt;class T&gt; struct atomic&lt;shared_ptr&lt;T&gt;&gt; {
    [&hellip;]
    constexpr atomic() noexcept;
    constexpr atomic(nullptr_t) noexcept : atomic() { }
    atomic(shared_ptr&lt;T&gt; desired) noexcept;
    atomic(const atomic&amp;) = delete;
    void operator=(const atomic&amp;) = delete;
    [&hellip;]
    void operator=(shared_ptr&lt;T&gt; desired) noexcept;
    <ins>void operator=(nullptr_t) noexcept;</ins>
    [&hellip;]
  private:
    shared_ptr&lt;T&gt; p; // <i>exposition only</i>
  };
}
</pre>
</blockquote>
[&hellip;]
<pre>
void operator=(shared_ptr&lt;T&gt; desired) noexcept;
</pre>
<blockquote>
<p>
-5- <i>Effects</i>: Equivalent to <tt>store(desired)</tt>.
</p>
</blockquote>
<pre>
<ins>void operator=(nullptr_t) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Equivalent to <tt>store(nullptr)</tt>.</ins>
</p>
</blockquote>
</blockquote>


</li>


</ol>





<hr>
<h3><a name="3894" href="#3894">3894</a><sup><a href="https://cplusplus.github.io/LWG/issue3894">(i)</a></sup>. <tt>generator::promise_type::yield_value(ranges::elements_of&lt;Rng, Alloc&gt;)</tt> should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 26.8.5 <a href="https://wg21.link/coro.generator.promise">[coro.generator.promise]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2023-02-25 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#coro.generator.promise">active issues</a> in [coro.generator.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#coro.generator.promise">issues</a> in [coro.generator.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The overload of <tt>yield_value</tt> for yielding elements of arbitrary ranges does so by creating a nested generator, 
but to do so it needs to:
</p>
<ul>
<li><p>call <tt>ranges::begin</tt>/<tt>ranges::end</tt> on the range  </p></li>
<li><p>allocate a new coroutine frame (unless the allocation is elided by the compiler, which isn't guaranteed)</p></li>
<li><p>copy/move the iterator and sentinel into the coroutine frame</p></li>
</ul>
<p>
All of these are allowed to throw, so this overload should not be <tt>noexcept</tt>.
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-3894"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928">N4928</a>.
</p>

<ol>

<li><p>Modify 26.8.5 <a href="https://wg21.link/coro.generator.promise">[coro.generator.promise]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std {
  template&lt;class Ref, class V, class Allocator&gt;
  class generator&lt;Ref, V, Allocator&gt;::promise_type {
  public:
    [&hellip;]
    auto yield_value(const remove_reference_t&lt;yielded&gt;&amp; lval)
      requires is_rvalue_reference_v&lt;yielded&gt; &amp;&amp;
        constructible_from&lt;remove_cvref_t&lt;yielded&gt;, const remove_reference_t&lt;yielded&gt;&amp;&gt;;
    
    template&lt;class R2, class V2, class Alloc2, class Unused&gt;
      requires same_as&lt;typename generator&lt;R2, V2, Alloc2&gt;::yielded, yielded&gt;
        auto yield_value(ranges::elements_of&lt;generator&lt;R2, V2, Alloc2&gt;&amp;&amp;, Unused&gt; g) noexcept;
    
    template&lt;ranges::input_range R, class Alloc&gt;
      requires convertible_to&lt;ranges::range_reference_t&lt;R&gt;, yielded&gt;
        auto yield_value(ranges::elements_of&lt;R, Alloc&gt; r) <del>noexcept</del>;
    [&hellip;]
   };
}
</pre>
</blockquote>
[&hellip;]
<pre>
template&lt;ranges::input_range R, class Alloc&gt;
  requires convertible_to&lt;ranges::range_reference_t&lt;R&gt;, yielded&gt;
  auto yield_value(ranges::elements_of&lt;R, Alloc&gt; r) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-13- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
auto nested = [](allocator_arg_t, Alloc, ranges::iterator_t&lt;R&gt; i, ranges::sentinel_t&lt;R&gt; s)
  -&gt; generator&lt;yielded, ranges::range_value_t&lt;R&gt;, Alloc&gt; {
    for (; i != s; ++i) {
      co_yield static_cast&lt;yielded&gt;(*i);
    }
  };
return yield_value(ranges::elements_of(nested(
  allocator_arg, r.allocator, ranges::begin(r.range), ranges::end(r.range))));
</pre></blockquote>
[&hellip;]
</blockquote>
</blockquote>


</li>


</ol>





<hr>
<h3><a name="3901" href="#3901">3901</a><sup><a href="https://cplusplus.github.io/LWG/issue3901">(i)</a></sup>. Is uses-allocator construction of a <i>cv</i>-qualified object type still well-formed after LWG 3870?</h3>
<p><b>Section:</b> 20.2.8 <a href="https://wg21.link/allocator.uses">[allocator.uses]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-05 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="lwg-defects.html#3870">3870</a> made <tt>std::construct_at</tt> unable to create an object of a <i>cv</i>-qualified type, 
which affects <tt>std::uninitialized_construct_using_allocator</tt>. However, uses-allocator construction is 
currently not required to be equivalent to some call to <tt>std::uninitialized_construct_using_allocator</tt>, 
which possibly implies that uses-allocator construction of a <i>cv</i>-qualified type may still be required to be 
well-formed.
<p/>
Should we make such construction ill-formed?
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>Set status to Tentatively NAD.</p>
<p>Not all uses-allocator construction is done using <code>construct_at</code>.
<code>std::tuple&lt;const T&gt;(allocator_arg, alloc)</code> does
uses-allocator construction of a const type, so we can't make it ill-formed.
</p>



<p id="res-3901"><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3903" href="#3903">3903</a><sup><a href="https://cplusplus.github.io/LWG/issue3903">(i)</a></sup>. <tt>span</tt> destructor is redundantly <tt>noexcept</tt></h3>
<p><b>Section:</b> 24.7.2.2.1 <a href="https://wg21.link/span.overview">[span.overview]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ben Craig <b>Opened:</b> 2023-03-11 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#span.overview">active issues</a> in [span.overview].</p>
<p><b>View all other</b> <a href="lwg-index.html#span.overview">issues</a> in [span.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>span</tt> class template synopsis in 24.7.2.2.1 <a href="https://wg21.link/span.overview">[span.overview]</a> has this declaration:
</p>
<blockquote><pre>
~span() noexcept = default;
</pre></blockquote>
<p>
The <tt>noexcept</tt> is redundant, as <tt>~span</tt> is <tt>noexcept</tt> automatically. I think the entire 
declaration is unnecessary as well. There is no additional specification for <tt>~span()</tt> at all, much 
less some that warrants inclusion in the class template synopsis.
<p/>
Recommended fix:
</p>
<blockquote><pre>
<del>~span() noexcept = default;</del>
</pre></blockquote>
<p>
Alternative fix:
</p>
<blockquote><pre>
~span() <del>noexcept</del> = default;
</pre></blockquote>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-3903"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928">N4928</a>.
</p>

<ol>

<li><p>Modify 24.7.2.2.1 <a href="https://wg21.link/span.overview">[span.overview]</a>, class template <tt>span</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]

<del>~span() noexcept = default;</del>

[&hellip;]
</pre>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3904" href="#3904">3904</a><sup><a href="https://cplusplus.github.io/LWG/issue3904">(i)</a></sup>. <tt>lazy_split_view::<i>outer-iterator</i></tt>'s <tt>const</tt>-converting constructor isn't setting <tt><i>trailing_empty_</i></tt></h3>
<p><b>Section:</b> 26.7.16.3 <a href="https://wg21.link/range.lazy.split.outer">[range.lazy.split.outer]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Patrick Palka <b>Opened:</b> 2023-03-13 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.lazy.split.outer">active issues</a> in [range.lazy.split.outer].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.lazy.split.outer">issues</a> in [range.lazy.split.outer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems the <tt>const</tt>-converting constructor for <tt>lazy_split_view</tt>'s iterator fails
to propagate <tt><i>trailing_empty_</i></tt> from the argument, which effectively results in
the trailing empty range getting skipped over:
</p>
<blockquote><pre>
auto r = views::single(0) | views::lazy_split(0); // r is { {}, {} }
auto i = r.begin();
++i; // i.trailing_empty_ is correctly true
decltype(std::as_const(r).begin()) j = i; // <span style="color:red;font-weight:bolder">j.trailing_empty_ is incorrectly false</span>
auto k = r.end(); // <span style="color:red;font-weight:bolder">k.trailing_empty_ is correctly false, and we wrongly have j == k</span>
</pre></blockquote>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-3904"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928">N4928</a>.
</p>

<ol>

<li><p>Modify 26.7.16.3 <a href="https://wg21.link/range.lazy.split.outer">[range.lazy.split.outer]</a> as indicated:</p>

<blockquote>
<pre>
constexpr <i>outer-iterator</i>(<i>outer-iterator</i>&lt;!Const&gt; i)
  requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, iterator_t&lt;<i>Base</i>&gt;&gt;;
</pre>
<blockquote>
<p>
-4- <i>Effects</i>: Initializes <tt><i>parent_</i></tt> with <tt>i.<i>parent_</i></tt><ins>,</ins> 
<del>and</del> <tt><i>current_</i></tt> with <tt>std::move(i.<i>current_</i>)</tt><ins>, and 
<tt><i>trailing_empty_</i></tt> with <tt>i.<i>trailing_empty_</i></tt></ins>.
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3905" href="#3905">3905</a><sup><a href="https://cplusplus.github.io/LWG/issue3905">(i)</a></sup>. Type of <tt>std::fexcept_t</tt></h3>
<p><b>Section:</b> 28.3.1 <a href="https://wg21.link/cfenv.syn">[cfenv.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Sam Elliott <b>Opened:</b> 2023-03-13 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>&lt;cfenv&gt;</tt>, as specified in 28.3.1 <a href="https://wg21.link/cfenv.syn">[cfenv.syn]</a>, requires <tt>fexcept_t</tt> to be
an integer type:
</p>
<blockquote><pre>
using fexcept_t = <i>integer type</i>;
</pre></blockquote>
<p>
<tt>&lt;cfenv&gt;</tt> was initially added to the (first) Technical Report on
C++ Library Extensions via <a href="https://wg21.link/N1568">N1568</a> and then integrated into the 
C++ Working Draft N2009 in Berlin (April, 2006).
<p/>
However, C99 does not actually require that <tt>fexcept_t</tt> is
an integer type, it only requires:
</p>
<blockquote>
<p>
The type <tt>fexcept_t</tt> represents the floating-point status flags
collectively, including any status the implementation associates
with the flags.
</p>
</blockquote>
<p>
Relaxing this requirement should not cause conforming C++ implementations to no longer be conforming. 
In fact, this should enable conforming C implementations to become conforming C++ implementations without 
an ABI break. The only incompatibility I foresee is where a user's program is initializing a <tt>std::fexcept_t</tt> 
with an integer value, which would become invalid on some C++ implementations (but not those that were 
previously conforming).
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-3905"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928">N4928</a>.
</p>

<ol>

<li><p>Modify 28.3.1 <a href="https://wg21.link/cfenv.syn">[cfenv.syn]</a>, header <tt>&lt;cfenv&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
namespace std {
  // <i>types</i>
  using fenv_t = <i>object type</i>;
  using fexcept_t = <i><del>integer</del><ins>object</ins> type</i>;
  [&hellip;]
}
</pre>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3908" href="#3908">3908</a><sup><a href="https://cplusplus.github.io/LWG/issue3908">(i)</a></sup>. <code>enumerate_view::<i>iterator</i></code> constructor is explicit</h3>
<p><b>Section:</b> 26.7.23.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2023-03-23 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.enumerate.iterator">active issues</a> in [range.enumerate.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.enumerate.iterator">issues</a> in [range.enumerate.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>enumerate_view::<i>iterator</i></code> has this constructor:
</p>
<blockquote>
<pre><code>    constexpr explicit
      <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);  <i>// exposition only</i>
</code></pre>
</blockquote>

<p>
In <a href="https://wg21.link/P2164R9">P2164R9</a> the detailed description of the function showed a
default argument for the second parameter, which would justify it being
explicit. However, that default argument was not present in the class synopsis
and was removed from the detailed description when applying the paper to the
draft.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after four votes in favour during reflector poll.
</p>



<p id="res-3908"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944">N4944</a>.
</p>
<ol>
<li>
<p>
Modify the class synopsis in 26.7.23.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a>
as shown:
</p>
<blockquote><pre><code>
    constexpr <del>explicit</del>
      <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);  <i>// exposition only</i>
</code></pre></blockquote>
</li>

<li>
<p>
Modify the detailed description in 26.7.23.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a>
as shown:
</p>
<blockquote>
<pre><code>  constexpr <del>explicit</del> <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);
</code></pre>
<p>-2-
<i>Effects</i>: Initializes <code><i>current_</i></code>
with <code>std::move(current)</code> and <code><i>pos_</i></code> with
<code>pos</code>.
</p>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="3909" href="#3909">3909</a><sup><a href="https://cplusplus.github.io/LWG/issue3909">(i)</a></sup>. Issues about <code>viewable_range</code></h3>
<p><b>Section:</b> 99 [ranges.refinements], 26.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-27 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After LWG <a href="lwg-defects.html#3724">3724</a>, <code>views::all</code> is well-constrained for view types,
and the constraints are stronger than <code>viewable_range</code>.
The difference is that given an expression such that <code>decltype</code> gives <code>R</code>,
when <code>decay_t&lt;R&gt;</code> is a view type and the implicit conversion of <code>R</code>
to <code>decay_t&lt;R&gt;</code> is forbidden, <code>views::all</code> rejects the expression,
but <code>viewable_range</code> may accept <code>R</code>.
So I think we should remove the additional constraints on <code>views::all_t</code>.
</p>
<p>
While <code>viewable_range</code> is probably not introducing any additional constraint within the standard library,
I think it is still useful to express the constraints on <code>views::all</code>,
so it should be slightly adjusted to match <code>views::all</code>.
</p>
<p>
Furthermore, <code>viewable_range</code> is currently used in 26.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a>,
but given <a href="https://wg21.link/P2378R3">P2378R3</a> relaxed the requirements for range adaptor closure objects,
I think we should also apply similar relaxation for range adaptor objects.
This should have no impact on standard range adaptor objects.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after three votes in favour during reflector poll.
</p>
<p>
"First change is pointless. Second change is a duplicate of <a href="lwg-active.html#3896">3896</a>.
Range adaptors return a view over their first argument, so they need to
require it's a <code>viewable_range</code>."
</p>



<p id="res-3909"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944">N4944</a>.
</p>

<ol>
<li>
<p>
Change the definition of <code>views::all_t</code> in 26.2 <a href="https://wg21.link/ranges.syn">[ranges.syn]</a> as indicated:
</p>
<blockquote><pre><code>
   template&lt;<del>viewable_range</del><ins>class</ins> R&gt;
      using all_t = decltype(all(declval&lt;R&gt;()));          // freestanding
</code></pre>
</blockquote>
</li>
<li>
<p>
Change the definition of <code>viewable_range</code> in 26.4.5 <a href="https://wg21.link/range.refinements">[range.refinements]</a> as indicated:
</p>
<blockquote>
<p>-6-
The <code>viewable_range</code> concept specifies the requirements of a <code>range</code> type
that can be converted to a view safely.
</p>
<pre><code>
template&lt;class T&gt;
  concept viewable_range =
    range&lt;T&gt; &amp;&amp;
    ((view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp; <del>constructible_from&lt;remove_cvref_t&lt;T&gt;, T&gt;</del> <ins>convertible_to&lt;T, remove_cvref_t&lt;T&gt;&gt;</ins>) ||
     (!view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp;
      (is_lvalue_reference_v&lt;T&gt; || (movable&lt;remove_reference_t&lt;T&gt;&gt; &amp;&amp; !<i>is-initializer-list</i>&lt;T&gt;))));
</code></pre>
</blockquote>
</li>
<li>
<p>
Change 26.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> as indicated:
</p>
<blockquote>
<p>-6-
A <i>range adaptor object</i> is a customization point object (16.3.3.3.5 <a href="https://wg21.link/customization.point.object">[customization.point.object]</a>)
that accepts a <code><del>viewable_range</del><ins>range</ins></code> as its first argument
and returns a view.
</p>
<p>
[&hellip;]
</p>
<p>-8-
If a range adaptor object <code>adaptor</code> accepts more than one argument,
then let <code>range</code> be an expression such that <code>decltype((range))</code>
models <code><del>viewable_range</del><ins>range</ins></code>,
let <code>args...</code> be arguments such that <code>adaptor(range, args...)</code>
is a well-formed expression as specified in the rest of subclause 26.7 <a href="https://wg21.link/range.adaptors">[range.adaptors]</a>,
and let <code>BoundArgs</code> be a pack that denotes <code>decay_t&lt;decltype((args))&gt;...</code>.
The expression <code>adaptor(args...)</code> produces a range adaptor closure object
<code>f</code> that is a perfect forwarding call wrapper (22.10.4 <a href="https://wg21.link/func.require">[func.require]</a>)
with the following properties: [...]
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="3912" href="#3912">3912</a><sup><a href="https://cplusplus.github.io/LWG/issue3912">(i)</a></sup>. <code>enumerate_view::iterator::operator-</code> should be <code>noexcept</code></h3>
<p><b>Section:</b> 26.7.23.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-03-27 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.enumerate.iterator">active issues</a> in [range.enumerate.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.enumerate.iterator">issues</a> in [range.enumerate.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The distance between two <code>enumerate_view::iterator</code>
is calculated by subtracting two integers, which never throws.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-3912"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944">N4944</a>.
</p>

<ol>
<li>
<p>
Modify 26.7.23.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a> as indicated:
</p>
<blockquote>
<pre><code>
namespace std::ranges {
  template&lt;view V&gt;
    requires <i>range-with-movable-references</i>&lt;V&gt;
  template&lt;bool Const&gt;
  class enumerate_view&lt;V&gt;::<i>iterator</i> {
    [&hellip;]
    public:
    [&hellip;]
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)<ins> noexcept</ins>;
    [&hellip;]
  }
  [&hellip;]
}
</code></pre>
[&hellip;]
<pre><code>
friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)<ins> noexcept</ins>;
</code></pre>
<p>
-19- <i>Effects</i>:
Equivalent to: <code>return x.<i>pos_</i> - y.<i>pos_</i>;</code>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3914" href="#3914">3914</a><sup><a href="https://cplusplus.github.io/LWG/issue3914">(i)</a></sup>. Inconsistent <i>template-head</i> of <tt>ranges::enumerate_view</tt></h3>
<p><b>Section:</b> 26.2 <a href="https://wg21.link/ranges.syn">[ranges.syn]</a>, 26.7.23 <a href="https://wg21.link/range.enumerate">[range.enumerate]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Johel Ernesto Guerrero Pe&ntilde;a <b>Opened:</b> 2023-03-30 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#ranges.syn">active issues</a> in [ranges.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#ranges.syn">issues</a> in [ranges.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Originally editorial issue <a href="https://github.com/cplusplus/draft/issues/6151">Editorial issue #6151</a>.
<p/>
The <i>template-head</i> of <tt>ranges::enumerate_view</tt> in the header synopsis
is different from those in the class synopses of itself and its iterator/sentinel pair.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-3914"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944">N4944</a>.
</p>

<ol>
<li>
<p>Modify 26.2 <a href="https://wg21.link/ranges.syn">[ranges.syn]</a> as indicated:</p>

<blockquote><pre>
[&hellip;]
// <i>26.7.23 <a href="https://wg21.link/range.enumerate">[range.enumerate]</a>, enumerate view</i>
template&lt;<ins>view V</ins><del>input_range View</del>&gt;
  requires <ins><i>see below</i></ins><del>view&lt;View&gt;</del>
class enumerate_view;
[&hellip;]
</pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="3915" href="#3915">3915</a><sup><a href="https://cplusplus.github.io/LWG/issue3915">(i)</a></sup>. Redundant paragraph about expression variations</h3>
<p><b>Section:</b> 26.4.2 <a href="https://wg21.link/range.range">[range.range]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Johel Ernesto Guerrero Pe&ntilde;a <b>Opened:</b> 2023-04-01 <b>Last modified:</b> 2023-05-25</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.range">issues</a> in [range.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Originally editorial issue <a href="https://github.com/cplusplus/draft/issues/4431">Editorial issue #4431</a>.
<p/>
Expression variations kick in for "an expression that is non-modifying for some constant lvalue operand", but 
<tt>std::ranges::range</tt>'s is an non-constant lvalue, so 26.4.2 <a href="https://wg21.link/range.range">[range.range]</a> p2 is redundant.
<p/>
I suppose that the change that clarified the template parameters' <i>cv</i>-qualification for purposes of 
equality-preservation and requiring additional variations happened concurrently with the change of 
<tt>std::ranges::range</tt>'s operand from a forwarding reference to a non-constant lvalue reference.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-3915"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944">N4944</a>.
</p>

<ol>
<li>
<p>Modify 26.2 <a href="https://wg21.link/ranges.syn">[ranges.syn]</a> as indicated:</p>

<blockquote>
<p>
-1- The <tt>range</tt> concept defines the requirements of a type that allows iteration over its elements by providing an
iterator and sentinel that denote the elements of the range.
</p>
<pre>
template&lt;class T&gt;
  concept range =
    requires(T&amp; t) {
      ranges::begin(t); // <i>sometimes equality-preserving (see below)</i>
      ranges::end(t);
    };
</pre>
<blockquote>
<del>-2- The required expressions <tt>ranges::begin(t)</tt> and <tt>ranges::end(t)</tt> of the <tt>range</tt> 
concept do not require implicit expression variations (18.2 <a href="https://wg21.link/concepts.equality">[concepts.equality]</a>).</del>
<p/>
-3- [&hellip;]
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="3925" href="#3925">3925</a><sup><a href="https://cplusplus.github.io/LWG/issue3925">(i)</a></sup>. Concept <tt>formattable</tt>'s definition is incorrect</h3>
<p><b>Section:</b> 22.14.6.2 <a href="https://wg21.link/format.formattable">[format.formattable]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Mark de Wever <b>Opened:</b> 2023-04-16 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#format.formattable">active issues</a> in [format.formattable].</p>
<p><b>View all other</b> <a href="lwg-index.html#format.formattable">issues</a> in [format.formattable].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="lwg-defects.html#3631">3631</a> modified the <tt>formattable</tt> concept. The new wording 
contains a small issue: <tt>basic_format_context</tt> requires two template arguments, 
but only one is provided.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after ten votes in favour during reflector poll.
</p>



<p id="res-3925"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944">N4944</a>.
</p>
<ol>
<li>
<p>Modify 22.14.6.2 <a href="https://wg21.link/format.formattable">[format.formattable]</a> as indicated:</p>

<blockquote>
<p>
-1- Let <tt><i>fmt-iter-for</i>&lt;charT&gt;</tt> be an unspecified type that models 
<tt>output_iterator&lt;const charT&amp;&gt;</tt> (25.3.4.10 <a href="https://wg21.link/iterator.concept.output">[iterator.concept.output]</a>).
</p>
<blockquote><pre>
[&hellip;]
template&lt;class T, class charT&gt;
  concept formattable =
    <i>formattable-with</i>&lt;remove_reference_t&lt;T&gt;, basic_format_context&lt;<i>fmt-iter-for</i>&lt;charT&gt;<ins>, charT</ins>&gt;&gt;;
</pre></blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="3927" href="#3927">3927</a><sup><a href="https://cplusplus.github.io/LWG/issue3927">(i)</a></sup>. Unclear preconditions for <tt>operator[]</tt> for sequence containers</h3>
<p><b>Section:</b> 24.2.4 <a href="https://wg21.link/sequence.reqmts">[sequence.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2023-04-24 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 24.2.4 <a href="https://wg21.link/sequence.reqmts">[sequence.reqmts]</a>/118, we specify what <tt>a[n]</tt> means for a sequence
container <tt>a</tt>, but we don't state that it actually has preconditions, other
than implied ones.
<p/>
When we want to use implied preconditions, we can actually get them by using the "<i>Effects</i>: 
Equivalent to..." wording.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-3927"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944">N4944</a>.
</p>

<ol>
<li>
<p>Modify 24.2.4 <a href="https://wg21.link/sequence.reqmts">[sequence.reqmts]</a> as indicated:</p>

<blockquote><pre>
a[n]
</pre><blockquote>
<p>
-118- <i>Result</i>: <tt>reference</tt>; <tt>const_reference</tt> for constant <tt>a</tt>
<p/>
-119- <i><del>Returns</del><ins>Effects</ins></i>: <ins>Equivalent to:</ins> <tt><ins>return</ins> *(a.begin() + n)<ins>;</ins></tt>
<p/>
-120- <i>Remarks</i>: Required for <tt>basic_string</tt>, <tt>array</tt>, <tt>deque</tt>, and <tt>vector</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3930" href="#3930">3930</a><sup><a href="https://cplusplus.github.io/LWG/issue3930">(i)</a></sup>. Simplify type trait wording</h3>
<p><b>Section:</b> 21 <a href="https://wg21.link/meta">[meta]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2023-05-01 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are many traits that have a requirement that they are instantiated only if
"<tt>T</tt> shall be a complete type, <i>cv</i> <tt>void</tt>, or an array of unknown bound."
<p/>
Breaking down what this means, by supporting <i>cv</i>-<tt>void</tt> and arrays of unknown
bound (almost) the only remaining type-category is incomplete class types.
<p/>
The remaining edge case is incomplete enumerations, but they are required to
have a known fixed-base, so act as complete types, they can be copied,
assigned, etc., without knowing the names of their enumerators.
<p/>
Hence, I suggest clearer wording would be:
"<tt>T</tt> shall not be an incomplete class type."
<p/>
This is easier to understand, as we do not need to mentally enumerate every
type against a list to check it qualifies; it is a simpler test for the library to
check if we were to mandate these restrictions.
<p/>
There are a very small number of traits with subtly different wording, where
incomplete unions are supported, or arrays of unknown bound are not a
concern due to invoking <tt>remove_all_extents</tt> first. The bulk of the changes
can be made to traits with only the precise wording above though, and then
we can review whether any of the remaining restrictions deserve a wording
update of their own.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after four votes in favour during reflector poll,
including a request to withdraw the issue from the submitter.
</p>
<p>
Incomplete enumeration types are found within the <i>enum-specifier</i>
of an enum without a fixed underlying type:
<pre><code>
enum E {
    A = sizeof(E) // error, E is incomplete at this point
};
</code></pre>
and we definitely can't provide an underlying type for this case.
</p>



<p id="res-3930"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944">N4944</a>.
</p>

<ol>
<li>
<p>
Throughout 21 <a href="https://wg21.link/meta">[meta]</a> replace all occurrences of
</p>
<blockquote><p>
<tt>T</tt> shall be a complete type, <i>cv</i> <tt>void</tt>, or an array of unknown bound.
</p></blockquote>
<p>
by
</p>
<blockquote><p>
<tt>T</tt> shall not be an incomplete class type.
</p></blockquote>

</li>

</ol>





<hr>
<h3><a name="3935" href="#3935">3935</a><sup><a href="https://cplusplus.github.io/LWG/issue3935">(i)</a></sup>. <tt>template&lt;class X&gt; constexpr complex&amp; operator=(const complex&lt;X&gt;&amp;)</tt> has no specification</h3>
<p><b>Section:</b> 28.4.3 <a href="https://wg21.link/complex">[complex]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2023-05-21 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#complex">active issues</a> in [complex].</p>
<p><b>View all other</b> <a href="lwg-index.html#complex">issues</a> in [complex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The class template <tt>complex</tt> synopsis in 28.4.3 <a href="https://wg21.link/complex">[complex]</a> shows the following member function template:
</p>
<blockquote><pre>
template&lt;class X&gt; constexpr complex&amp; operator= (const complex&lt;X&gt;&amp;);
</pre></blockquote>
<p>
but does not specify its semantics. This affects a code example such as the following one:
</p>
<blockquote><pre>
#include &lt;complex&gt;

int main()
{
  std::complex&lt;double&gt; zd(1, 1);
  std::complex&lt;float&gt; zf(2, 0);
  zd = zf;
}
</pre></blockquote>
<p>
This problem exists since the 1998 version of the standard (at that time this was declared in subclause [lib.complex]),
and even though this looks like a "copy-assignment-like" operation, its effects aren't implied by our general
16.3.3.4 <a href="https://wg21.link/functions.within.classes">[functions.within.classes]</a> wording (a function template is never considered as copy assignment operator,
see 11.4.6 <a href="https://wg21.link/class.copy.assign">[class.copy.assign]</a>).
<p/>
It should be point out that the refactoring done by <a href="https://wg21.link/P1467R9">P1467R9</a> had caused some other members to become finally
specified that were not specified before, but in addition to LWG <a href="lwg-active.html#3934">3934</a>'s observation about the missing
specification of the assignment operator taking a value type as parameter, this is now an additional currently unspecified 
member, but unaffected by any decision on LWG <a href="lwg-active.html#3933">3933</a>.
</p>


<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p id="res-3935"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950">N4950</a>.
</p>
<ol>

<li>
<p>Add a new prototype specification between the current paragraphs 8 and 9 of 28.4.5 <a href="https://wg21.link/complex.member.ops">[complex.member.ops]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: Similar to the proposed wording for LWG <a href="lwg-active.html#3934">3934</a>, the wording form used below intentionally 
deviates from the rest of the [complex.member.ops] wording forms, because it seems much simpler and clearer to follow the wording 
forms used that specify the effects of <tt>imag</tt> and <tt>real</tt> functions plus borrowing relevant parts from 
28.4.4 <a href="https://wg21.link/complex.members">[complex.members]</a> p2.]
</p>
</blockquote>

<blockquote>
<pre>
constexpr complex&amp; operator/=(const T&amp; rhs);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
<ins>template&lt;class X&gt; constexpr complex&amp; operator=(const complex&lt;X&gt;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Assigns the value <tt>rhs.real()</tt> to the real part and the value 
<tt>rhs.imag()</tt> to the imaginary part of the complex value <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Returns</i>: <tt>*this</tt>.</ins>
</p>
</blockquote>
<pre>
template&lt;class X&gt; constexpr complex&amp; operator+=(const complex&lt;X&gt;&amp; rhs);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="3936" href="#3936">3936</a><sup><a href="https://cplusplus.github.io/LWG/issue3936">(i)</a></sup>. Are implementations allowed to deprecate components not in [depr]?</h3>
<p><b>Section:</b> D <a href="https://wg21.link/depr">[depr]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-05-22 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
D.1 <a href="https://wg21.link/depr.general">[depr.general]</a>/2 allows implementations to apply the
<code>deprecated</code> attribute to deprecated components.
However, there doesn't seem to be any wording disallowing applying the
<code>deprecated</code> attribute to non-deprecated components.
</p>
<p>
Is it intended to allow implementations to deprecate every library component
as they want? If so, should we turn the allowance into "<i>Recommended practice</i>" and move it to somewhere in 16.4 <a href="https://wg21.link/requirements">[requirements]</a>?
</p>
<p>
There doesn't seem to be wording which formally recommends applying
<code>deprecated</code> attribute to deprecated components either.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after nine votes in favour during reflector poll.
Let implementations decide when to apply these attributes.
</p>



<p id="res-3936"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950">N4950</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i>
There are two mutually exclusive proposed resolutions,
depending on whether it is allowed to deprecate components not in
D <a href="https://wg21.link/depr">[depr]</a>.
</p>
</blockquote>

<p><strong>Option A:</strong></p>

<ol>
<li>
<p>Insert a paragraph at the end of 16.4.2.2 <a href="https://wg21.link/contents">[contents]</a>:</p>

<blockquote>
<p>
<ins>
-?- <i>Recommended practice</i>:
Implementations should not apply the <code>deprecated</code> attribute
(9.12.5 <a href="https://wg21.link/dcl.attr.deprecated">[dcl.attr.deprecated]</a>) to library entities that are not
specified in D <a href="https://wg21.link/depr">[depr]</a>.
Implementations should apply the <code>deprecated</code> attribute to
library entities specified in D <a href="https://wg21.link/depr">[depr]</a> whenever possible.
</ins>
</p>
</blockquote>
</li>
</ol>

<p><strong>Option B:</strong></p>

<ol>
<li>
<p>Insert two paragraphs at the end of 16.4.2.2 <a href="https://wg21.link/contents">[contents]</a>:</p>

<blockquote>
<p>
<ins>
-?- Implementations shall not apply the <code>deprecated</code> attribute
(9.12.5 <a href="https://wg21.link/dcl.attr.deprecated">[dcl.attr.deprecated]</a>) to library entities that are not
specified in D <a href="https://wg21.link/depr">[depr]</a>.
</ins>
</p>
<p>
<ins>-?- <i>Recommended practice</i>:
Implementations should apply the <code>deprecated</code> attribute to
library entities specified in D <a href="https://wg21.link/depr">[depr]</a> whenever possible.
</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3938" href="#3938">3938</a><sup><a href="https://cplusplus.github.io/LWG/issue3938">(i)</a></sup>. Cannot use <code>std::expected</code> monadic ops with move-only <code>error_type</code></h3>
<p><b>Section:</b> 22.8.6.7 <a href="https://wg21.link/expected.object.monadic">[expected.object.monadic]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2023-05-25 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#expected.object.monadic">issues</a> in [expected.object.monadic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The monadic ops for <code>std::expected</code> are specified in terms of calls
to <code>value()</code> and <code>error()</code>, but LWG <a href="lwg-defects.html#3843">3843</a>
("<code>std::expected&lt;T,E&gt;::value()&amp;</code> assumes <code>E</code>
is copy constructible") added additional <i>Mandates</i> requirements to
<code>value()</code>. This means that you can never call <code>value()</code>
for a move-only <code>error_type</code>, even the overloads of
<code>value()</code> with rvalue ref-qualifiers.
</p>
<p>
The changes to <code>value()</code> are because it needs to be able to throw a
<code>bad_expected_access&lt;E&gt;</code> which requires a copyable <code>E</code>.
But in the monadic ops we know it can't throw, because we always check.
All the monadic ops are of the form:
</p>
<blockquote>
<pre><code>if (has_value())
  <i>do something with</i> value();
else
  <i>do something with</i> error();
</code></pre></blockquote>
<p>
We know that <code>value()</code> won't throw here, but because we use
"<i>Effects</i>: Equivalent to ..." the requirement for <code>E</code>
to be copyable is inherited from <code>value()</code>.
</p>
<p>
Should we have changed the monadic ops to use <code>operator*()</code>
instead of <code>value()</code>?
For example, for the first <code>and_then</code> overloads the change would be:
</p>
<blockquote>
-4- <i>Effects</i>: Equivalent to:
<blockquote>
<pre><code>if (has_value())
  return invoke(std::forward&lt;F&gt;(f), <del>value()</del><ins>**this</ins>);
else
  return U(unexpect, error());
</code></pre></blockquote>
</blockquote>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-3938"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950">N4950</a>.
</p>

<ol>
<li>
<p>
For each <i>Effects</i>: element in 22.8.6.7 <a href="https://wg21.link/expected.object.monadic">[expected.object.monadic]</a>,
replace <code>value()</code> with <code>**this</code> as indicated:
</p>

<blockquote>
<pre><code>
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) &amp;;
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) const &amp;;
</code></pre>
<p>-1- Let <code>U</code> be
<code>remove_cvref_t&lt;invoke_result_t&lt;F, decltype(<del>value()</del><ins>**this</ins>)&gt;&gt;</code>.
</p>
<p>-2- <i>Constraints</i>:
<code>is_constructible_v&lt;E, decltype(error())&gt;</code>
is <code>true</code>.
</p>
<p>-3- <i>Mandates</i>:
<code>U</code> is a specialization of <code>expected</code> and
<code>is_same_v&lt;U::error_type, E&gt;</code> is <code>true</code>.
</p>
<p>-4- <i>Effects</i>: Equivalent to:</p>
<blockquote>
<pre><code>if (has_value())
  return invoke(std::forward&lt;F&gt;(f), <del>value()</del><ins>**this</ins>);
else
  return U(unexpect, error());
</code></pre>
</blockquote>

<pre><code>
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) &amp;&amp;;
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) const &amp;&amp;;
</code></pre>
<p>-5- Let <code>U</code> be
<code>remove_cvref_t&lt;invoke_result_t&lt;F, decltype(std::move(<del>value()</del><ins>**this</ins>))&gt;&gt;</code>.
</p>
<p>-6- <i>Constraints</i>:
<code>is_constructible_v&lt;E, decltype(std::move(error()))&gt;</code>
is <code>true</code>.
</p>
<p>-7- <i>Mandates</i>:
<code>U</code> is a specialization of <code>expected</code> and
<code>is_same_v&lt;U::error_type, E&gt;</code> is <code>true</code>.
</p>
<p>-8- <i>Effects</i>: Equivalent to:</p>
<blockquote>
<pre><code>if (has_value())
  return invoke(std::forward&lt;F&gt;(f), std::move(<del>value()</del><ins>**this</ins>));
else
  return U(unexpect, std::move(error()));
</code></pre>
</blockquote>

<pre><code>
template&lt;class F&gt; constexpr auto or_else(F&amp;&amp; f) &amp;;
template&lt;class F&gt; constexpr auto or_else(F&amp;&amp; f) const &amp;;
</code></pre>
<p>-9- Let <code>G</code> be
<code>remove_cvref_t&lt;invoke_result_t&lt;F, decltype(error())&gt;&gt;</code>.
</p>
<p>-10- <i>Constraints</i>:
<code>is_constructible_v&lt;T, decltype(<del>value()</del><ins>**this</ins>)&gt;</code>
is <code>true</code>.
</p>
<p>-11- <i>Mandates</i>:
<code>G</code> is a specialization of <code>expected</code> and
<code>is_same_v&lt;G::value_type, T&gt;</code> is <code>true</code>.
</p>
<p>-12- <i>Effects</i>: Equivalent to:</p>
<blockquote>
<pre><code>if (has_value())
  return G(in_place, <del>value()</del><ins>**this</ins>);
else
  return invoke(std::forward&lt;F&gt;(f), error());
</code></pre>
</blockquote>

<pre><code>
template&lt;class F&gt; constexpr auto or_else(F&amp;&amp; f) &amp;&amp;;
template&lt;class F&gt; constexpr auto or_else(F&amp;&amp; f) const &amp;&amp;;
</code></pre>
<p>-13- Let <code>G</code> be
<code>remove_cvref_t&lt;invoke_result_t&lt;F, decltype(std::move(error()))&gt;&gt;</code>.
</p>
<p>-14- <i>Constraints</i>:
<code>is_constructible_v&lt;T, decltype(std::move(<del>value()</del><ins>**this</ins>))&gt;</code>
is <code>true</code>.
</p>
<p>-15- <i>Mandates</i>:
<code>G</code> is a specialization of <code>expected</code> and
<code>is_same_v&lt;G::value_type, T&gt;</code> is <code>true</code>.
</p>
<p>-16- <i>Effects</i>: Equivalent to:</p>
<blockquote>
<pre><code>if (has_value())
  return G(in_place, std::move(<del>value()</del><ins>**this</ins>));
else
  return invoke(std::forward&lt;F&gt;(f), std::move(error()));
</code></pre>
</blockquote>

<pre><code>
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) &amp;;
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) const &amp;;
</code></pre>
<p>-17- Let <code>U</code> be
<code>remove_cv_t&lt;invoke_result_t&lt;F, decltype(<del>value()</del><ins>**this</ins>)&gt;&gt;</code>.
</p>
<p>-18- <i>Constraints</i>:
<code>is_constructible_v&lt;E, decltype(error())&gt;</code>
is <code>true</code>.
</p>
<p>-19- <i>Mandates</i>:
<code>U</code> is a valid value type for <code>expected</code>.
If <code>is_void_v&lt;U&gt;</code> is <code>false</code>, the declaration
<pre><code>  U u(invoke(std::forward&lt;F&gt;(f), <del>value()</del><ins>**this</ins>));</code></pre>
is well-formed.

</p>
<p>-20- <i>Effects</i>:
<ol style="list-style-type: none">
<li> (20.1) &mdash;
If <code>has_value()</code> is <code>false</code>,
returns <code>expected&lt;U, E&gt;(unexpect, error())</code>.
</li>
<li> (20.2) &mdash;
Otherwise, if <code>is_void_v&lt;U&gt;</code> is <code>false</code>,
returns an <code>expected&lt;U, E&gt;</code> object whose
<code><i>has_val</i></code> member is <code>true</code> and
<code><i>val</i></code> member is direct-non-list-initialized with
<code>invoke(std::forward&lt;F&gt;(f), <del>value()</del><ins>**this</ins>)</code>.
</li>
<li> (20.3) &mdash;
Otherwise, evaluates
<code>invoke(std::forward&lt;F&gt;(f), <del>value()</del><ins>**this</ins>)</code>
and then returns <code>expected&lt;U, E&gt;()</code>.
</li>
</ol>
</p>

<pre><code>
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) &amp;&amp;;
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) const &amp;&amp;;
</code></pre>
<p>-21- Let <code>U</code> be
<code>remove_cv_t&lt;invoke_result_t&lt;F, decltype(std::move(<del>value()</del><ins>**this</ins>))&gt;&gt;</code>.
</p>
<p>-22- <i>Constraints</i>:
<code>is_constructible_v&lt;E, decltype(std::move(error()))&gt;</code>
is <code>true</code>.
</p>
<p>-23- <i>Mandates</i>:
<code>U</code> is a valid value type for <code>expected</code>.
If <code>is_void_v&lt;U&gt;</code> is <code>false</code>, the declaration
<pre><code>  U u(invoke(std::forward&lt;F&gt;(f), std::move(<del>value()</del><ins>**this</ins>)));</code></pre>
is well-formed <del>for some invented variable <code>u</code></del>.
<blockquote class="note">
<p>
[<i>Drafting Note:</i>
The removal of "for some invented variable u" in paragraph 23
is a drive-by fix for consistency with paragraphs 19, 27 and 31.]
</p>
</blockquote>
</p>
<p>-24- <i>Effects</i>:
<ol style="list-style-type: none">
<li> (24.1) &mdash;
If <code>has_value()</code> is <code>false</code>,
returns <code>expected&lt;U, E&gt;(unexpect, error())</code>.
</li>
<li> (24.2) &mdash;
Otherwise, if <code>is_void_v&lt;U&gt;</code> is <code>false</code>,
returns an <code>expected&lt;U, E&gt;</code> object whose
<code><i>has_val</i></code> member is <code>true</code> and
<code><i>val</i></code> member is direct-non-list-initialized with
<code>invoke(std::forward&lt;F&gt;(f), std::move(<del>value()</del><ins>**this</ins>))</code>.
</li>
<li> (24.3) &mdash;
Otherwise, evaluates
<code>invoke(std::forward&lt;F&gt;(f), std::move(<del>value()</del><ins>**this</ins>))</code>
and then returns <code>expected&lt;U, E&gt;()</code>.
</li>
</ol>
</p>

<pre><code>
template&lt;class F&gt; constexpr auto transform_error(F&amp;&amp; f) &amp;;
template&lt;class F&gt; constexpr auto transform_error(F&amp;&amp; f) const &amp;;
</code></pre>
<p>-25- Let <code>G</code> be
<code>remove_cv_t&lt;invoke_result_t&lt;F, decltype(error())&gt;&gt;</code>.
</p>
<p>-26- <i>Constraints</i>:
<code>is_constructible_v&lt;T, decltype(<del>value()</del><ins>**this</ins>)&gt;</code>
is <code>true</code>.
</p>
<p>-27- <i>Mandates</i>:
<code>G</code> is a valie template argument for <code>unexpected</code>
( [unexpected.un.general])
and the declaration
<pre><code>  G g(invoke(std::forward&lt;F&gt;(f), error()));</code></pre>
is well-formed.
</p>
<p>-28- <i>Returns</i>:
If <code>has_value()</code> is <code>true</code>,
<code>expected&lt;T, G&gt;(in_place, <del>value()</del><ins>**this</ins>);</code>;
otherwise, an <code>expected&lt;T, G&gt;</code> object whose
<code><i>has_val</i></code> member is <code>false</code>
and <code><i>unex</i></code> member is direct-non-list-initialized with
<code>invoke(std::forward&lt;F&gt;(f), error())</code>.
</p>

<pre><code>
template&lt;class F&gt; constexpr auto transform_error(F&amp;&amp; f) &amp;&amp;;
template&lt;class F&gt; constexpr auto transform_error(F&amp;&amp; f) const &amp;&amp;;
</code></pre>
<p>-29- Let <code>G</code> be
<code>remove_cv_t&lt;invoke_result_t&lt;F, decltype(std::move(error()))&gt;&gt;</code>.
</p>
<p>-30- <i>Constraints</i>:
<code>is_constructible_v&lt;T, decltype(std::move(<del>value()</del><ins>**this</ins>))&gt;</code>
is <code>true</code>.
</p>
<p>-31- <i>Mandates</i>:
<code>G</code> is a valie template argument for <code>unexpected</code>
( [unexpected.un.general])
and the declaration
<pre><code>  G g(invoke(std::forward&lt;F&gt;(f), std::move(error())));</code></pre>
is well-formed.
</p>
<p>-32- <i>Returns</i>:
If <code>has_value()</code> is <code>true</code>,
<code>expected&lt;T, G&gt;(in_place, std::move(<del>value()</del><ins>**this</ins>));</code>;
otherwise, an <code>expected&lt;T, G&gt;</code> object whose
<code><i>has_val</i></code> member is <code>false</code>
and <code><i>unex</i></code> member is direct-non-list-initialized with
<code>invoke(std::forward&lt;F&gt;(f), std::move(error()))</code>.
</p>

</blockquote>
</li>
</ol>






<hr>
<h3><a name="3940" href="#3940">3940</a><sup><a href="https://cplusplus.github.io/LWG/issue3940">(i)</a></sup>. <tt>std::expected&lt;void, E&gt;::value()</tt> also needs <tt>E</tt> to be copy constructible</h3>
<p><b>Section:</b> 22.8.7.6 <a href="https://wg21.link/expected.void.obs">[expected.void.obs]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-05-26 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="lwg-defects.html#3843">3843</a> added <i>Mandates:</i> to <tt>std::expected::value</tt>, but the similar handling is 
missing for <tt>expected&lt;<i>cv</i> void, E&gt;</tt>.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-3940"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950">N4950</a>.
</p>

<ol>
<li>
<p>Modify 22.8.7.6 <a href="https://wg21.link/expected.void.obs">[expected.void.obs]</a> as indicated:</p>

<blockquote>
<pre>
constexpr void value() const &amp;;
</pre>
<blockquote>
<p>
<ins>-?- <i>Mandates:</i> <tt>is_copy_constructible_v&lt;E&gt;</tt> is <tt>true</tt>.</ins>
<p/>
-3- <i>Throws:</i> <tt>bad_expected_access(error())</tt> if <tt>has_value()</tt> is <tt>false</tt>.
</p>
</blockquote>
<pre>
constexpr void value() &amp;&amp;;
</pre>
<blockquote>
<p>
<ins>-?- <i>Mandates:</i> <tt>is_copy_constructible_v&lt;E&gt;</tt> is <tt>true</tt> and 
<tt>is_move_constructible_v&lt;E&gt;</tt> is <tt>true</tt>.</ins>
<p/>
-4- <i>Throws:</i> <tt>bad_expected_access(std::move(error()))</tt> if <tt>has_value()</tt> is <tt>false</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





</body>
</html>
