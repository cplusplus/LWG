<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<p>Revised 2024-03-15 at 14:33:42 UTC
</p><h2>Tentative Issues</h2>
<hr>
<h3 id="2457"><a href="#2457">2457</a><sup><a href="https://cplusplus.github.io/LWG/issue2457">(i)</a></sup>. <code>std::begin()</code> and <code>std::end()</code> do not support multi-dimensional arrays correctly</h3>
<p><b>Section:</b> 25.7 <a href="https://wg21.link/iterator.range">[iterator.range]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Janez &#x17d;emva <b>Opened:</b> 2014-11-16 <b>Last modified:</b> 2023-04-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.range">active issues</a> in [iterator.range].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in [iterator.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following code:
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;

int main() 
{
  int a[2][3][4] = { { { 1,  2,  3,  4}, { 5,  6,  7,  8}, { 9, 10, 11, 12} },
                     { {13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24} } };
  int b[2][3][4];

  assert(std::distance(std::begin(a), std::end(a)) == 2 * 3 * 4);
  std::copy(std::begin(a), std::end(a), std::begin(b));
  std::copy(std::begin(b), std::end(b), std::ostream_iterator&lt;int&gt;(std::cout, ","));
}
</pre></blockquote>
<p>
does not compile. 
<p/>
A possible way to remedy this would be to add the following overloads of
<code>begin</code>, <code>end</code>, <code>rbegin</code>, and <code>rend</code> to 25.7 <a href="https://wg21.link/iterator.range">[iterator.range]</a>, 
relying on recursive evaluation:
</p>
<blockquote><pre>
namespace std {

  template &lt;typename T, size_t M, size_t N&gt;
  constexpr remove_all_extents_t&lt;T&gt;*
  begin(T (&amp;array)[M][N])
  {
    return begin(*array);
  }
  
  template &lt;typename T, size_t M, size_t N&gt;
  constexpr remove_all_extents_t&lt;T&gt;*
  end(T (&amp;array)[M][N])
  {
    return end(array[M - 1]);
  }

  template &lt;typename T, size_t M, size_t N&gt;
  reverse_iterator&lt;remove_all_extents_t&lt;T&gt;*&gt;
  rbegin(T (&amp;array)[M][N])
  {
    return decltype(rbegin(array))(end(array[M - 1]));
  }
  
  template &lt;typename T, size_t M, size_t N&gt;
  reverse_iterator&lt;remove_all_extents_t&lt;T&gt;*&gt;
  rend(T (&amp;array)[M][N])
  {
    return decltype(rend(array))(begin(*array));
  }

}
</pre></blockquote>

<p><i>[2023-04-06; LWG reflector poll in November 2021]</i></p>

<p>
Changed to Tentatively NAD after 12 votes in favour.
Use <code>views::join</code> or <code>mdspan</code> instead.
</p>



<p id="res-2457"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3635"><a href="#3635">3635</a><sup><a href="https://cplusplus.github.io/LWG/issue3635">(i)</a></sup>. Add <code>__cpp_lib_deduction_guides</code> to feature test macros</h3>
<p><b>Section:</b> 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Konstantin Varlamov <b>Opened:</b> 2021-11-09 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#version.syn">active issues</a> in [version.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#version.syn">issues</a> in [version.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P0433R2" title=" Toward a resolution of US7 and US14: Integrating template deduction for class templates into the standard library">P0433R2</a>, the proposal for adding deduction guides to the standard library, contained a 
recommendation to use <code>__cpp_lib_deduction_guides</code> as a feature test macro. However, it appears that this feature test macro has been accidentally omitted from the Standard when the paper was applied and probably needs to be added back.
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_coroutine          201902L  <i>// also in &lt;coroutine&gt;</i>
<ins>#define __cpp_lib_deduction_guides   201703L
  <i>// also in &lt;deque&gt;, &lt;forward_list&gt;, &lt;list&gt;, &lt;map&gt;, &lt;queue&gt;, &lt;set&gt;, &lt;stack&gt;,
  // &lt;unordered_map&gt;, &lt;unordered_set&gt;, &lt;vector&gt;</i></ins>
#define __cpp_lib_destroying_delete  201806L  <i>// also in &lt;new&gt;</i>
[&hellip;]
</pre>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2021-11-16; Konstantin Varlamov comments and improves wording]</i></p>

<p>
One potential topic of discussion is whether the new feature test macro needs to be defined in every library 
header that contains an explicit deduction guide. While this would be consistent with the current approach, 
no other macro is associated with such a large set of headers (20 headers in total, whereas the current 
record-holder is <code>__cpp_lib_nonmember_container_access</code> with 12 headers). For this reason, it should 
be considered whether perhaps the new macro should only be defined in <code>&lt;version&gt;</code> (which would, 
however, make it an outlier). The proposed wording currently contains an exhaustive list (note that the 
deduction guides for <code>&lt;mutex&gt;</code> were removed by LWG <a href="lwg-defects.html#2981" title="Remove redundant deduction guides from standard library">2981</a>).
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Several votes for NAD as it's too late to be useful, and code which needs
to be portable to pre-CTAD compilers can just not use CTAD.
</p>

<p><i>[2023-04-21; Reflector poll for 'Tentatively NAD']</i></p>

<p><i>[
"We keep changing the deduction guides, and different libraries might be
conformant in some headers and not others. The status cannot be represented
by a single number."
]</i></p>




<p id="res-3635"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_coroutine          201902L  <i>// also in &lt;coroutine&gt;</i>
<ins>#define __cpp_lib_deduction_guides   201703L
  <i>// also in &lt;array&gt;, &lt;deque&gt;, &lt;forward_list&gt;, &lt;functional&gt;, &lt;list&gt;, &lt;map&gt;,
  // &lt;memory&gt;, &lt;optional&gt;, &lt;queue&gt;, &lt;regex&gt;, &lt;scoped_allocator&gt;, &lt;set&gt;, &lt;stack&gt;,
  // &lt;string&gt;, &lt;tuple&gt;, &lt;unordered_map&gt;, &lt;unordered_set&gt;, &lt;utility&gt;, &lt;valarray&gt;,
  // &lt;vector&gt;</i></ins>
#define __cpp_lib_destroying_delete  201806L  <i>// also in &lt;new&gt;</i>
[&hellip;]
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3714"><a href="#3714">3714</a><sup><a href="https://cplusplus.github.io/LWG/issue3714">(i)</a></sup>. Non-single-argument constructors for range adaptors should not be <code>explicit</code></h3>
<p><b>Section:</b> 26.7.25.2 <a href="https://wg21.link/range.zip.transform.view">[range.zip.transform.view]</a>, 26.7.27.2 <a href="https://wg21.link/range.adjacent.transform.view">[range.adjacent.transform.view]</a>, 26.7.28.2 <a href="https://wg21.link/range.chunk.view.input">[range.chunk.view.input]</a>, 26.7.28.6 <a href="https://wg21.link/range.chunk.view.fwd">[range.chunk.view.fwd]</a>, 26.7.29.2 <a href="https://wg21.link/range.slide.view">[range.slide.view]</a>, 26.7.30.2 <a href="https://wg21.link/range.chunk.by.view">[range.chunk.by.view]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-06-10 <b>Last modified:</b> 2024-01-29</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
All C++20 range adaptors' non-single-argument constructors are not declared as <code>explicit</code>, which makes 
the following initialization well-formed:
</p>
<blockquote><pre>
std::vector v{42};
std::ranges::take_view r1 = {v, 1};
std::ranges::filter_view r2 = {v, [](int) { return true; }};
</pre></blockquote>
<p>
However, the non-single-argument constructors of C++23 range adaptors, except for <code>join_with_view</code>, 
are all <code>explicit</code>, which makes us no longer able to
</p>
<blockquote><pre>
std::ranges::chunk_view r1 = {v, 1}; // <span style="color:red;font-weight:bolder">ill-formed</span>
std::ranges::chunk_by_view r2 = {v, [](int, int) { return true; }}; // <span style="color:red;font-weight:bolder">ill-formed</span>
</pre></blockquote>
<p>
This seems unnecessary since I don't see the observable benefit of preventing this. In the standard, 
non-single-argument constructors are rarely specified as <code>explicit</code> unless it is really undesirable, 
I think the above initialization is what the user expects since it's clearly intentional, and I don't see 
any good reason to reject it from C++23.
</p>
<p><i>[2022-06-11; Daniel comments]</i></p>

<p>
Another possible candidate could be 26.7.11.3 <a href="https://wg21.link/range.take.while.sentinel">[range.take.while.sentinel]</a>'s
</p>
<blockquote><pre>
constexpr explicit <i>sentinel</i>(sentinel_t&lt;<i>Base</i>&gt; end, const Pred* pred);
</pre></blockquote>

<p><i>[2022-06-21; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll. Send to LEWG.
</p>

<p><i>[2023-01-24; LEWG in Kona]</i></p>

<p>Use alternative approach in <a href="https://wg21.link/P2711" title=" Making multi-param constructors of views explicit">P2711</a> instead.</p>



<p id="res-3714"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 26.7.25.2 <a href="https://wg21.link/range.zip.transform.view">[range.zip.transform.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;copy_constructible F, input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
              regular_invocable&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt; &amp;&amp;
              <i>can-reference</i>&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt;&gt;
  class zip_transform_view : public view_interface&lt;zip_transform_view&lt;F, Views...&gt;&gt; {
    <i>copyable-box</i>&lt;F&gt; <i>fun_</i>;                   <i>// exposition only</i>
    zip_view&lt;Views...&gt; <i>zip_</i>;                <i>// exposition only</i>
    [&hellip;]
  public:
    zip_transform_view() = default;

    constexpr <del>explicit</del> zip_transform_view(F fun, Views... views);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> zip_transform_view(F fun, Views... views);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <code><i>fun_</i></code> with <code>std::move(fun)</code> and <code><i>zip_</i></code> 
with <code>std::move(views)...</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.27.2 <a href="https://wg21.link/range.adjacent.transform.view">[range.adjacent.transform.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, copy_constructible F, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, <i>REPEAT</i>(range_reference_t&lt;V&gt;, N)...&gt; &amp;&amp;
             <i>can-reference</i>&lt;invoke_result_t&lt;F&amp;, <i>REPEAT</i>(range_reference_t&lt;V&gt;, N)...&gt;&gt;
  class adjacent_transform_view : public view_interface&lt;adjacent_transform_view&lt;V, F, N&gt;&gt; {
    <i>copyable-box</i>&lt;F&gt; <i>fun_</i>;                       <i>// exposition only</i>
    adjacent_view&lt;V, N&gt; <i>inner_</i>;                 <i>// exposition only</i>
    [&hellip;]
  public:
    adjacent_transform_view() = default;
    constexpr <del>explicit</del> adjacent_transform_view(V base, F fun);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> adjacent_transform_view(V base, F fun);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <code><i>fun_</i></code> with <code>std::move(fun)</code> and 
<code><i>inner_</i></code> with <code>std::move(base)</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.28.2 <a href="https://wg21.link/range.chunk.view.input">[range.chunk.view.input]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class chunk_view : public view_interface&lt;chunk_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                                        <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;                         <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Preconditions:</i> <code>n &gt; 0</code> is <code>true</code>.
<p/>
-2- <i>Effects</i>: Initializes <code><i>base_</i></code> with <code>std::move(base)</code> and 
<code><i>n_</i></code> with <code>n</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.28.6 <a href="https://wg21.link/range.chunk.view.fwd">[range.chunk.view.fwd]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;view V&gt;
    requires forward_range&lt;V&gt;
  class chunk_view&lt;V&gt; : public view_interface&lt;chunk_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                      <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;       <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Preconditions:</i> <code>n &gt; 0</code> is <code>true</code>.
<p/>
-2- <i>Effects</i>: Initializes <code><i>base_</i></code> with <code>std::move(base)</code> and 
<code><i>n_</i></code> with <code>n</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.29.2 <a href="https://wg21.link/range.slide.view">[range.slide.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;forward_range V&gt;
    requires view&lt;V&gt;
  class slide_view : public view_interface&lt;slide_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                      <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;       <i>// exposition only</i>
    [&hellip;]
  public:
    slide_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> slide_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> slide_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <code><i>base_</i></code> with <code>std::move(base)</code> and 
<code><i>n_</i></code> with <code>n</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.30.2 <a href="https://wg21.link/range.chunk.by.view">[range.chunk.by.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, indirect_binary_predicate&lt;iterator_t&lt;V&gt;, iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class chunk_by_view : public view_interface&lt;chunk_by_view&lt;V, Pred&gt;&gt; {
    V <i>base_</i> = V();                                <i>// exposition only</i>
    <i>copyable-box</i>&lt;Pred&gt; <i>pred_</i> = Pred();            <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_by_view() requires default_initializable&lt;V&gt; &amp;&amp; default_initializable&lt;Pred&gt; = default;
    constexpr <del>explicit</del> chunk_by_view(V base, Pred pred);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_by_view(V base, Pred pred);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <code><i>base_</i></code> with <code>std::move(base)</code> and 
<code><i>pred_</i></code> with <code>std::move(pred)</code>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3901"><a href="#3901">3901</a><sup><a href="https://cplusplus.github.io/LWG/issue3901">(i)</a></sup>. Is uses-allocator construction of a <i>cv</i>-qualified object type still well-formed after LWG 3870?</h3>
<p><b>Section:</b> 20.2.8 <a href="https://wg21.link/allocator.uses">[allocator.uses]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-05 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="lwg-defects.html#3870" title="Remove voidify">3870</a> made <code>std::construct_at</code> unable to create an object of a <i>cv</i>-qualified type, 
which affects <code>std::uninitialized_construct_using_allocator</code>. However, uses-allocator construction is 
currently not required to be equivalent to some call to <code>std::uninitialized_construct_using_allocator</code>, 
which possibly implies that uses-allocator construction of a <i>cv</i>-qualified type may still be required to be 
well-formed.
<p/>
Should we make such construction ill-formed?
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>Set status to Tentatively NAD.</p>
<p>Not all uses-allocator construction is done using <code>construct_at</code>.
<code>std::tuple&lt;const T&gt;(allocator_arg, alloc)</code> does
uses-allocator construction of a const type, so we can't make it ill-formed.
</p>



<p id="res-3901"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3908"><a href="#3908">3908</a><sup><a href="https://cplusplus.github.io/LWG/issue3908">(i)</a></sup>. <code>enumerate_view::<i>iterator</i></code> constructor is explicit</h3>
<p><b>Section:</b> 26.7.23.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2023-03-23 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.enumerate.iterator">issues</a> in [range.enumerate.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>enumerate_view::<i>iterator</i></code> has this constructor:
</p>
<blockquote>
<pre><code>    constexpr explicit
      <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);  <i>// exposition only</i>
</code></pre>
</blockquote>

<p>
In <a href="https://wg21.link/P2164R9" title=" views::enumerate">P2164R9</a> the detailed description of the function showed a
default argument for the second parameter, which would justify it being
explicit. However, that default argument was not present in the class synopsis
and was removed from the detailed description when applying the paper to the
draft.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after four votes in favour during reflector poll.
</p>



<p id="res-3908"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>
<ol>
<li>
<p>
Modify the class synopsis in 26.7.23.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a>
as shown:
</p>
<blockquote><pre><code>
    constexpr <del>explicit</del>
      <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);  <i>// exposition only</i>
</code></pre></blockquote>
</li>

<li>
<p>
Modify the detailed description in 26.7.23.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a>
as shown:
</p>
<blockquote>
<pre><code>  constexpr <del>explicit</del> <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);
</code></pre>
<p>-2-
<i>Effects</i>: Initializes <code><i>current_</i></code>
with <code>std::move(current)</code> and <code><i>pos_</i></code> with
<code>pos</code>.
</p>
</blockquote>
</li>

</ol>






<hr>
<h3 id="3909"><a href="#3909">3909</a><sup><a href="https://cplusplus.github.io/LWG/issue3909">(i)</a></sup>. Issues about <code>viewable_range</code></h3>
<p><b>Section:</b> 99 [ranges.refinements], 26.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-27 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After LWG <a href="lwg-defects.html#3724" title="decay-copy should be constrained">3724</a>, <code>views::all</code> is well-constrained for view types,
and the constraints are stronger than <code>viewable_range</code>.
The difference is that given an expression such that <code>decltype</code> gives <code>R</code>,
when <code>decay_t&lt;R&gt;</code> is a view type and the implicit conversion of <code>R</code>
to <code>decay_t&lt;R&gt;</code> is forbidden, <code>views::all</code> rejects the expression,
but <code>viewable_range</code> may accept <code>R</code>.
So I think we should remove the additional constraints on <code>views::all_t</code>.
</p>
<p>
While <code>viewable_range</code> is probably not introducing any additional constraint within the standard library,
I think it is still useful to express the constraints on <code>views::all</code>,
so it should be slightly adjusted to match <code>views::all</code>.
</p>
<p>
Furthermore, <code>viewable_range</code> is currently used in 26.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a>,
but given <a href="https://wg21.link/P2378R3">P2378R3</a> relaxed the requirements for range adaptor closure objects,
I think we should also apply similar relaxation for range adaptor objects.
This should have no impact on standard range adaptor objects.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after three votes in favour during reflector poll.
</p>
<p>
"First change is pointless. Second change is a duplicate of <a href="lwg-active.html#3896" title="The definition of viewable_range is not quite right">3896</a>.
Range adaptors return a view over their first argument, so they need to
require it's a <code>viewable_range</code>."
</p>



<p id="res-3909"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<ol>
<li>
<p>
Change the definition of <code>views::all_t</code> in 26.2 <a href="https://wg21.link/ranges.syn">[ranges.syn]</a> as indicated:
</p>
<blockquote><pre><code>
   template&lt;<del>viewable_range</del><ins>class</ins> R&gt;
      using all_t = decltype(all(declval&lt;R&gt;()));          // freestanding
</code></pre>
</blockquote>
</li>
<li>
<p>
Change the definition of <code>viewable_range</code> in 26.4.5 <a href="https://wg21.link/range.refinements">[range.refinements]</a> as indicated:
</p>
<blockquote>
<p>-6-
The <code>viewable_range</code> concept specifies the requirements of a <code>range</code> type
that can be converted to a view safely.
</p>
<pre><code>
template&lt;class T&gt;
  concept viewable_range =
    range&lt;T&gt; &amp;&amp;
    ((view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp; <del>constructible_from&lt;remove_cvref_t&lt;T&gt;, T&gt;</del> <ins>convertible_to&lt;T, remove_cvref_t&lt;T&gt;&gt;</ins>) ||
     (!view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp;
      (is_lvalue_reference_v&lt;T&gt; || (movable&lt;remove_reference_t&lt;T&gt;&gt; &amp;&amp; !<i>is-initializer-list</i>&lt;T&gt;))));
</code></pre>
</blockquote>
</li>
<li>
<p>
Change 26.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> as indicated:
</p>
<blockquote>
<p>-6-
A <i>range adaptor object</i> is a customization point object (16.3.3.3.5 <a href="https://wg21.link/customization.point.object">[customization.point.object]</a>)
that accepts a <code><del>viewable_range</del><ins>range</ins></code> as its first argument
and returns a view.
</p>
<p>
[&hellip;]
</p>
<p>-8-
If a range adaptor object <code>adaptor</code> accepts more than one argument,
then let <code>range</code> be an expression such that <code>decltype((range))</code>
models <code><del>viewable_range</del><ins>range</ins></code>,
let <code>args...</code> be arguments such that <code>adaptor(range, args...)</code>
is a well-formed expression as specified in the rest of subclause 26.7 <a href="https://wg21.link/range.adaptors">[range.adaptors]</a>,
and let <code>BoundArgs</code> be a pack that denotes <code>decay_t&lt;decltype((args))&gt;...</code>.
The expression <code>adaptor(args...)</code> produces a range adaptor closure object
<code>f</code> that is a perfect forwarding call wrapper (22.10.4 <a href="https://wg21.link/func.require">[func.require]</a>)
with the following properties: [...]
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3930"><a href="#3930">3930</a><sup><a href="https://cplusplus.github.io/LWG/issue3930">(i)</a></sup>. Simplify type trait wording</h3>
<p><b>Section:</b> 21 <a href="https://wg21.link/meta">[meta]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2023-05-01 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are many traits that have a requirement that they are instantiated only if
"<code>T</code> shall be a complete type, <i>cv</i> <code>void</code>, or an array of unknown bound."
<p/>
Breaking down what this means, by supporting <i>cv</i>-<code>void</code> and arrays of unknown
bound (almost) the only remaining type-category is incomplete class types.
<p/>
The remaining edge case is incomplete enumerations, but they are required to
have a known fixed-base, so act as complete types, they can be copied,
assigned, etc., without knowing the names of their enumerators.
<p/>
Hence, I suggest clearer wording would be:
"<code>T</code> shall not be an incomplete class type."
<p/>
This is easier to understand, as we do not need to mentally enumerate every
type against a list to check it qualifies; it is a simpler test for the library to
check if we were to mandate these restrictions.
<p/>
There are a very small number of traits with subtly different wording, where
incomplete unions are supported, or arrays of unknown bound are not a
concern due to invoking <code>remove_all_extents</code> first. The bulk of the changes
can be made to traits with only the precise wording above though, and then
we can review whether any of the remaining restrictions deserve a wording
update of their own.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after four votes in favour during reflector poll,
including a request to withdraw the issue from the submitter.
</p>
<p>
Incomplete enumeration types are found within the <i>enum-specifier</i>
of an enum without a fixed underlying type:
<pre><code>
enum E {
    A = sizeof(E) // error, E is incomplete at this point
};
</code></pre>
and we definitely can't provide an underlying type for this case.
</p>



<p id="res-3930"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<ol>
<li>
<p>
Throughout 21 <a href="https://wg21.link/meta">[meta]</a> replace all occurrences of
</p>
<blockquote><p>
<code>T</code> shall be a complete type, <i>cv</i> <code>void</code>, or an array of unknown bound.
</p></blockquote>
<p>
by
</p>
<blockquote><p>
<code>T</code> shall not be an incomplete class type.
</p></blockquote>

</li>

</ol>





<hr>
<h3 id="3936"><a href="#3936">3936</a><sup><a href="https://cplusplus.github.io/LWG/issue3936">(i)</a></sup>. Are implementations allowed to deprecate components not in [depr]?</h3>
<p><b>Section:</b> D <a href="https://wg21.link/depr">[depr]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-05-22 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
D.1 <a href="https://wg21.link/depr.general">[depr.general]</a>/2 allows implementations to apply the
<code>deprecated</code> attribute to deprecated components.
However, there doesn't seem to be any wording disallowing applying the
<code>deprecated</code> attribute to non-deprecated components.
</p>
<p>
Is it intended to allow implementations to deprecate every library component
as they want? If so, should we turn the allowance into "<i>Recommended practice</i>" and move it to somewhere in 16.4 <a href="https://wg21.link/requirements">[requirements]</a>?
</p>
<p>
There doesn't seem to be wording which formally recommends applying
<code>deprecated</code> attribute to deprecated components either.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after nine votes in favour during reflector poll.
Let implementations decide when to apply these attributes.
</p>



<p id="res-3936"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i>
There are two mutually exclusive proposed resolutions,
depending on whether it is allowed to deprecate components not in
D <a href="https://wg21.link/depr">[depr]</a>.
</p>
</blockquote>

<p><strong>Option A:</strong></p>

<ol>
<li>
<p>Insert a paragraph at the end of 16.4.2.2 <a href="https://wg21.link/contents">[contents]</a>:</p>

<blockquote>
<p>
<ins>
-?- <i>Recommended practice</i>:
Implementations should not apply the <code>deprecated</code> attribute
(9.12.5 <a href="https://wg21.link/dcl.attr.deprecated">[dcl.attr.deprecated]</a>) to library entities that are not
specified in D <a href="https://wg21.link/depr">[depr]</a>.
Implementations should apply the <code>deprecated</code> attribute to
library entities specified in D <a href="https://wg21.link/depr">[depr]</a> whenever possible.
</ins>
</p>
</blockquote>
</li>
</ol>

<p><strong>Option B:</strong></p>

<ol>
<li>
<p>Insert two paragraphs at the end of 16.4.2.2 <a href="https://wg21.link/contents">[contents]</a>:</p>

<blockquote>
<p>
<ins>
-?- Implementations shall not apply the <code>deprecated</code> attribute
(9.12.5 <a href="https://wg21.link/dcl.attr.deprecated">[dcl.attr.deprecated]</a>) to library entities that are not
specified in D <a href="https://wg21.link/depr">[depr]</a>.
</ins>
</p>
<p>
<ins>-?- <i>Recommended practice</i>:
Implementations should apply the <code>deprecated</code> attribute to
library entities specified in D <a href="https://wg21.link/depr">[depr]</a> whenever possible.
</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3958"><a href="#3958">3958</a><sup><a href="https://cplusplus.github.io/LWG/issue3958">(i)</a></sup>. <code>ranges::to</code> should prioritize the "<code>reserve</code>" branch</h3>
<p><b>Section:</b> 26.5.7.2 <a href="https://wg21.link/range.utility.conv.to">[range.utility.conv.to]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-07-17 <b>Last modified:</b> 2024-01-29</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.utility.conv.to">active issues</a> in [range.utility.conv.to].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.utility.conv.to">issues</a> in [range.utility.conv.to].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When the constructed range object has no range version constructor, <code>ranges::to</code> falls into a 
branch designed specifically for C++17-compliant containers, which calls the legacy constructor that 
accepts an iterator pair with <code>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</code>.    
<p/>
However, this kind of initialization may bring some performance issues, because we split the original 
range into pairs of iterators, which may lose information contained in the original range, for example:
</p>
<blockquote><pre>
#include &lt;boost/container/vector.hpp&gt;
#include &lt;sstream&gt;
#include &lt;ranges&gt;

int main() {
  std::istringstream ints("1 2 3 4 5");
  std::ranges::subrange s(std::istream_iterator&lt;int&gt;(ints),
                          std::istream_iterator&lt;int&gt;(),
                          5);
  auto r = std::ranges::to&lt;boost::container::vector&gt;(s); // <span style="color:red;font-weight:bolder">discard size info</span>
}
</pre></blockquote>
<p>
Above, <code>subrange</code> saves the size information of the stream, but <code>ranges::to</code> only extracts 
its iterator pair to create the object, so that the original size information is discarded, resulting in 
unnecessary allocations.
<p/>
I believe we should prefer to use the "<code>reserve</code>" branch here because it is really designed for this situation.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after reflector poll.
"This optimizes exotic cases at the expense of realistic cases."
</p>



<p id="res-3958"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>

<li><p>Modify 26.5.7.2 <a href="https://wg21.link/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
  constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: <code>C</code> is a cv-unqualified class type.
</p>
<p>
-2- <i>Returns</i>: An object of type <code>C</code> constructed from the elements of <code>r</code> in the following manner:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <code>C</code> does not satisfy <code>input_range</code> or <code>convertible_to&lt;range_reference_t&lt;R&gt;, 
range_value_t&lt;C&gt;&gt;</code> is <code>true</code>:</p>
<ol style="list-style-type: none">
<li><p>(2.1.1) &mdash; If <code>constructible_from&lt;C, R, Args...&gt;</code> is <code>true</code>:</p>
<blockquote><code>C(std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</code></blockquote></li>
<li><p>(2.1.2) &mdash; Otherwise, if <code>constructible_from&lt;C, from_range_t, R, Args...&gt;</code> is <code>true</code>:</p>
<blockquote><code>C(from_range, std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</code></blockquote></li>
<li><p><del>(2.1.3) &mdash; Otherwise, if</del></p>
<ol style="list-style-type: none">
<li><p><del>(2.1.3.1) &mdash; <code>common_range&lt;R&gt;</code> is <code>true</code>,</del></p></li>
<li><p><del>(2.1.3.2) &mdash; the <i>qualified-id</i>  
<code>iterator_traits&lt;iterator_t&lt;R&gt;&gt;::iterator_category</code> is valid and denotes a type that models 
<code>derived_from&lt;input_iterator_tag&gt;</code>, and</del></p></li>
<li><p><del>(2.1.3.3) &mdash; <code>constructible_from&lt;C, iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, Args...&gt;</code> 
is <code>true</code>:</del></p>
<blockquote><pre><del>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</del></pre></blockquote></li>
</ol>
</li>
<li><p>(2.1.4) &mdash; Otherwise, if</p>
<ol style="list-style-type: none">
<li><p>(2.1.4.1) &mdash; <code>constructible_from&lt;C, Args...&gt;</code> is <code>true</code>, and</p></li>
<li><p>(2.1.4.2) &mdash; <code><i>container-insertable</i>&lt;C, range_reference_t&lt;R&gt;&gt;</code> is <code>true</code>:</p>
<blockquote><pre>
C c(std::forward&lt;Args&gt;(args)...);
if constexpr (sized_range&lt;R&gt; &amp;&amp; <i>reservable-container</i>&lt;C&gt;)
  c.reserve(static_cast&lt;range_size_t&lt;C&gt;&gt;(ranges::size(r)));
ranges::copy(r, <i>container-inserter</i>&lt;range_reference_t&lt;R&gt;&gt;(c));
</pre></blockquote></li>
</ol>
</li>
<li><p><ins>(?.?.?) &mdash; Otherwise, if</ins></p>
<ol style="list-style-type: none">
<li><p><ins>(?.?.?.?) &mdash; <code>common_range&lt;R&gt;</code> is <code>true</code>,</ins></p></li>
<li><p><ins>(?.?.?.?) &mdash; the <i>qualified-id</i> <code>iterator_traits&lt;iterator_t&lt;R&gt;&gt;::iterator_category</code> 
is valid and denotes a type that models <code>derived_from&lt;input_iterator_tag&gt;</code>, and</ins></p></li>
<li><p><ins>(?.?.?.?) &mdash; <code>constructible_from&lt;C, iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, Args...&gt;</code> 
is <code>true</code>:</ins></p>
<blockquote><pre><ins>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</ins></pre></blockquote></li>
</ol>
</li>
</ol>
</li>
<li><p>(2.2) &mdash; Otherwise, if <code>input_range&lt;range_reference_t&lt;R&gt;&gt;</code> is <code>true</code>:</p>
<blockquote><pre>
to&lt;C&gt;(r | views::transform([](auto&amp;&amp; elem) {
  return to&lt;range_value_t&lt;C&gt;&gt;(std::forward&lt;decltype(elem)&gt;(elem));
}), std::forward&lt;Args&gt;(args)...);
</pre></blockquote></li>
<li><p>(2.3) &mdash; Otherwise, the program is ill-formed.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3980"><a href="#3980">3980</a><sup><a href="https://cplusplus.github.io/LWG/issue3980">(i)</a></sup>. The read exclusive ownership of an atomic read-modify-write operation and whether its read and write are two operations are unclear</h3>
<p><b>Section:</b> 33.5.4 <a href="https://wg21.link/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> jim x <b>Opened:</b> 2023-08-22 <b>Last modified:</b> 2023-11-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Such two questions are sourced from StackOverflow:
</p>
<ol>
<li><p><a href="https://stackoverflow.com/questions/77126045/can-the-read-operations-in-compare-exchange-strong-in-different-two-thread-rea/77126363?noredirect=1#comment135968355_77126363">Can the read operations in <code>compare_exchange_strong</code> in different two thread read the same value?</a></p></li>
<li><p><a href="https://stackoverflow.com/questions/65568185/for-purposes-of-ordering-is-atomic-read-modify-write-one-operation-or-two">For purposes of ordering, is atomic read-modify-write one operation or two?</a></p></li>
</ol>
<p>
Given this example:
</p>
<blockquote>
<pre>
#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;

struct SpinLock{
  std::atomic&lt;bool&gt; atomic_;
  void lock(){
    bool expected = false;
    while (!atomic_.compare_exchange_strong(expected,true,std::memory_order_release,std::memory_order_relaxed)) {
    }
  }
  void unlock(){
    atomic_.store(false, std::memory_order_release);
  }
};

int main(){
  SpinLock spin{false};
  auto t1 = std::thread([&amp;](){
    spin.lock();
    spin.unlock();
  });
  auto t2 = std::thread([&amp;](){
    spin.lock();
    spin.unlock();
  });
  t1.join();
  t2.join();
}
</pre>
</blockquote>
<p>
In the current draft, the relevant phrasing that can interpret that only one read-modify-write operation reads the initial 
value false is 33.5.4 <a href="https://wg21.link/atomics.order">[atomics.order]</a> p10:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
Atomic read-modify-write operations shall always read the last value (in the modification order) written before the write 
associated with the read-modify-write operation.
</p></blockquote>
<p>
However, the wording can have two meanings, each kind of read can result in different explanations for the example
</p>
<ol>
<li><p>The check of the violation is done before the side effect of the RMW is in the modification order, i.e. the rule is 
just checked at the read point.</p></li>
<li><p>The check of the violation is done after the side effect of the RMW is in the modification order, i.e. the rule is 
checked when <code>RMW</code> tries to add the side effect that is based on the read-value to the modification order, and that 
side effect wouldn't be added to the modification order if the rule was violated.</p></li>
</ol>
<p>
With the first interpretation, the two RMW operations can read the same initial value because that value is indeed the last value 
in the modification order before such two RMW operations produce the side effect to the modification order.
<p/>
With the second interpretation, there is only one RMW operation that can read the initial value because the latter one in 
the modification order would violate the rule if it read the initial value.
<p/>
Such two interpretations arise from that the wording doesn't clearly specify when that check is performed.
<p/>
So, my proposed wording is:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
Atomic read-modify-write operations shall always read the value from a side effect <code>X</code>, where <code>X</code> 
immediately precedes the side effect of the read-modify-write operation in the modification order.
</p></blockquote>
<p>
This wording keeps a similar utterance to 6.9.2.2 <a href="https://wg21.link/intro.races">[intro.races]</a>, and it can clearly convey the meaning 
that we say the value read by <code>RWM</code> is associated with the side effect of <code>RMW</code> in the modification order.
<p/>
Relevant discussion can be seen <a href="https://github.com/cplusplus/CWG/issues/423">CWG/issues/423</a> here.
</p>

<p><i>[2023-11-03; Reflector poll]</i></p>

<p>NAD. The first reading isn't plausible. </p>



<p id="res-3980"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages — C++">N4958</a>.
</p>

<ol>

<li><p>Modify 33.5.4 <a href="https://wg21.link/atomics.order">[atomics.order]</a> as indicated:</p>

<blockquote>
<p>
-10- Atomic read-modify-write operations shall always read the <del>last</del> value <ins>from a side effect <i>X</i>, 
where <i>X</i> immediately precedes the side effect of the read-modify-write operation</ins> <del>(</del>in the 
modification order<del>) written before the write associated with the read-modify-write operation</del>.
<p/>
-11- Implementations should make atomic stores visible to atomic loads within a reasonable amount of time.
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3981"><a href="#3981">3981</a><sup><a href="https://cplusplus.github.io/LWG/issue3981">(i)</a></sup>. Range adaptor closure object is underspecified for its return type</h3>
<p><b>Section:</b> 26.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-22 <b>Last modified:</b> 2024-01-29</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.adaptor.object">active issues</a> in [range.adaptor.object].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.adaptor.object">issues</a> in [range.adaptor.object].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In order to provide pipe support for user-defined range adaptors, <a href="https://wg21.link/P2387R3" title=" Pipe support for user-defined range adaptors">P2387R3</a> 
removed the specification that the adaptor closure object returns a view, which conforms to the wording of <code>ranges::to</code>.
<p/>
However, the current wording seems to be too low-spec so that the range adaptor closure object can return any type 
or even <code>void</code>. This makes it possible to break the previous specification when returning types that don't make sense, 
<a href="https://godbolt.org/z/Y4nvjY3xj">for example</a>:
</p>
<blockquote>
<pre>
#include &lt;ranges&gt;

struct Closure : std::ranges::range_adaptor_closure&lt;Closure&gt; {
  struct NonCopyable {
    NonCopyable(const NonCopyable&amp;) = delete;
  };

  const NonCopyable&amp; operator()(std::ranges::range auto&amp;&amp;);
};

auto r = std::views::iota(0) | Closure{}; // <span style="color:red;font-weight:bolder">hard error in stdlibc++ and MSVC-STL</span>
</pre></blockquote>
<p>
Above, since the return type of the pipeline operator is declared as <code>auto</code>, this causes the deleted 
copy constructor to be invoked in the function body and produces a hard error.
<p/>
The proposed resolution adds a specification for the range adaptor closure object to return a <i>cv</i>-unqualified class type.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD.
"The wording says <code>R | C</code> is equivalent to <code>C(R)</code>,
not <code>auto(C(R))</code>."
</p>



<p id="res-3981"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages — C++">N4958</a>.
</p>

<ol>

<li><p>Modify 26.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> as indicated:</p>

<blockquote>
<p>
-1- A <i>range adaptor closure object</i> is a unary function object that accepts a range argument. For a range adaptor
closure object <code>C</code> and an expression <code>R</code> such that <code>decltype((R))</code> models <code>range</code>, the 
following expressions are equivalent:
</p>
<p>[&hellip;]</p>
<p>
-2- Given an object <code>t</code> of type <code>T</code>, where
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <code>t</code> is a unary function object that accepts a range argument <ins>and returns a 
<i>cv</i>-unqualified class object</ins>,</p></li>
<li><p>[&hellip;]</p></li>
</ol>
<p>
then the implementation ensures that <code>t</code> is a range adaptor closure object.
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3982"><a href="#3982">3982</a><sup><a href="https://cplusplus.github.io/LWG/issue3982">(i)</a></sup>. <code><i>is-derived-from-view-interface</i></code> should require that <code>T</code> is derived from <code>view_interface&lt;T&gt;</code></h3>
<p><b>Section:</b> 26.4.4 <a href="https://wg21.link/range.view">[range.view]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-22 <b>Last modified:</b> 2023-10-30</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.view">issues</a> in [range.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the wording of <code><i>is-derived-from-view-interface</i></code> only detects whether type <code>T</code> is unambiguously 
derived from one base class <code>view_interface&lt;U&gt;</code> where <code>U</code> is not required to be <code>T</code>, which is not 
the intention of CRTP.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>Set status to Tentatively NAD.
The wording correctly handles the case where T derives from <code>Base</code>
which derives from <code>view_interface&lt;Base&gt;</code>.
We don't want it to only be satisfied for direct inheritance from
<code>view_interface&lt;T&gt;</code>, but from any specialization of
<code>view_interface</code>.
Previously the concept only checked for inheritance from <code>view_base</code>
but it was changed when <code>view_interface</code> stopped inheriting from
<code>view_base</code>.
</p>



<p id="res-3982"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages — C++">N4958</a>.
</p>

<ol>

<li><p>Modify 26.4.4 <a href="https://wg21.link/range.view">[range.view]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr bool <i>is-derived-from-view-interface</i> = <i>see below</i>;            // exposition only
template&lt;class T&gt;
  constexpr bool enable_view =
    derived_from&lt;T, view_base&gt; || <i>is-derived-from-view-interface</i>&lt;T&gt;;
</pre>
<blockquote>
<p>
-6- For a type <code>T</code>, <code><i>is-derived-from-view-interface</i>&lt;T&gt;</code>
is <code>true</code> if and only if <code>T</code> has exactly one public base class
<code>view_interface&lt;<ins>T</ins><del>U</del>&gt;</code> <del>for some type <code>U</code></del> and
<code>T</code> has no base classes of type <code>view_interface&lt;<ins>U</ins><del>V</del>&gt;</code> for any
other type <code><ins>U</ins><del>V</del></code>.
<p/>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3996"><a href="#3996">3996</a><sup><a href="https://cplusplus.github.io/LWG/issue3996">(i)</a></sup>. <code>projected&lt;I, identity&gt;</code> should just be <code>I</code></h3>
<p><b>Section:</b> 25.3.6.4 <a href="https://wg21.link/projected">[projected]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-10-12 <b>Last modified:</b> 2023-11-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#projected">issues</a> in [projected].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code>projected</code> is a wrapper of the implementation type regardless of whether <code>Proj</code> is <code>identity</code>.
<p/>
Since <code>identity</code> always returns a reference, this prevents <code>projected&lt;I, identity&gt;</code> from fully 
emulating the properties of the original iterator when its reference is a prvalue. 
<p/>
Such non-equivalence may lead to unexpected behavior in some cases (<a href="https://godbolt.org/z/KM45ndWvh">demo</a>):
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;ranges&gt;
#include &lt;iostream&gt;

int main() {
  auto outer = std::views::iota(0, 5)
             | std::views::transform([](int i) {
                 return std::views::single(i) | std::views::filter([](int) { return true; });
               });
  
  for (auto&amp;&amp; inner : outer)
    for (auto&amp;&amp; elem : inner)
      std::cout &lt;&lt; elem &lt;&lt; " "; // 0 1 2 3 4 
  
  std::ranges::for_each(
    outer,
    [](auto&amp;&amp; inner) {
      // <span  style="color:#C80000;font-weight:bold">error: passing 'const filter_view' as 'this' argument discards qualifiers</span>
      for (auto&amp;&amp; elem : inner)
        std::cout &lt;&lt; elem &lt;&lt; " ";
    });
}
</pre></blockquote>
<p>
In the above example, <code>ranges::for_each</code> requires <code>indirect_unary_predicate&lt;Pred, projected&lt;I, identity&gt;&gt;</code>
which ultimately requires <code>invocable&lt;Pred&amp;, iter_common_reference_t&lt;projected&lt;I, identity&gt;&gt;&gt;</code>.
<p/> 
According to the current wording, the reference and indirect value type of <code>projected&lt;I, identity&gt;</code> are 
<code>filter_view&amp;&amp;</code> and <code>filter_view&amp;</code> respectively, which causes its common reference to be eventually 
calculated as <code>const filter_view&amp;</code>. Since the former is not <code>const</code>-iterable, this results in a hard error 
during instantiation because <code>const begin</code> is called unexpectedly in an unconstrained lambda.
</p>
<p>
It seems like having <code>projected&lt;I, identity&gt;</code> just be <code>I</code> is a more appropriate choice, 
which makes the concept checking really specific to <code>I</code> rather than a potentially incomplete iterator wrapper.
</p>

<p><i>[2023-11-03; Reflector poll]</i></p>

<p>
NAD. <a href="https://wg21.link/P2997" title=" Removing the common reference requirement from the indirectly invocable concepts">P2997</a> solves this, and more.
"Applying the projection does in fact materialize prvalues,
so this is just lying unless we special-case identity everywhere."
</p>



<p id="res-3996"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages — C++">N4958</a>.
</p>

<ol>

<li><p>Modify 25.3.6.4 <a href="https://wg21.link/projected">[projected]</a> as indicated:</p>

<blockquote>
<p>
-1- Class template <code>projected</code> is used to constrain algorithms that accept callable objects and projections 
(3.42 <a href="https://wg21.link/defns.projection">[defns.projection]</a>). It combines an <code>indirectly_readable</code> type <code>I</code> and a callable 
object type <code>Proj</code> into a new <code>indirectly_readable</code> type whose <code>reference</code> type is the 
result of applying <code>Proj</code> to the <code>iter_reference_t</code> of <code>I</code>.
</p>
<blockquote><pre>
namespace std {
  template&lt;class I, class Proj&gt;
  struct <i>projected-impl</i> {                               // <i>exposition only</i>
    struct <i>type</i> {                                       // <i>exposition only</i>
      using value_type = remove_cvref_t&lt;indirect_result_t&lt;Proj&amp;, I&gt;&gt;;
      using difference_type = iter_difference_t&lt;I&gt;;     // <i>present only if</i> I
                                                        // <i>models</i> weakly_incrementable
      indirect_result_t&lt;Proj&amp;, I&gt; operator*() const;    // <i>not defined</i>
    };
  };

  template&lt;indirectly_readable I, indirectly_regular_unary_invocable&lt;I&gt; Proj&gt;
    using projected = <ins>conditional_t&lt;is_same_v&lt;Proj, identity&gt;, I, typename</ins> <i>projected-impl</i>&lt;I, Proj&gt;::type<ins>&gt;</ins>;
}
</pre></blockquote>
</blockquote>


</li>

</ol>





<hr>
<h3 id="4003"><a href="#4003">4003</a><sup><a href="https://cplusplus.github.io/LWG/issue4003">(i)</a></sup>. <code>view_interface::back</code> is overconstrained</h3>
<p><b>Section:</b> 26.5.3 <a href="https://wg21.link/view.interface">[view.interface]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-10-28 <b>Last modified:</b> 2023-11-07</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#view.interface">issues</a> in [view.interface].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code>view_interface</code> only provides the <code>back</code> member when the derived class satisfies both 
<code>bidirectional_range</code> and <code>common_range</code>, which ensures that <code>ranges::prev</code> can act its sentinel.
<p/>
However, requiring <code>common_range</code> seems to be too strict because when the derived class satisfies both 
<code>random_access_range</code> and <code>sized_range</code>, its end iterator can still be calculated in constant time, 
which is what some range adaptors currently do to greedily become common ranges.
<p/>
I think we should follow similar rules to eliminate this inconsistency (<a href="https://godbolt.org/z/1oEf58Krh">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;

constexpr auto r = std::ranges::subrange(std::views::iota(0), 5);
constexpr auto z = std::views::zip(r);
static_assert(r.back() == 4); // <span style="color:red;font-weight:bolder">ill-formed</span>
static_assert(std::get&lt;0&gt;(z.back()) == 4); // ok
</pre></blockquote>

<p><i>[2023-11-07; Reflector poll]</i></p>

+<p>NAD. "During the <code>concat</code> discussion LEWG decided not to
support the corner case of random-access sized but not-common ranges."
"If we did want to address such ranges, would be better to enforce commonness
for random-access sized ranges by having <code>ranges::end</code> return
<code>ranges::begin(r) + ranges::size(r)</code>."
</p>


<p id="res-4003"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages — C++">N4964</a>.
</p>

<ol>

<li><p>Modify 26.5.3 <a href="https://wg21.link/view.interface">[view.interface]</a>, class template <code>view_interface</code> synopsis, as indicated:</p>

<blockquote><pre>
namespace std::ranges {
  template&lt;class D&gt;
    requires is_class_v&lt;D&gt; &amp;&amp; same_as&lt;D, remove_cv_t&lt;D&gt;&gt;
  class view_interface {
    [&hellip;]
  public:
    [&hellip;]
    constexpr decltype(auto) back() requires <ins>(</ins>bidirectional_range&lt;D&gt; &amp;&amp; common_range&lt;D&gt;<ins>) ||</ins>
                                             <ins>(random_access_range&lt;D&gt; &amp;&amp; sized_range&lt;D&gt;)</ins>;
    constexpr decltype(auto) back() const
      requires <ins>(</ins>bidirectional_range&lt;const D&gt; &amp;&amp; common_range&lt;const D&gt;<ins>) ||</ins>
               <ins>(random_access_range&lt;const D&gt; &amp;&amp; sized_range&lt;const D&gt;)</ins>;
    [&hellip;]
  };
}
</pre></blockquote>

</li>

<li><p>Modify 26.5.3.2 <a href="https://wg21.link/view.interface.members">[view.interface.members]</a> as indicated:</p>

<blockquote>
<pre>
constexpr decltype(auto) back() requires <ins>(</ins>bidirectional_range&lt;D&gt; &amp;&amp; common_range&lt;D&gt;<ins>) ||</ins>
                                         <ins>(random_access_range&lt;D&gt; &amp;&amp; sized_range&lt;D&gt;)</ins>;
constexpr decltype(auto) back() const
  requires <ins>(</ins>bidirectional_range&lt;const D&gt; &amp;&amp; common_range&lt;const D&gt;<ins>) ||</ins>
           <ins>(random_access_range&lt;const D&gt; &amp;&amp; sized_range&lt;const D&gt;)</ins>;
</pre>
<blockquote>
<p>
-3- <i>Preconditions</i>: <code>!empty()</code> is <code>true</code>.
<p/>
-4- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
<ins>auto <i>common-arg-end</i> = []&lt;class R&gt;(R&amp; r) {
  if constexpr (common_range&lt;R&gt;) {
    return ranges::end(r);
  } else {
    return ranges::begin(r) + ranges::distance(r);
  }
};</ins>
return *ranges::prev(<ins><i>common-arg-end</i></ins><del>ranges::end</del>(<i>derived</i>()));
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4006"><a href="#4006">4006</a><sup><a href="https://cplusplus.github.io/LWG/issue4006">(i)</a></sup>. <code>chunk_view::<i>outer-iterator</i>::value_type</code> should provide <code>empty</code></h3>
<p><b>Section:</b> 26.7.28.4 <a href="https://wg21.link/range.chunk.outer.value">[range.chunk.outer.value]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-11-05 <b>Last modified:</b> 2024-03-11</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.chunk.outer.value">issues</a> in [range.chunk.outer.value].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>chunk_view::<i>outer-iterator</i>::value_type</code> can determine whether it is empty by simply checking whether the 
<code>chunk_view</code>'s <code><i>remainder_</i></code> is <code>0</code>, which makes it valuable to explicitly provide a 
<code>noexcept empty</code> member.
<p/>
Otherwise, the <code>view_interface::empty</code> is synthesized only through the <code>size</code> member when the original 
sentinel and iterator type model <code>sized_sentinel_for</code>, <a href="https://godbolt.org/z/v3MbzfT9G">which seems overkill</a>:
</p>
<blockquote><pre>
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;ranges&gt;

int main() {
  auto ints = std::istringstream{"1 2 3 4 5 6 7 8 9 10"};
  for (auto chunk : std::views::istream&lt;int&gt;(ints) | std::views::chunk(3)) {
    for (auto elem : chunk) {
      assert(!chunk.empty()); // <span style="color:red;font-weight:bolder">no matching function for call to 'empty()'</span>
      std::cout &lt;&lt; elem &lt;&lt; " ";
    }
    assert(chunk.empty()); // <span style="color:red;font-weight:bolder">ditto</span>
    std::cout &lt;&lt; "\n";
  }
}
</pre></blockquote>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after reflector poll in November 2023.
</p>
<p>
"The example shows you could use it if it existed, but not why that would be useful."
</p>
<p>
"This is a bad idea - the fact that the chunk 'shrinks' as it is iterated over
is an implementation detail and not supposed to be observable."
</p>



<p id="res-4006"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages — C++">N4964</a>.
</p>

<ol>

<li><p>Modify 26.7.28.4 <a href="https://wg21.link/range.chunk.outer.value">[range.chunk.outer.value]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
  namespace std::ranges {
    template&lt;view V&gt;
      requires input_range&lt;V&gt;
    struct chunk_view&lt;V&gt;::<i>outer-iterator</i>::value_type : view_interface&lt;value_type&gt; {
    private:
      chunk_view* <i>parent_</i>;                                        // <i>exposition only</i>

      constexpr explicit value_type(chunk_view&amp; parent);          // <i>exposition only</i>

    public:
      constexpr <i>inner-iterator</i> begin() const noexcept;
      constexpr default_sentinel_t end() const noexcept;

      <ins>constexpr bool empty() const noexcept;</ins>
      constexpr auto size() const
        requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
    };
  }
</pre>
</blockquote>
[&hellip;]
<pre>
constexpr default_sentinel_t end() const noexcept;
</pre>
<blockquote>
<p>
-3- <i>Returns</i>: <code>default_sentinel</code>.
</p>
</blockquote>
<pre>
<ins>constexpr bool empty() const noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Equivalent to: <code>return <i>parent_</i>-&gt;<i>remainder_</i> == 0;</code></ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4011"><a href="#4011">4011</a><sup><a href="https://cplusplus.github.io/LWG/issue4011">(i)</a></sup>. "<i>Effects</i>: Equivalent to return" in [span.elem]</h3>
<p><b>Section:</b> 24.7.2.2.6 <a href="https://wg21.link/span.elem">[span.elem]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Arthur O'Dwyer <b>Opened:</b> 2023-11-09 <b>Last modified:</b> 2024-03-11</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In reviewing the wording for <a href="https://wg21.link/P2821" title=" span.at()">P2821</a> <code>span.at()</code>, it had been noticed that 
24.7.2.2.6 <a href="https://wg21.link/span.elem">[span.elem]</a> uses a lot of "<i>Effects</i>: Equivalent to return [&hellip;];" which 
could be simply "<i>Returns</i>:  [&hellip;]".
<p/>
For comparison, 23.3.3.6 <a href="https://wg21.link/string.view.access">[string.view.access]</a> uses "<i>Returns</i>: ..." instead, so I 
suggest that 24.7.2.2.6 <a href="https://wg21.link/span.elem">[span.elem]</a> should be consistent with that.
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-4011"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages — C++">N4964</a>.
</p>

<ol>

<li><p>Modify 24.7.2.2.6 <a href="https://wg21.link/span.elem">[span.elem]</a> as indicated:</p>

<pre>
constexpr reference operator[](size_type idx) const;
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: <code>idx &lt; size()</code> is <code>true</code>.
<p/>
-2- <i><del>Effects</del><ins>Returns</ins></i>: <del>Equivalent to:</del> <code><del>return</del> *(data() + idx)<del>;</del></code><ins>.</ins>
<p/>
<ins>-?- <i>Throws</i>: Nothing.</ins>
</p>
</blockquote>
<pre>
constexpr reference front() const;
</pre>
<blockquote>
<p>
-3- <i>Preconditions</i>: <code>empty()</code> is <code>false</code>.
<p/>
-4- <i><del>Effects</del><ins>Returns</ins></i>: <del>Equivalent to:</del> <code><del>return</del> *data()<del>;</del></code><ins>.</ins>
<p/>
<ins>-?- <i>Throws</i>: Nothing.</ins>
</p>
</blockquote>
<pre>
constexpr reference back() const;
</pre>
<blockquote>
<p>
-5- <i>Preconditions</i>: <code>empty()</code> is <code>false</code>.
<p/>
-6- <i><del>Effects</del><ins>Returns</ins></i>: <del>Equivalent to:</del> <code><del>return</del> *(data() + (size() - 1))<del>;</del></code><ins>.</ins>
<p/>
<ins>-?- <i>Throws</i>: Nothing.</ins>
</p>
</blockquote>
<pre>
constexpr pointer data() const noexcept;
</pre>
<blockquote>
<p>
-7- <i><del>Effects</del><ins>Returns</ins></i>: <del>Equivalent to:</del> <code><del>return</del> <i>data_</i><del>;</del></code><ins>.</ins>
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4012"><a href="#4012">4012</a><sup><a href="https://cplusplus.github.io/LWG/issue4012">(i)</a></sup>. <code>common_view::begin/end</code> are missing the <code><i>simple-view</i></code> check</h3>
<p><b>Section:</b> 26.7.19.2 <a href="https://wg21.link/range.common.view">[range.common.view]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-11-11 <b>Last modified:</b> 2024-03-11</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.common.view">issues</a> in [range.common.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>common_view::begin/end</code> have exactly the same implementation as their corresponding <code>const</code> versions, 
which implies that when the underlying <code>V</code> satisfies <code><i>simple-view</i></code>, it is sufficient to 
just provide <code>const</code>-qualified members.
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-4012"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages — C++">N4964</a>.
</p>

<ol>

<li><p>Modify 26.7.19.2 <a href="https://wg21.link/range.common.view">[range.common.view]</a> as indicated:</p>

<blockquote><pre>
namespace std::ranges {
  template&lt;view V&gt;
    requires (!common_range&lt;V&gt; &amp;&amp; copyable&lt;iterator_t&lt;V&gt;&gt;)
  class common_view : public view_interface&lt;common_view&lt;V&gt;&gt; {
  private:
    V <i>base_</i> = V();  // <i>exposition only</i>

  public:
    [&hellip;]
    constexpr auto begin() <ins>requires (!<i>simple-view</i>&lt;V&gt;)</ins> {
      if constexpr (random_access_range&lt;V&gt; &amp;&amp; sized_range&lt;V&gt;)
        return ranges::begin(<i>base_</i>);
      else
        return common_iterator&lt;iterator_t&lt;V&gt;, sentinel_t&lt;V&gt;&gt;(ranges::begin(<i>base_</i>));
    }

    constexpr auto begin() const requires range&lt;const V&gt; {
      if constexpr (random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;)
        return ranges::begin(<i>base_</i>);
      else
        return common_iterator&lt;iterator_t&lt;const V&gt;, sentinel_t&lt;const V&gt;&gt;(ranges::begin(<i>base_</i>));
    }
    
    constexpr auto end() <ins>requires (!<i>simple-view</i>&lt;V&gt;)</ins> {
      if constexpr (random_access_range&lt;V&gt; &amp;&amp; sized_range&lt;V&gt;)
        return ranges::begin(<i>base_</i>) + ranges::distance(<i>base_</i>);
      else
        return common_iterator&lt;iterator_t&lt;V&gt;, sentinel_t&lt;V&gt;&gt;(ranges::end(<i>base_</i>));
    }

    constexpr auto end() const requires range&lt;const V&gt; {
      if constexpr (random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;)
        return ranges::begin(<i>base_</i>) + ranges::distance(<i>base_</i>);
      else
        return common_iterator&lt;iterator_t&lt;const V&gt;, sentinel_t&lt;const V&gt;&gt;(ranges::end(<i>base_</i>));
    }

    [&hellip;]
  };
[&hellip;]
}
</pre></blockquote>

</li>

</ol>





<hr>
<h3 id="4013"><a href="#4013">4013</a><sup><a href="https://cplusplus.github.io/LWG/issue4013">(i)</a></sup>. <code>lazy_split_view::<i>outer-iterator</i>::value_type</code> should not provide default constructor</h3>
<p><b>Section:</b> 26.7.16.4 <a href="https://wg21.link/range.lazy.split.outer.value">[range.lazy.split.outer.value]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-11-11 <b>Last modified:</b> 2024-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.lazy.split.outer.value">issues</a> in [range.lazy.split.outer.value].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After <a href="https://wg21.link/P2325" title=" Views should not be required to be default constructible">P2325</a>, there is no reason for <code>lazy_split_view::<i>outer-iterator</i>::value_type</code> 
to provide a default constructor, which only leads to <a href="https://godbolt.org/z/rM4WdMz79">unexpected behavior</a>:
</p>
<blockquote><pre>
#include &lt;ranges&gt;

constexpr int arr[] = {42};
constexpr auto split = arr | std::views::lazy_split(0);
static_assert(!std::ranges::range_value_t&lt;decltype(split)&gt;{});  // <span style="color:red;font-weight:bolder">UB, dereferencing a null pointer</span>
</pre></blockquote>
<p>
Also, the other constructor should be private because it makes no sense for the user to construct it arbitrarily, 
which is not the intention.
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-4013"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages — C++">N4964</a>.
</p>

<ol>

<li><p>Modify 26.7.16.4 <a href="https://wg21.link/range.lazy.split.outer.value">[range.lazy.split.outer.value]</a>, class <code>split_view::<i>outer-iterator</i>::value_type</code> synopsis, 
as indicated:</p>

<blockquote><pre>
namespace std::ranges {
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt; &amp;&amp;
             (forward_range&lt;V&gt; || <i>tiny-range</i>&lt;Pattern&gt;)
  template&lt;bool Const&gt;
  struct lazy_split_view&lt;V, Pattern&gt;::<i>outer-iterator</i>&lt;Const&gt;::value_type
    : view_interface&lt;value_type&gt; {
  private:
    <i>outer-iterator i_</i> = <i>outer-iterator</i>();               <i>// exposition only</i>
  
    <ins>constexpr explicit value_type(<i>outer-iterator</i> i);    <i>// exposition only</i></ins>

  public:
    <del>value_type() = default;</del>
    <del>constexpr explicit value_type(<i>outer-iterator</i> i);</del>

    constexpr <i>inner-iterator</i>&lt;Const&gt; begin() const;
    constexpr default_sentinel_t end() const noexcept;
  };
}
</pre></blockquote>

</li>

</ol>





<hr>
<h3 id="4016"><a href="#4016">4016</a><sup><a href="https://cplusplus.github.io/LWG/issue4016">(i)</a></sup>. <code><i>container-insertable</i></code> checks do not match what <code><i>container-inserter</i></code> does</h3>
<p><b>Section:</b> 26.5.7 <a href="https://wg21.link/range.utility.conv">[range.utility.conv]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2023-11-24 <b>Last modified:</b> 2024-03-11</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The exposition-only helper <code><i>container-inserter</i></code> uses either
<code>std::back_inserter</code> or <code>std::inserter</code>. Both
<code>std::back_insert_iterator</code> and <code>std::insert_iterator</code>
require <code>C::value_type</code> to be a valid type, and we do not check
for that in <code><i>container-insertable</i></code>.
The insert iterators can also incur a conversion to construct a
<code>C::value_type</code> which then gets moved into the container.
Using emplace instead of insert would avoid that temporary object.
It's also possible (although arguably not worth caring about) that
<code>range_value_t&lt;C&gt;</code> is not the same type as
<code>C::value_type</code>, and that conversion to <code>C::value_type</code>
could be ill-formed (we only check that conversion from
<code>range_reference_t&lt;R&gt;</code> to <code>range_value_t&lt;C&gt;</code>
is well-formed).
</p>
<p>
It seems preferable to remove the use of insert iterators, so that we don't
need to check their requirements at all.
</p>

<p><i>[2023-1-26; Rename exposition-only concept and function after reflector discussion.]</i></p>



<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-4016"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages — C++">N4964</a>.
</p>

<ol>

<li><p>Modify 26.5.7.1 <a href="https://wg21.link/range.utility.conv.general">[range.utility.conv.general]</a> as indicated:</p>

<blockquote>
<p>-4- Let <code><i>container-<del>insertable</del><ins>appendable</ins></i></code> be defined as follows:
<blockquote>
<pre><code>template&lt;class Container, class Ref&gt;
constexpr bool <i>container-<del>insertable</del><ins>appendable</ins></i> =         <i>// exposition only</i>
  requires(Container&amp; c, Ref&amp;&amp; ref) {
           requires (<ins>requires { c.emplace_back(std::forward&lt;Ref&gt;(ref)); } ||</ins>
                     requires { c.push_back(std::forward&lt;Ref&gt;(ref)); } ||
                     <ins>requires { c.emplace(c.end(), std::forward&lt;Ref&gt;(ref)); } ||</ins>
                     requires { c.insert(c.end(), std::forward&lt;Ref&gt;(ref)); });
};
</code></pre>
</blockquote>
</p>
<p>-5- Let <code><i>container-<del>inserter</del><ins>append</ins></i></code> be defined as follows:
<blockquote>
<pre><code>template&lt;class Container<del>, class Ref</del>&gt;
constexpr auto <i>container-<del>inserter</del><ins>append</ins></i>(Container&amp; c) {     <i>// exposition only</i>
<del>  if constexpr (requires { c.push_back(declval&lt;Ref&gt;()); })
    return back_inserter(c);
  else
    return inserter(c, c.end());</del>
<ins>  return [&amp;c]&lt;class Ref&gt;(Ref&amp;&amp; ref) {
    if constexpr (requires { c.emplace_back(declval&lt;Ref&gt;()); })
      c.emplace_back(std::forward&lt;Ref&gt;(ref));
    else if constexpr (requires { c.push_back(declval&lt;Ref&gt;()); })
      c.push_back(std::forward&lt;Ref&gt;(ref));
    else if constexpr (requires { c.emplace(c.end(), declval&lt;Ref&gt;()); })
      c.emplace(c.end(), std::forward&lt;Ref&gt;(ref));
    else
      c.insert(c.end(), std::forward&lt;Ref&gt;(ref));
  };</ins>
};
</code></pre>
</blockquote>
</p>
</blockquote>
</li>
<li><p>Modify 26.5.7.2 <a href="https://wg21.link/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>
<blockquote>
<p>(2.1.4) Otherwise, if
<ul style="list-style-type: none">
<li>&mdash; <code>constructible_from&lt;C, Args...&gt;</code> is <code>true</code>, and</li>
<li>&mdash; <code><i>container-<del>insertable</del><ins>appendable</ins></i>&lt;C, range_reference_t&lt;R&gt;&gt;</code> is <code>true</code>:</li>
</ul>
<blockquote>
<pre><code>
C c(std::forward&lt;Args&gt;(args)...);
if constexpr (sized_range&lt;R&gt; &amp;&amp; <i>reservable-container</i>&lt;C&gt;)
c.reserve(static_cast&lt;range_size_t&lt;C&gt;&gt;(ranges::size(r)));
ranges::<del>copy</del><ins>for_each</ins>(r, <i>container-<del>inserter</del><ins>append</ins></i><del>&lt;range_reference_t&lt;R&gt;&gt;</del>(c));
</code></pre>
</blockquote>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4023"><a href="#4023">4023</a><sup><a href="https://cplusplus.github.io/LWG/issue4023">(i)</a></sup>. Preconditions of <code>std::basic_streambuf::setg/setp</code></h3>
<p><b>Section:</b> 31.6.3.4 <a href="https://wg21.link/streambuf.protected">[streambuf.protected]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-12-08 <b>Last modified:</b> 2024-03-11</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems that operations of <code>std::basic_streambuf</code> expect that
</p>
<ul>
<li><p><code>[eback(), egptr())</code> is a valid range and <code>gptr()</code> points into that range, and</p></li>
<li><p><code>[pbase(), pptr())</code> is a valid range and <code>epptr()</code> points into that range.</p></li>
</ul>
<p>
However, it is currently not specified for <code>setg/setp</code> that such invariants need to be established.
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-4023"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages — C++">N4964</a>.
</p>

<ol>

<li><p>Modify 31.6.3.4.2 <a href="https://wg21.link/streambuf.get.area">[streambuf.get.area]</a> as indicated:</p>

<blockquote>
<pre>
void setg(char_type* gbeg, char_type* gnext, char_type* gend);
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions</i>: <code>[gbeg,  gnext)</code>, <code>[gbeg, gend)</code>, and <code>[gnext, gend)</code> are all valid ranges.</ins>
<p/>
-5- <i>Postconditions</i>: <code>gbeg == eback()</code>, <code>gnext == gptr()</code>, and <code>gend == egptr()</code> are all <code>true</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 31.6.3.4.3 <a href="https://wg21.link/streambuf.put.area">[streambuf.put.area]</a> as indicated:</p>

<blockquote>
<pre>
void setp(char_type* pbeg, char_type* pend);
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions</i>: <code>[pbeg, pend)</code> is a valid range.</ins>
<p/>
-5- <i>Postconditions</i>: <code>pbeg == pbase()</code>, <code>pbeg == pptr()</code>, and <code>pend == epptr()</code> are all <code>true</code>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4025"><a href="#4025">4025</a><sup><a href="https://cplusplus.github.io/LWG/issue4025">(i)</a></sup>. Move assignment operator of <code>std::expected&lt;<i>cv</i> void, E&gt;</code> should not be conditionally deleted</h3>
<p><b>Section:</b> 22.8.7.4 <a href="https://wg21.link/expected.void.assign">[expected.void.assign]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-12-16 <b>Last modified:</b> 2024-03-11</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#expected.void.assign">issues</a> in [expected.void.assign].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems intended that copy functions of <code>std::optional</code>, <code>std::variant</code>, and <code>std::expected</code> 
are conditionally deleted, while move functions are constrained. However, the move assignment operator of 
<code>std::expected&lt;<i>cv</i> void, E&gt;</code> is currently conditionally deleted, which is inconsistent.
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-4025"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>

<li><p>Modify 22.8.7.4 <a href="https://wg21.link/expected.void.assign">[expected.void.assign]</a> as indicated:</p>

<blockquote>
<pre>
constexpr expected&amp; operator=(expected&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints</i>: <code>is_move_constructible_v&lt;E&gt;</code> is <code>true</code> and 
<code>is_move_assignable_v&lt;E&gt;</code> is <code>true</code>.</ins>
<p/>
[&hellip;]
<p/>
-6- <i>Remarks</i>: The exception specification is equivalent to <code>is_nothrow_move_constructible_v&lt;E&gt; &amp;&amp;
is_nothrow_move_assignable_v&lt;E&gt;</code>.
<p/>
<del>-7- This operator is defined as deleted unless <code>is_move_constructible_v&lt;E&gt;</code> is <code>true</code> 
and <code>is_move_assignable_v&lt;E&gt;</code> is <code>true</code>.</del>
</p>
</blockquote>
</blockquote>
</li>

</ol>







<hr>
<h3 id="4030"><a href="#4030">4030</a><sup><a href="https://cplusplus.github.io/LWG/issue4030">(i)</a></sup>. Clarify whether arithmetic expressions in [numeric.sat.func] are mathematical or C++</h3>
<p><b>Section:</b> 27.10.17.1 <a href="https://wg21.link/numeric.sat.func">[numeric.sat.func]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Thomas K&ouml;ppe <b>Opened:</b> 2023-12-18 <b>Last modified:</b> 2024-03-11</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the application of <a href="https://wg21.link/P0543R0" title=" Saturation arithmetic">P0543R0</a>, "Saturation arithmetic", it was pointed out that it 
might not be entirely clear what we want something like "<code>x</code> + <code>y</code>" to mean. The paper does not 
suggest any formatting for those symbols, and a non-normative note explains that the intention is for 
the expression to be considered mathematically.
<p/>
I wonder if this is clear enough. Notes are not normative, and the document "shall be usable without notes". 
I have formatted this as <code>$\tcode{x} + \tcode{y}$</code> throughout, i.e. the variables are in code font, 
but the symbol is maths, not code. This is quite subtle. (See also 
<a href="https://github.com/cplusplus/draft/pull/6686">GitHub discussion</a>.)
<p/>
I think it would be an improvement if we simply made the note not be a note. It seems to contain entirely reasonable, mandatory content.
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-4030"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>

<li><p>Modify 27.10.17.1 <a href="https://wg21.link/numeric.sat.func">[numeric.sat.func]</a> as indicated:</p>

<blockquote>
<p>
-1- <del>[<i>Note 1</i>:</del> In the following descriptions, an arithmetic operation is performed as a mathematical 
operation with infinite range and then it is determined whether the mathematical result fits into the result type. 
<del>&mdash; <i>end note</i>]</del>
</p>
</blockquote>

</li>

</ol>







<hr>
<h3 id="4031"><a href="#4031">4031</a><sup><a href="https://cplusplus.github.io/LWG/issue4031">(i)</a></sup>. <code>bad_expected_access&lt;void&gt;</code> member functions should be <code>noexcept</code></h3>
<p><b>Section:</b> 22.8.5 <a href="https://wg21.link/expected.bad.void">[expected.bad.void]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Cassio Neri <b>Opened:</b> 2023-12-24 <b>Last modified:</b> 2024-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to 17.9.3 <a href="https://wg21.link/exception">[exception]</a>/2:
</p>
<blockquote>
<p>
Each standard library class <code>T</code> that derives from class <code>exception</code> has the following 
publicly accessible member functions, each of them having a non-throwing exception specification (14.5):
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; default constructor (unless the class synopsis shows other constructors)</p></li>
<li><p>(2.2) &mdash; copy constructor</p></li>
<li><p>(2.3) &mdash; copy assignment operator</p></li>
</ol>
</blockquote>
<p>
For good reasons, <code>bad_expected_access&lt;void&gt;</code> overrules from this general rule by 
protecting its special member functions. However, there's no reason these functions should not be 
<code>noexcept</code>.
</p>

<p><i>[2024-03-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-4031"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>

<li><p>Modify 22.8.5 <a href="https://wg21.link/expected.bad.void">[expected.bad.void]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;&gt;
  class bad_expected_access&lt;void&gt; : public exception {
  protected:
    bad_expected_access() noexcept;
    bad_expected_access(const bad_expected_access&amp;) <ins>noexcept</ins>;
    bad_expected_access(bad_expected_access&amp;&amp;) <ins>noexcept</ins>;
    bad_expected_access&amp; operator=(const bad_expected_access&amp;) <ins>noexcept</ins>;
    bad_expected_access&amp; operator=(bad_expected_access&amp;&amp;) <ins>noexcept</ins>;
    ~bad_expected_access();
  public:
    const char* what() const noexcept override;
  };
}
</pre>
</blockquote>

</li>

</ol>







<hr>
<h3 id="4035"><a href="#4035">4035</a><sup><a href="https://cplusplus.github.io/LWG/issue4035">(i)</a></sup>. <code>single_view</code> should provide <code>empty</code></h3>
<p><b>Section:</b> 26.6.3.2 <a href="https://wg21.link/range.single.view">[range.single.view]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-12-31 <b>Last modified:</b> 2024-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.single.view">issues</a> in [range.single.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Although <code>single_view::empty</code> can be synthesized through <code>view_interface</code>,
it seems more worthwhile to provide a static <code>empty</code> for it which eliminates the 
need to pass in an object parameter, guarantees <code>noexcept</code>-ness, and is consistent 
with the design of <code>empty_view</code> (<a href="https://godbolt.org/z/Yr6bhM11n">demo</a>):
</p>
<blockquote>
<pre>
#include &lt;ranges&gt;
auto empty = std::views::empty&lt;int&gt;;
static_assert(noexcept(empty.empty()));
static_assert(noexcept(empty.size()));
auto single = std::views::single(0);
static_assert(noexcept(single.empty())); // <span style="color:red;font-weight:bolder">fire</span>
static_assert(noexcept(single.size()));
</pre>
</blockquote>

<p><i>[2024-03-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-4035"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>

<li><p>Modify 26.6.3.2 <a href="https://wg21.link/range.single.view">[range.single.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;move_constructible T&gt;
    requires is_object_v&lt;T&gt;
  class single_view : public view_interface&lt;single_view&lt;T&gt;&gt; {
    [&hellip;]
  public:
    [&hellip;]
    constexpr T* begin() noexcept;
    constexpr const T* begin() const noexcept;
    constexpr T* end() noexcept;
    constexpr const T* end() const noexcept;
    <ins>static constexpr bool empty() noexcept;</ins>
    static constexpr size_t size() noexcept;
    constexpr T* data() noexcept;
    constexpr const T* data() const noexcept;
  };
  [&hellip;]
}
</pre>
</blockquote>
[&hellip;]
<pre>
constexpr T* end() noexcept;
constexpr const T* end() const noexcept;
</pre>
<blockquote>
<p>
-5- <i>Effects</i>: Equivalent to: <code>return data() + 1;</code>
</p>
</blockquote>
<pre>
<ins>static constexpr bool empty() noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Equivalent to: <code>return false;</code></ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>







<hr>
<h3 id="4036"><a href="#4036">4036</a><sup><a href="https://cplusplus.github.io/LWG/issue4036">(i)</a></sup>. <code>__alignof_is_defined</code> is only implicitly specified in C++ and not yet deprecated</h3>
<p><b>Section:</b> D.11 <a href="https://wg21.link/depr.c.macros">[depr.c.macros]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-01-12 <b>Last modified:</b> 2024-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently 17.14.4 <a href="https://wg21.link/stdalign.h.syn">[stdalign.h.syn]</a> states
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
The contents of the C++ header <code>&lt;stdalign.h&gt;</code> are the same as the C standard library header 
<code>&lt;stdalign.h&gt;</code>, with the following changes: The header <code>&lt;stdalign.h&gt;</code> does not 
define a macro named <code>alignas</code>.
<p/>
<span style="font-variant: small-caps">See also</span>: ISO/IEC 9899:2018, 7.15
</p>
</blockquote>
<p>
which implicitly specifies that <code>__alignof_is_defined</code> is also provided in C++, because C17 
specified that the macro is provided in <code>&lt;stdaligh.h&gt;</code>.
<p/>
However, there's no explicit mentioning of <code>__alignof_is_defined</code> in the C++ standard wording. 
And D.11 <a href="https://wg21.link/depr.c.macros">[depr.c.macros]</a>/1 (added by LWG <a href="lwg-defects.html#3827" title="Deprecate &lt;stdalign.h&gt; and &lt;stdbool.h&gt; macros">3827</a>) seemingly contradicts with 
17.14.4 <a href="https://wg21.link/stdalign.h.syn">[stdalign.h.syn]</a> and only makes <code>__alignas_is_defined</code> deprecated.
<p/>
It seems that we should explicitly mention <code>__alignof_is_defined</code> in D.11 <a href="https://wg21.link/depr.c.macros">[depr.c.macros]</a> 
at this moment.
</p>

<p><i>[2024-03-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-4036"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>

<li><p>Modify D.11 <a href="https://wg21.link/depr.c.macros">[depr.c.macros]</a> as indicated:</p>

<blockquote>
<p>
-1- The header <code>&lt;stdalign.h&gt;</code> has the following macro<ins>s</ins>:
</p>
<blockquote>
<pre>
#define __alignas_is_defined 1
<ins>#define __alignof_is_defined 1</ins>
</pre>
</blockquote>
</blockquote>

</li>

</ol>







<hr>
<h3 id="4037"><a href="#4037">4037</a><sup><a href="https://cplusplus.github.io/LWG/issue4037">(i)</a></sup>. Static data members of <code>ctype_base</code> are not yet required to be usable in constant expressions</h3>
<p><b>Section:</b> 30.4.2.1 <a href="https://wg21.link/category.ctype.general">[category.ctype.general]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-01-12 <b>Last modified:</b> 2024-03-13</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It may be desired that static data members <code>ctype_base</code> are "real constants", i.e. usable in constant expressions. 
However, this is not strictly required because <code>mask</code> is only required to be a bitmask type that can be a class type, 
which makes the plain <code>const</code> potentially insufficient.
</p>

<p><i>[2024-03-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-4037"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>

<li><p>Modify 30.4.2.1 <a href="https://wg21.link/category.ctype.general">[category.ctype.general]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std {
  class ctype_base {
  public:
    using mask = <i>see below</i>;

    // <i>numeric values are for exposition only.</i>
    static const<ins>expr</ins> mask space  = 1 &lt;&lt; 0;
    static const<ins>expr</ins> mask print  = 1 &lt;&lt; 1;
    static const<ins>expr</ins> mask cntrl  = 1 &lt;&lt; 2;
    static const<ins>expr</ins> mask upper  = 1 &lt;&lt; 3;
    static const<ins>expr</ins> mask lower  = 1 &lt;&lt; 4;
    static const<ins>expr</ins> mask alpha  = 1 &lt;&lt; 5;
    static const<ins>expr</ins> mask digit  = 1 &lt;&lt; 6;
    static const<ins>expr</ins> mask punct  = 1 &lt;&lt; 7;
    static const<ins>expr</ins> mask xdigit = 1 &lt;&lt; 8;
    static const<ins>expr</ins> mask blank  = 1 &lt;&lt; 9;
    static const<ins>expr</ins> mask alnum  = alpha | digit;
    static const<ins>expr</ins> mask graph  = alnum | punct;
  };
}
</pre>
</blockquote>
<p>
-1- The type <code>mask</code> is a bitmask type (16.3.3.3.3 <a href="https://wg21.link/bitmask.types">[bitmask.types]</a>).
</p>
</blockquote>


</li>

</ol>







<hr>
<h3 id="4038"><a href="#4038">4038</a><sup><a href="https://cplusplus.github.io/LWG/issue4038">(i)</a></sup>. <code>std::text_encoding::aliases_view</code> should have constexpr iterators</h3>
<p><b>Section:</b> 30.6.2.5 <a href="https://wg21.link/text.encoding.aliases">[text.encoding.aliases]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2024-01-16 <b>Last modified:</b> 2024-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>aliases_view::begin()</code> and <code>aliases_view::end()</code>
are constexpr functions, but there is no requirement that you can use
the returned iterator and sentinel in constant expressions.
</p>

<p><i>[2024-03-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-4038"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>
<li><p>Modify 30.6.2.5 <a href="https://wg21.link/text.encoding.aliases">[text.encoding.aliases]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
struct text_encoding::aliases_view : ranges::view_interface&lt;text_encoding::aliases_view&gt; {
  constexpr <i>implementation-defined</i> begin() const;
  constexpr <i>implementation-defined</i> end() const;
};
</pre>
</blockquote>
<p>
-1-
<code>text_encoding::aliases_view</code> models <code>copyable</code>,
<code>ranges::view</code>, <code>ranges::random_access_range</code>,
and <code>ranges::borrowed_range</code>.
</p>
<p>
-2-
Both <code>ranges::range_value_t&lt;text_encoding::aliases_view&gt;</code>
and <code>ranges::range_reference_t&lt;text_encoding::aliases_view&gt;</code>
denote <code>const char*</code>.
</p>
<p>
<ins>
-?-
<code>ranges::iterator_t&lt;text_encoding::aliases_view&gt;</code>
is a constexpr iterator (25.3.1 <a href="https://wg21.link/iterator.requirements.general">[iterator.requirements.general]</a>).
</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4043"><a href="#4043">4043</a><sup><a href="https://cplusplus.github.io/LWG/issue4043">(i)</a></sup>. <code>"ASCII"</code> is not a registered character encoding</h3>
<p><b>Section:</b> 30.6.2.2 <a href="https://wg21.link/text.encoding.general">[text.encoding.general]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2024-01-23 <b>Last modified:</b> 2024-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The IANA Charater Sets registry does not contain "ASCII" as an alias of the
"US-ASCII" encoding. This is apparently for historical reasons, because there
used to be some ambiguity about exactly what "ASCII" meant. I don't think
those historical reasons are relevant to C++26, but the absence of "ASCII"
in the IANA registry means that it's not a registered character encoding
as defined by 30.6.2.2 <a href="https://wg21.link/text.encoding.general">[text.encoding.general]</a>.
</p>

<p>
This means that the encoding referred to by notes in the C++ standard
(31.12.6.2 <a href="https://wg21.link/fs.path.generic">[fs.path.generic]</a>, 30.4.4.1.3 <a href="https://wg21.link/facet.numpunct.virtuals">[facet.numpunct.virtuals]</a>)
and by an example in the <code>std::text_encoding</code> proposal
(<a href="https://wg21.link/P1885" title=" Naming Text Encodings to Demystify Them">P1885</a>) isn't actually usable in portable code.
So <code>std::text_encoding("ASCII")</code> creates an object with
<code>mib() == std::text_encoding::other</code>, which is not the same
encoding as <code>std::text_encoding("US-ASCII")</code>.
This seems surprising.
</p>

<p><i>[2024-03-12; Reflector poll]</i></p>

<p>
SG16 approved the proposed resolution.
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-4043"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>
<li><p>Modify 30.6.2.2 <a href="https://wg21.link/text.encoding.general">[text.encoding.general]</a> as indicated:</p>

<blockquote>
<p>-1-
A <i>registered character encoding</i> is a character encoding scheme
in the IANA Character Sets registry.
</p>
<p>
[<i>Note 1</i>:
The IANA Character Sets registry uses the term “character sets” to refer to character encodings.
&mdash; <i>end note</i>]
</p>
<p>
The primary name of a registered character encoding is the name
of that encoding specified in the IANA Character Sets registry.
</p>

<p>-2-
The set of known registered character encodings contains every
registered character encoding specified in the IANA Character Sets registry
except for the following:
<ol style="list-style-type: none">
<li>(2.1) &ndash; NATS-DANO (33)</li>
<li>(2.2) &ndash; NATS-DANO-ADD (34)</li>
</ol>
</p>

<p>-3-
Each known registered character encoding is identified by an enumerator in
<code>text_encoding::id</code>, and has a set of zero or more <i>aliases</i>.
</p>

<p>-4-
The set of aliases of a known registered character encoding is an
implementation-defined superset of the aliases specified in the
IANA Character Sets registry.
<ins>The set of aliases for US-ASCII includes <code>"ASCII"</code>.</ins>
No two aliases or primary names of distinct registered character encodings
are equivalent when compared by <code>text_encoding::<i>comp-name</i></code>.
</p>

</blockquote>
</li>
</ol>






<hr>
<h3 id="4045"><a href="#4045">4045</a><sup><a href="https://cplusplus.github.io/LWG/issue4045">(i)</a></sup>. <code>tuple</code> can create dangling references from <code><i>tuple-like</i></code></h3>
<p><b>Section:</b> 22.4.4.2 <a href="https://wg21.link/tuple.cnstr">[tuple.cnstr]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2024-01-24 <b>Last modified:</b> 2024-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P2165R4" title=" Compatibility between tuple, pair and tuple-like objects">P2165R4</a>
(Compatibility between tuple, pair and tuple-like objects)
added two new constructors to <code>std::tuple</code>:
</p>
<pre><code>
  template&lt;tuple-likeUTuple&gt;
    constexpr explicit(see below ) tuple(UTuple&amp;&amp; u);
</code></pre>
<p>
and the allocator-extended equivalent.
Unlike the existing constructors taking a single parameter of tuple type,
these new constructors are not defined as deleted if they would create a
dangling reference to a temporary. The existing constructors gained that
restriction from
<a href="https://wg21.link/P2255R2" title=" A type trait to detect reference binding to temporary">P2255R2</a>
(A type trait to detect reference binding to temporary)
which was approved one meeting before
<a href="https://wg21.link/P2165R4" title=" Compatibility between tuple, pair and tuple-like objects">P2165R4</a>
so LWG seem to have missed the inconsistency.
</p>
<p>
The proposal also added a new constructor for <code>std::pair</code>:
</p>
<pre><code>
  template&lt;pair-like P&gt; constexpr explicit(<i>see below</i>) pair(P&amp;&amp; p);
</code></pre>
<p>
This <em>is</em> deleted if it would create a dangling reference,
although that seems to be an almost accidental consequence of adding
the new signature after existing ones which already have the <em>Remarks</em>:
about being deleted.
</p>

<p><i>[2024-03-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eleven votes in favour during reflector poll.
</p>



<p id="res-4045"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>
<ol>
<li><p>Modify 22.4.4.2 <a href="https://wg21.link/tuple.cnstr">[tuple.cnstr]</a> as indicated:</p>
<blockquote>
<pre><code>
template&lt;<i>tuple-like</i> UTuple&gt;
  constexpr explicit(<i>see below</i>) tuple(UTuple&amp;&amp; u);
</code></pre>
<p>-28-
Let <code>I</code> be the pack <code>0, 1, ..., (sizeof...(Types) - 1)</code>.
</p>
<p>-29-
<i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li>(29.1) &ndash;
<code><i>different-from</i>&lt;UTuple, tuple&gt;</code>
(26.5.2 <a href="https://wg21.link/range.utility.helpers">[range.utility.helpers]</a>) is <code>true</code>,
</li>
<li>(29.2) &ndash;
<code>remove_cvref_t&lt;UTuple&gt;</code> is not a specialization of
<code>ranges::subrange</code>,
</li>
<li>(29.3) &ndash;
<code>sizeof...(Types)</code> equals
<code>tuple_size_v&lt;remove_cvref_t&lt;UTuple&gt;&gt;</code>,
</li>
<li>(29.4) &ndash;
<code>(is_constructible_v&lt;Types, decltype(get&lt;I&gt;(std::forward&lt;UTuple&gt;(u)))> &amp;&amp; ...)</code>
 is
<code>true</code>, and
</li>
<li>(29.5) &ndash;
either <code>sizeof...(Types)</code> is not 1,
or (when <code>Types...</code> expands to <code>T</code>)
<code>is_convertible_v&lt;UTuple, T&gt;</code> and <code>is_constructible_v&lt;T, UTuple&gt;</code>
are both <code>false</code>.
</li>
</ol>
<p>-30- <i>Effects</i>:
For all <i>i</i>,
initializes the <i>i</i><sup>th</sup> element of <code>*this</code>
with <code>get&lt;i&gt;(std::forward&lt;UTuple&gt;(u))</code>.
</p>
<p>-31- <i>Remarks</i>:
The expression inside <code>explicit</code> is equivalent to:
</p>
<pre><code>  !(is_convertible_v&lt;decltype(get&lt;I&gt;(std::forward&lt;UTuple&gt;(u))), Types&gt; &amp;&amp; ...)
</code></pre>
<p>
<ins>
The constructor is defined as deleted if
</ins>
</p>
<pre><code><ins>  (reference_constructs_from_temporary_v&lt;Types, decltype(get&lt;I&gt;(std::forward&lt;UTuple&gt;(u)))&gt; || ...)</ins>
</code></pre>
<p>
<ins>
is <code>true</code>.
</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4053"><a href="#4053">4053</a><sup><a href="https://cplusplus.github.io/LWG/issue4053">(i)</a></sup>. Unary call to <code>std::views::repeat</code> does not decay the argument</h3>
<p><b>Section:</b> 26.6.5.2 <a href="https://wg21.link/range.repeat.view">[range.repeat.view]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-02-05 <b>Last modified:</b> 2024-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.repeat.view">active issues</a> in [range.repeat.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.repeat.view">issues</a> in [range.repeat.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, a binary call to <code>std::views::repeat</code> decay the arguments due to the deduction guide, 
but a unary call doesn't, which is inconsistent.
<p/>
For example:
</p>
<blockquote><pre>
#include &lt;concepts&gt;
#include &lt;ranges&gt;

using RPV = std::ranges::repeat_view&lt;const char*&gt;;

static_assert(std::same_as&lt;decltype(std::views::repeat("foo", std::unreachable_sentinel)), RPV&gt;); // OK
static_assert(std::same_as&lt;decltype(std::views::repeat(+"foo", std::unreachable_sentinel)), RPV&gt;); // OK
static_assert(std::same_as&lt;decltype(std::views::repeat("foo")), RPV&gt;); // <span style="color:red;font-weight:bolder">ill-formed</span>
static_assert(std::same_as&lt;decltype(std::views::repeat(+"foo")), RPV&gt;); // OK
</pre></blockquote>
<p>
Presumably we should extend the deduction guide of <code>std::ranges::repeat_view</code> to cover the unary cases.
</p>

<p><i>[2024-03-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-4053"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>
<li><p>Modify 26.6.5.2 <a href="https://wg21.link/range.repeat.view">[range.repeat.view]</a>, class template <code>repeat_view</code> synopsis, as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The proposed wording has been suggested by Casey Carter, see 
<a href="https://github.com/microsoft/STL/issues/3576">microsoft/STL#3576</a>]
</p>
</blockquote>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]

  template&lt;class T, class Bound <ins>= unreachable_sentinel_t</ins>&gt;
    repeat_view(T, Bound <ins>= Bound()</ins>) -&gt; repeat_view&lt;T, Bound&gt;;
}
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4054"><a href="#4054">4054</a><sup><a href="https://cplusplus.github.io/LWG/issue4054">(i)</a></sup>. Repeating a <code>repeat_view</code> should repeat the view</h3>
<p><b>Section:</b> 26.6.5.1 <a href="https://wg21.link/range.repeat.overview">[range.repeat.overview]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2024-02-12 <b>Last modified:</b> 2024-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>views::repeat(views::repeat(5))</code> should be a view of <code>repeat_view</code>s, but it's currently a view of 
<code>ints</code> due to the use of CTAD in the specification of <code>views::repeat</code>.
</p>

<p><i>[2024-03-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-4054"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>
<li><p>Modify 26.6.5.1 <a href="https://wg21.link/range.repeat.overview">[range.repeat.overview]</a> as indicated:</p>

<blockquote>
<p>
-1- <code>repeat_view</code> generates a sequence of elements by repeatedly producing the same value.
<p/>
-2- The name <code>views::repeat</code> denotes a customization point object (16.3.3.3.5 <a href="https://wg21.link/customization.point.object">[customization.point.object]</a>). 
Given subexpressions <code>E</code> and <code>F</code>, the expressions <code>views::repeat(E)</code> and <code>views::repeat(E, F)</code> 
are expression-equivalent to <code>repeat_view<ins>&lt;decay_t&lt;decltype((E))&gt;&gt;</ins>(E)</code> and 
<code>repeat_view(E, F)</code>, respectively.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4056"><a href="#4056">4056</a><sup><a href="https://cplusplus.github.io/LWG/issue4056">(i)</a></sup>. The effects of <code>std::swap</code> are under-specified</h3>
<p><b>Section:</b> 22.2.2 <a href="https://wg21.link/utility.swap">[utility.swap]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jan Schultke <b>Opened:</b> 2024-02-28 <b>Last modified:</b> 2024-03-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#utility.swap">active issues</a> in [utility.swap].</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.swap">issues</a> in [utility.swap].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Subclause 22.2.2 <a href="https://wg21.link/utility.swap">[utility.swap]</a> describes the effect of <code>std::swap</code> as follows:
</p>
<blockquote>
<p>
<i>Effects</i>: Exchanges values stored in two locations.
</p>
</blockquote>
<p>
This description is extremely vague. A possible implementation which complies with this wording is:
</p>
<blockquote>
<pre>
template&lt;class T&gt;
constexpr void swap(T&amp;, T&amp;) noexcept(/* ... */)
{
    int __x = 0, __y = 0;
    int __z = __x;
    __x = __y;
    __y = __z;
}
</pre>
</blockquote>
<p>
This exchanges values stored in two locations; namely in the locations of two objects with automatic 
storage duration within <code>swap</code>. Since this has no observable effect and complies, it is also 
valid to implement <code>swap</code> as follows:
</p>
<blockquote>
<pre>
template&lt;class T&gt;
constexpr void swap(T&amp;, T&amp;) noexcept(/* ... */) { }
</pre>
</blockquote>
<p>
Furthermore, there is implementation divergence. 
<a href="https://github.com/llvm/llvm-project/blob/26402777ebf4eb3d8f3d5a45943b451c740b2d76/libcxx/include/__utility/swap.h#L42">
libc++ uses direct-initialization</a> to construct a temporary <code>T</code>, but 
<a href="https://github.com/gcc-mirror/gcc/blob/80c386cb20d38ebc55f30a79418fabfbed904b87/libstdc%2B%2B-v3/include/bits/move.h#L221">
libstdc++ uses copy-initialization</a>. For most types, this hopefully calls the same constructor, however, 
this is not universally true. The standard should specify in more detail what is meant to happen.
</p>

<p><i>[2024-03-15; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD Editorial after reflector poll.
</p>
<p>
<em>Cpp17MoveConstructible</em> require direct-init and copy-init to be
semantically equivalent, so the different implementation techniques can
only be observed by types which fail to meet the function's preconditions.
</p>
<p>
Replace the unusual "stored in two locations" wording
<a href="https://github.com/cplusplus/draft/pull/6857">editorially</a>.
</p>



<p id="res-4056"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>
<li><p>Modify 22.2.2 <a href="https://wg21.link/utility.swap">[utility.swap]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr void swap(T&amp; a, T&amp; b) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Constraints</i>: <code>is_move_constructible_v&lt;T&gt;</code> is <code>true</code> and 
<code>is_move_assignable_v&lt;T&gt;</code> is <code>true</code>.
<p/>
-2-<i>Preconditions</i>: Type <code>T</code> meets the <i>Cpp17MoveConstructible</i> (Table 31) and 
<i>Cpp17MoveAssignable</i> (Table 33) requirements.
<p/>
-3- <i>Effects</i>: <del>Exchanges values stored in two locations.</del><ins>Equivalent to:</ins>
</p>
<blockquote><pre>
<ins>auto t(std::move(a));
a = std::move(b);
b = std::move(t);</ins>
</pre></blockquote>
<p>
-4- <i>Remarks</i>: The exception specification is equivalent to: [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





</body>
</html>
