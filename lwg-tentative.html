<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<p>Revised 2025-10-20 at 14:47:46 UTC
</p><h2>Tentative Issues</h2>
<hr>
<h3 id="3627"><a href="#3627">3627</a><sup><a href="https://cplusplus.github.io/LWG/issue3627">(i)</a></sup>. Inconsistent specifications for <code>std::make_optional</code> overloads</h3>
<p><b>Section:</b> 22.5.10 <a href="https://wg21.link/optional.specalg">[optional.specalg]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2021-10-23 <b>Last modified:</b> 2025-10-16</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Three <code>std::make_optional</code> overloads are specified in 22.5.10 <a href="https://wg21.link/optional.specalg">[optional.specalg]</a>. 
The first one is specified by "<i>Returns:</i>" and the other two are specified by "<i>Effects:</i> Equivalent to:".
According to 16.3.2.4 <a href="https://wg21.link/structure.specifications">[structure.specifications]</a>/4, such uses of "<i>Effects:</i> Equivalent to:" 
propagate the <i>Constraints</i> specified for constructors. As the selected constructor for the first 
overload has "<i>Constraints:</i>" (22.5.3.2 <a href="https://wg21.link/optional.ctor">[optional.ctor]</a>/22), it seems that inconsistency is introduced here.
<p/>
Existing implementations are inconsistent: libstdc++ constrains all three overloads, 
while libc++ and MSVC STL do not constrain any of them.
<p/>
IMO all three overloads should be constrained.
</p>

<p><i>[2022-01-29; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[2025-10-16; Status changed: New &rarr; Tentatively Ready.]</i></p>

<p>Reflector poll in 2024-07 with eight supporting votes.</p>



<p id="res-3627"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4901">N4901</a>.
</p>

<ol>
<li><p>Modify 22.5.10 <a href="https://wg21.link/optional.specalg">[optional.specalg]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt; constexpr optional&lt;decay_t&lt;T&gt;&gt; make_optional(T&amp;&amp; v);
</pre>
<blockquote>
<p>
-3- <i><del>Returns</del><ins>Effects</ins>:</i> <ins>Equivalent to: </ins><code><ins>return </ins>optional&lt;decay_t&lt;T&gt;&gt;(std::forward&lt;T&gt;(v))<ins>;</ins></code><del>.</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3908"><a href="#3908">3908</a><sup><a href="https://cplusplus.github.io/LWG/issue3908">(i)</a></sup>. <code>enumerate_view::<i>iterator</i></code> constructor is explicit</h3>
<p><b>Section:</b> 25.7.24.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2023-03-23 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.enumerate.iterator">active issues</a> in [range.enumerate.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.enumerate.iterator">issues</a> in [range.enumerate.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>enumerate_view::<i>iterator</i></code> has this constructor:
</p>
<blockquote>
<pre><code>    constexpr explicit
      <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);  <i>// exposition only</i>
</code></pre>
</blockquote>

<p>
In <a href="https://wg21.link/P2164R9" title=" views::enumerate">P2164R9</a> the detailed description of the function showed a
default argument for the second parameter, which would justify it being
explicit. However, that default argument was not present in the class synopsis
and was removed from the detailed description when applying the paper to the
draft.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after four votes in favour during reflector poll.
The constructor is exposition-only, it doesn't make any difference to anything
whether it's explicit or not.
</p>



<p id="res-3908"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>
<ol>
<li>
<p>
Modify the class synopsis in 25.7.24.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a>
as shown:
</p>
<blockquote><pre><code>
    constexpr <del>explicit</del>
      <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);  <i>// exposition only</i>
</code></pre></blockquote>
</li>

<li>
<p>
Modify the detailed description in 25.7.24.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a>
as shown:
</p>
<blockquote>
<pre><code>  constexpr <del>explicit</del> <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);
</code></pre>
<p>-2-
<i>Effects</i>: Initializes <code><i>current_</i></code>
with <code>std::move(current)</code> and <code><i>pos_</i></code> with
<code>pos</code>.
</p>
</blockquote>
</li>

</ol>






<hr>
<h3 id="3909"><a href="#3909">3909</a><sup><a href="https://cplusplus.github.io/LWG/issue3909">(i)</a></sup>. Issues about <code>viewable_range</code></h3>
<p><b>Section:</b> 99 [ranges.refinements], 25.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-27 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After LWG <a href="lwg-defects.html#3724" title="decay-copy should be constrained (Status: C++23)">3724</a><sup><a href="https://cplusplus.github.io/LWG/issue3724" title="Latest snapshot">(i)</a></sup>, <code>views::all</code> is well-constrained for view types,
and the constraints are stronger than <code>viewable_range</code>.
The difference is that given an expression such that <code>decltype</code> gives <code>R</code>,
when <code>decay_t&lt;R&gt;</code> is a view type and the implicit conversion of <code>R</code>
to <code>decay_t&lt;R&gt;</code> is forbidden, <code>views::all</code> rejects the expression,
but <code>viewable_range</code> may accept <code>R</code>.
So I think we should remove the additional constraints on <code>views::all_t</code>.
</p>
<p>
While <code>viewable_range</code> is probably not introducing any additional constraint within the standard library,
I think it is still useful to express the constraints on <code>views::all</code>,
so it should be slightly adjusted to match <code>views::all</code>.
</p>
<p>
Furthermore, <code>viewable_range</code> is currently used in 25.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a>,
but given <a href="https://wg21.link/P2378R3">P2378R3</a> relaxed the requirements for range adaptor closure objects,
I think we should also apply similar relaxation for range adaptor objects.
This should have no impact on standard range adaptor objects.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after three votes in favour during reflector poll.
</p>
<p>
"First change is pointless. Second change is a duplicate of <a href="lwg-active.html#3896" title="The definition of viewable_range is not quite right (Status: New)">3896</a><sup><a href="https://cplusplus.github.io/LWG/issue3896" title="Latest snapshot">(i)</a></sup>.
Range adaptors return a view over their first argument, so they need to
require it's a <code>viewable_range</code>."
</p>



<p id="res-3909"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<ol>
<li>
<p>
Change the definition of <code>views::all_t</code> in 25.2 <a href="https://wg21.link/ranges.syn">[ranges.syn]</a> as indicated:
</p>
<blockquote><pre><code>
   template&lt;<del>viewable_range</del><ins>class</ins> R&gt;
      using all_t = decltype(all(declval&lt;R&gt;()));          // freestanding
</code></pre>
</blockquote>
</li>
<li>
<p>
Change the definition of <code>viewable_range</code> in 25.4.6 <a href="https://wg21.link/range.refinements">[range.refinements]</a> as indicated:
</p>
<blockquote>
<p>-6-
The <code>viewable_range</code> concept specifies the requirements of a <code>range</code> type
that can be converted to a view safely.
</p>
<pre><code>
template&lt;class T&gt;
  concept viewable_range =
    range&lt;T&gt; &amp;&amp;
    ((view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp; <del>constructible_from&lt;remove_cvref_t&lt;T&gt;, T&gt;</del> <ins>convertible_to&lt;T, remove_cvref_t&lt;T&gt;&gt;</ins>) ||
     (!view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp;
      (is_lvalue_reference_v&lt;T&gt; || (movable&lt;remove_reference_t&lt;T&gt;&gt; &amp;&amp; !<i>is-initializer-list</i>&lt;T&gt;))));
</code></pre>
</blockquote>
</li>
<li>
<p>
Change 25.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> as indicated:
</p>
<blockquote>
<p>-6-
A <i>range adaptor object</i> is a customization point object (16.3.3.3.5 <a href="https://wg21.link/customization.point.object">[customization.point.object]</a>)
that accepts a <code><del>viewable_range</del><ins>range</ins></code> as its first argument
and returns a view.
</p>
<p>
[&hellip;]
</p>
<p>-8-
If a range adaptor object <code>adaptor</code> accepts more than one argument,
then let <code>range</code> be an expression such that <code>decltype((range))</code>
models <code><del>viewable_range</del><ins>range</ins></code>,
let <code>args...</code> be arguments such that <code>adaptor(range, args...)</code>
is a well-formed expression as specified in the rest of subclause 25.7 <a href="https://wg21.link/range.adaptors">[range.adaptors]</a>,
and let <code>BoundArgs</code> be a pack that denotes <code>decay_t&lt;decltype((args))&gt;...</code>.
The expression <code>adaptor(args...)</code> produces a range adaptor closure object
<code>f</code> that is a perfect forwarding call wrapper (22.10.4 <a href="https://wg21.link/func.require">[func.require]</a>)
with the following properties: [...]
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3958"><a href="#3958">3958</a><sup><a href="https://cplusplus.github.io/LWG/issue3958">(i)</a></sup>. <code>ranges::to</code> should prioritize the "<code>reserve</code>" branch</h3>
<p><b>Section:</b> 25.5.7.2 <a href="https://wg21.link/range.utility.conv.to">[range.utility.conv.to]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-07-17 <b>Last modified:</b> 2024-01-29</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.utility.conv.to">active issues</a> in [range.utility.conv.to].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.utility.conv.to">issues</a> in [range.utility.conv.to].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When the constructed range object has no range version constructor, <code>ranges::to</code> falls into a 
branch designed specifically for C++17-compliant containers, which calls the legacy constructor that 
accepts an iterator pair with <code>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</code>.    
<p/>
However, this kind of initialization may bring some performance issues, because we split the original 
range into pairs of iterators, which may lose information contained in the original range, for example:
</p>
<blockquote><pre>
#include &lt;boost/container/vector.hpp&gt;
#include &lt;sstream&gt;
#include &lt;ranges&gt;

int main() {
  std::istringstream ints("1 2 3 4 5");
  std::ranges::subrange s(std::istream_iterator&lt;int&gt;(ints),
                          std::istream_iterator&lt;int&gt;(),
                          5);
  auto r = std::ranges::to&lt;boost::container::vector&gt;(s); // <span style="color:red;font-weight:bolder">discard size info</span>
}
</pre></blockquote>
<p>
Above, <code>subrange</code> saves the size information of the stream, but <code>ranges::to</code> only extracts 
its iterator pair to create the object, so that the original size information is discarded, resulting in 
unnecessary allocations.
<p/>
I believe we should prefer to use the "<code>reserve</code>" branch here because it is really designed for this situation.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after reflector poll.
"This optimizes exotic cases at the expense of realistic cases."
</p>



<p id="res-3958"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>

<li><p>Modify 25.5.7.2 <a href="https://wg21.link/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
  constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: <code>C</code> is a cv-unqualified class type.
</p>
<p>
-2- <i>Returns</i>: An object of type <code>C</code> constructed from the elements of <code>r</code> in the following manner:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <code>C</code> does not satisfy <code>input_range</code> or <code>convertible_to&lt;range_reference_t&lt;R&gt;, 
range_value_t&lt;C&gt;&gt;</code> is <code>true</code>:</p>
<ol style="list-style-type: none">
<li><p>(2.1.1) &mdash; If <code>constructible_from&lt;C, R, Args...&gt;</code> is <code>true</code>:</p>
<blockquote><code>C(std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</code></blockquote></li>
<li><p>(2.1.2) &mdash; Otherwise, if <code>constructible_from&lt;C, from_range_t, R, Args...&gt;</code> is <code>true</code>:</p>
<blockquote><code>C(from_range, std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</code></blockquote></li>
<li><p><del>(2.1.3) &mdash; Otherwise, if</del></p>
<ol style="list-style-type: none">
<li><p><del>(2.1.3.1) &mdash; <code>common_range&lt;R&gt;</code> is <code>true</code>,</del></p></li>
<li><p><del>(2.1.3.2) &mdash; the <i>qualified-id</i>  
<code>iterator_traits&lt;iterator_t&lt;R&gt;&gt;::iterator_category</code> is valid and denotes a type that models 
<code>derived_from&lt;input_iterator_tag&gt;</code>, and</del></p></li>
<li><p><del>(2.1.3.3) &mdash; <code>constructible_from&lt;C, iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, Args...&gt;</code> 
is <code>true</code>:</del></p>
<blockquote><pre><del>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</del></pre></blockquote></li>
</ol>
</li>
<li><p>(2.1.4) &mdash; Otherwise, if</p>
<ol style="list-style-type: none">
<li><p>(2.1.4.1) &mdash; <code>constructible_from&lt;C, Args...&gt;</code> is <code>true</code>, and</p></li>
<li><p>(2.1.4.2) &mdash; <code><i>container-insertable</i>&lt;C, range_reference_t&lt;R&gt;&gt;</code> is <code>true</code>:</p>
<blockquote><pre>
C c(std::forward&lt;Args&gt;(args)...);
if constexpr (sized_range&lt;R&gt; &amp;&amp; <i>reservable-container</i>&lt;C&gt;)
  c.reserve(static_cast&lt;range_size_t&lt;C&gt;&gt;(ranges::size(r)));
ranges::copy(r, <i>container-inserter</i>&lt;range_reference_t&lt;R&gt;&gt;(c));
</pre></blockquote></li>
</ol>
</li>
<li><p><ins>(?.?.?) &mdash; Otherwise, if</ins></p>
<ol style="list-style-type: none">
<li><p><ins>(?.?.?.?) &mdash; <code>common_range&lt;R&gt;</code> is <code>true</code>,</ins></p></li>
<li><p><ins>(?.?.?.?) &mdash; the <i>qualified-id</i> <code>iterator_traits&lt;iterator_t&lt;R&gt;&gt;::iterator_category</code> 
is valid and denotes a type that models <code>derived_from&lt;input_iterator_tag&gt;</code>, and</ins></p></li>
<li><p><ins>(?.?.?.?) &mdash; <code>constructible_from&lt;C, iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, Args...&gt;</code> 
is <code>true</code>:</ins></p>
<blockquote><pre><ins>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</ins></pre></blockquote></li>
</ol>
</li>
</ol>
</li>
<li><p>(2.2) &mdash; Otherwise, if <code>input_range&lt;range_reference_t&lt;R&gt;&gt;</code> is <code>true</code>:</p>
<blockquote><pre>
to&lt;C&gt;(r | views::transform([](auto&amp;&amp; elem) {
  return to&lt;range_value_t&lt;C&gt;&gt;(std::forward&lt;decltype(elem)&gt;(elem));
}), std::forward&lt;Args&gt;(args)...);
</pre></blockquote></li>
<li><p>(2.3) &mdash; Otherwise, the program is ill-formed.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3980"><a href="#3980">3980</a><sup><a href="https://cplusplus.github.io/LWG/issue3980">(i)</a></sup>. The read exclusive ownership of an atomic read-modify-write operation and whether its read and write are two operations are unclear</h3>
<p><b>Section:</b> 32.5.4 <a href="https://wg21.link/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> jim x <b>Opened:</b> 2023-08-22 <b>Last modified:</b> 2023-11-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Such two questions are sourced from StackOverflow:
</p>
<ol>
<li><p><a href="https://stackoverflow.com/questions/77126045/can-the-read-operations-in-compare-exchange-strong-in-different-two-thread-rea/77126363?noredirect=1#comment135968355_77126363">Can the read operations in <code>compare_exchange_strong</code> in different two thread read the same value?</a></p></li>
<li><p><a href="https://stackoverflow.com/questions/65568185/for-purposes-of-ordering-is-atomic-read-modify-write-one-operation-or-two">For purposes of ordering, is atomic read-modify-write one operation or two?</a></p></li>
</ol>
<p>
Given this example:
</p>
<blockquote>
<pre>
#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;

struct SpinLock{
  std::atomic&lt;bool&gt; atomic_;
  void lock(){
    bool expected = false;
    while (!atomic_.compare_exchange_strong(expected,true,std::memory_order_release,std::memory_order_relaxed)) {
    }
  }
  void unlock(){
    atomic_.store(false, std::memory_order_release);
  }
};

int main(){
  SpinLock spin{false};
  auto t1 = std::thread([&amp;](){
    spin.lock();
    spin.unlock();
  });
  auto t2 = std::thread([&amp;](){
    spin.lock();
    spin.unlock();
  });
  t1.join();
  t2.join();
}
</pre>
</blockquote>
<p>
In the current draft, the relevant phrasing that can interpret that only one read-modify-write operation reads the initial 
value false is 32.5.4 <a href="https://wg21.link/atomics.order">[atomics.order]</a> p10:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
Atomic read-modify-write operations shall always read the last value (in the modification order) written before the write 
associated with the read-modify-write operation.
</p></blockquote>
<p>
However, the wording can have two meanings, each kind of read can result in different explanations for the example
</p>
<ol>
<li><p>The check of the violation is done before the side effect of the RMW is in the modification order, i.e. the rule is 
just checked at the read point.</p></li>
<li><p>The check of the violation is done after the side effect of the RMW is in the modification order, i.e. the rule is 
checked when <code>RMW</code> tries to add the side effect that is based on the read-value to the modification order, and that 
side effect wouldn't be added to the modification order if the rule was violated.</p></li>
</ol>
<p>
With the first interpretation, the two RMW operations can read the same initial value because that value is indeed the last value 
in the modification order before such two RMW operations produce the side effect to the modification order.
<p/>
With the second interpretation, there is only one RMW operation that can read the initial value because the latter one in 
the modification order would violate the rule if it read the initial value.
<p/>
Such two interpretations arise from that the wording doesn't clearly specify when that check is performed.
<p/>
So, my proposed wording is:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
Atomic read-modify-write operations shall always read the value from a side effect <code>X</code>, where <code>X</code> 
immediately precedes the side effect of the read-modify-write operation in the modification order.
</p></blockquote>
<p>
This wording keeps a similar utterance to 6.10.2.2 <a href="https://wg21.link/intro.races">[intro.races]</a>, and it can clearly convey the meaning 
that we say the value read by <code>RWM</code> is associated with the side effect of <code>RMW</code> in the modification order.
<p/>
Relevant discussion can be seen <a href="https://github.com/cplusplus/CWG/issues/423">CWG/issues/423</a> here.
</p>

<p><i>[2023-11-03; Reflector poll]</i></p>

<p>NAD. The first reading isn't plausible. </p>



<p id="res-3980"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages — C++">N4958</a>.
</p>

<ol>

<li><p>Modify 32.5.4 <a href="https://wg21.link/atomics.order">[atomics.order]</a> as indicated:</p>

<blockquote>
<p>
-10- Atomic read-modify-write operations shall always read the <del>last</del> value <ins>from a side effect <i>X</i>, 
where <i>X</i> immediately precedes the side effect of the read-modify-write operation</ins> <del>(</del>in the 
modification order<del>) written before the write associated with the read-modify-write operation</del>.
<p/>
-11- Implementations should make atomic stores visible to atomic loads within a reasonable amount of time.
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3981"><a href="#3981">3981</a><sup><a href="https://cplusplus.github.io/LWG/issue3981">(i)</a></sup>. Range adaptor closure object is underspecified for its return type</h3>
<p><b>Section:</b> 25.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-22 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.adaptor.object">active issues</a> in [range.adaptor.object].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.adaptor.object">issues</a> in [range.adaptor.object].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In order to provide pipe support for user-defined range adaptors, <a href="https://wg21.link/P2387R3" title=" Pipe support for user-defined range adaptors">P2387R3</a> 
removed the specification that the adaptor closure object returns a view, which conforms to the wording of <code>ranges::to</code>.
<p/>
However, the current wording seems to be too low-spec so that the range adaptor closure object can return any type 
or even <code>void</code>. This makes it possible to break the previous specification when returning types that don't make sense, 
<a href="https://godbolt.org/z/Y4nvjY3xj">for example</a>:
</p>
<blockquote>
<pre>
#include &lt;ranges&gt;

struct Closure : std::ranges::range_adaptor_closure&lt;Closure&gt; {
  struct NonCopyable {
    NonCopyable(const NonCopyable&amp;) = delete;
  };

  const NonCopyable&amp; operator()(std::ranges::range auto&amp;&amp;);
};

auto r = std::views::iota(0) | Closure{}; // <span style="color:red;font-weight:bolder">hard error in libstdc++ and MSVC-STL</span>
</pre></blockquote>
<p>
Above, since the return type of the pipeline operator is declared as <code>auto</code>, this causes the deleted 
copy constructor to be invoked in the function body and produces a hard error.
<p/>
The proposed resolution adds a specification for the range adaptor closure object to return a <i>cv</i>-unqualified class type.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD.
"The wording says <code>R | C</code> is equivalent to <code>C(R)</code>,
not <code>auto(C(R))</code>."
</p>



<p id="res-3981"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages — C++">N4958</a>.
</p>

<ol>

<li><p>Modify 25.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> as indicated:</p>

<blockquote>
<p>
-1- A <i>range adaptor closure object</i> is a unary function object that accepts a range argument. For a range adaptor
closure object <code>C</code> and an expression <code>R</code> such that <code>decltype((R))</code> models <code>range</code>, the 
following expressions are equivalent:
</p>
<p>[&hellip;]</p>
<p>
-2- Given an object <code>t</code> of type <code>T</code>, where
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <code>t</code> is a unary function object that accepts a range argument <ins>and returns a 
<i>cv</i>-unqualified class object</ins>,</p></li>
<li><p>[&hellip;]</p></li>
</ol>
<p>
then the implementation ensures that <code>t</code> is a range adaptor closure object.
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3982"><a href="#3982">3982</a><sup><a href="https://cplusplus.github.io/LWG/issue3982">(i)</a></sup>. <code><i>is-derived-from-view-interface</i></code> should require that <code>T</code> is derived from <code>view_interface&lt;T&gt;</code></h3>
<p><b>Section:</b> 25.4.5 <a href="https://wg21.link/range.view">[range.view]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-22 <b>Last modified:</b> 2023-10-30</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.view">issues</a> in [range.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the wording of <code><i>is-derived-from-view-interface</i></code> only detects whether type <code>T</code> is unambiguously 
derived from one base class <code>view_interface&lt;U&gt;</code> where <code>U</code> is not required to be <code>T</code>, which is not 
the intention of CRTP.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>Set status to Tentatively NAD.
The wording correctly handles the case where T derives from <code>Base</code>
which derives from <code>view_interface&lt;Base&gt;</code>.
We don't want it to only be satisfied for direct inheritance from
<code>view_interface&lt;T&gt;</code>, but from any specialization of
<code>view_interface</code>.
Previously the concept only checked for inheritance from <code>view_base</code>
but it was changed when <code>view_interface</code> stopped inheriting from
<code>view_base</code>.
</p>



<p id="res-3982"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages — C++">N4958</a>.
</p>

<ol>

<li><p>Modify 25.4.5 <a href="https://wg21.link/range.view">[range.view]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr bool <i>is-derived-from-view-interface</i> = <i>see below</i>;            // exposition only
template&lt;class T&gt;
  constexpr bool enable_view =
    derived_from&lt;T, view_base&gt; || <i>is-derived-from-view-interface</i>&lt;T&gt;;
</pre>
<blockquote>
<p>
-6- For a type <code>T</code>, <code><i>is-derived-from-view-interface</i>&lt;T&gt;</code>
is <code>true</code> if and only if <code>T</code> has exactly one public base class
<code>view_interface&lt;<ins>T</ins><del>U</del>&gt;</code> <del>for some type <code>U</code></del> and
<code>T</code> has no base classes of type <code>view_interface&lt;<ins>U</ins><del>V</del>&gt;</code> for any
other type <code><ins>U</ins><del>V</del></code>.
<p/>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4003"><a href="#4003">4003</a><sup><a href="https://cplusplus.github.io/LWG/issue4003">(i)</a></sup>. <code>view_interface::back</code> is overconstrained</h3>
<p><b>Section:</b> 25.5.3 <a href="https://wg21.link/view.interface">[view.interface]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-10-28 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#view.interface">issues</a> in [view.interface].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code>view_interface</code> only provides the <code>back</code> member when the derived class satisfies both 
<code>bidirectional_range</code> and <code>common_range</code>, which ensures that <code>ranges::prev</code> can act its sentinel.
<p/>
However, requiring <code>common_range</code> seems to be too strict because when the derived class satisfies both 
<code>random_access_range</code> and <code>sized_range</code>, its end iterator can still be calculated in constant time, 
which is what some range adaptors currently do to greedily become common ranges.
<p/>
I think we should follow similar rules to eliminate this inconsistency (<a href="https://godbolt.org/z/1oEf58Krh">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;

constexpr auto r = std::ranges::subrange(std::views::iota(0), 5);
constexpr auto z = std::views::zip(r);
static_assert(r.back() == 4); // <span style="color:red;font-weight:bolder">ill-formed</span>
static_assert(std::get&lt;0&gt;(z.back()) == 4); // ok
</pre></blockquote>

<p><i>[2023-11-07; Reflector poll]</i></p>

<p>NAD. "During the <code>concat</code> discussion LEWG decided not to
support the corner case of random-access sized but not-common ranges."
"If we did want to address such ranges, would be better to enforce commonness
for random-access sized ranges by having <code>ranges::end</code> return
<code>ranges::begin(r) + ranges::size(r)</code>."
</p>


<p id="res-4003"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages — C++">N4964</a>.
</p>

<ol>

<li><p>Modify 25.5.3 <a href="https://wg21.link/view.interface">[view.interface]</a>, class template <code>view_interface</code> synopsis, as indicated:</p>

<blockquote><pre>
namespace std::ranges {
  template&lt;class D&gt;
    requires is_class_v&lt;D&gt; &amp;&amp; same_as&lt;D, remove_cv_t&lt;D&gt;&gt;
  class view_interface {
    [&hellip;]
  public:
    [&hellip;]
    constexpr decltype(auto) back() requires <ins>(</ins>bidirectional_range&lt;D&gt; &amp;&amp; common_range&lt;D&gt;<ins>) ||</ins>
                                             <ins>(random_access_range&lt;D&gt; &amp;&amp; sized_range&lt;D&gt;)</ins>;
    constexpr decltype(auto) back() const
      requires <ins>(</ins>bidirectional_range&lt;const D&gt; &amp;&amp; common_range&lt;const D&gt;<ins>) ||</ins>
               <ins>(random_access_range&lt;const D&gt; &amp;&amp; sized_range&lt;const D&gt;)</ins>;
    [&hellip;]
  };
}
</pre></blockquote>

</li>

<li><p>Modify 25.5.3.2 <a href="https://wg21.link/view.interface.members">[view.interface.members]</a> as indicated:</p>

<blockquote>
<pre>
constexpr decltype(auto) back() requires <ins>(</ins>bidirectional_range&lt;D&gt; &amp;&amp; common_range&lt;D&gt;<ins>) ||</ins>
                                         <ins>(random_access_range&lt;D&gt; &amp;&amp; sized_range&lt;D&gt;)</ins>;
constexpr decltype(auto) back() const
  requires <ins>(</ins>bidirectional_range&lt;const D&gt; &amp;&amp; common_range&lt;const D&gt;<ins>) ||</ins>
           <ins>(random_access_range&lt;const D&gt; &amp;&amp; sized_range&lt;const D&gt;)</ins>;
</pre>
<blockquote>
<p>
-3- <i>Preconditions</i>: <code>!empty()</code> is <code>true</code>.
<p/>
-4- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
<ins>auto <i>common-arg-end</i> = []&lt;class R&gt;(R&amp; r) {
  if constexpr (common_range&lt;R&gt;) {
    return ranges::end(r);
  } else {
    return ranges::begin(r) + ranges::distance(r);
  }
};</ins>
return *ranges::prev(<ins><i>common-arg-end</i></ins><del>ranges::end</del>(<i>derived</i>()));
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4006"><a href="#4006">4006</a><sup><a href="https://cplusplus.github.io/LWG/issue4006">(i)</a></sup>. <code>chunk_view::<i>outer-iterator</i>::value_type</code> should provide <code>empty</code></h3>
<p><b>Section:</b> 25.7.29.4 <a href="https://wg21.link/range.chunk.outer.value">[range.chunk.outer.value]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-11-05 <b>Last modified:</b> 2024-03-11</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.chunk.outer.value">issues</a> in [range.chunk.outer.value].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>chunk_view::<i>outer-iterator</i>::value_type</code> can determine whether it is empty by simply checking whether the 
<code>chunk_view</code>'s <code><i>remainder_</i></code> is <code>0</code>, which makes it valuable to explicitly provide a 
<code>noexcept empty</code> member.
<p/>
Otherwise, the <code>view_interface::empty</code> is synthesized only through the <code>size</code> member when the original 
sentinel and iterator type model <code>sized_sentinel_for</code>, <a href="https://godbolt.org/z/v3MbzfT9G">which seems overkill</a>:
</p>
<blockquote><pre>
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;ranges&gt;

int main() {
  auto ints = std::istringstream{"1 2 3 4 5 6 7 8 9 10"};
  for (auto chunk : std::views::istream&lt;int&gt;(ints) | std::views::chunk(3)) {
    for (auto elem : chunk) {
      assert(!chunk.empty()); // <span style="color:red;font-weight:bolder">no matching function for call to 'empty()'</span>
      std::cout &lt;&lt; elem &lt;&lt; " ";
    }
    assert(chunk.empty()); // <span style="color:red;font-weight:bolder">ditto</span>
    std::cout &lt;&lt; "\n";
  }
}
</pre></blockquote>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after reflector poll in November 2023.
</p>
<p>
"The example shows you could use it if it existed, but not why that would be useful."
</p>
<p>
"This is a bad idea - the fact that the chunk 'shrinks' as it is iterated over
is an implementation detail and not supposed to be observable."
</p>



<p id="res-4006"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages — C++">N4964</a>.
</p>

<ol>

<li><p>Modify 25.7.29.4 <a href="https://wg21.link/range.chunk.outer.value">[range.chunk.outer.value]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
  namespace std::ranges {
    template&lt;view V&gt;
      requires input_range&lt;V&gt;
    struct chunk_view&lt;V&gt;::<i>outer-iterator</i>::value_type : view_interface&lt;value_type&gt; {
    private:
      chunk_view* <i>parent_</i>;                                        // <i>exposition only</i>

      constexpr explicit value_type(chunk_view&amp; parent);          // <i>exposition only</i>

    public:
      constexpr <i>inner-iterator</i> begin() const noexcept;
      constexpr default_sentinel_t end() const noexcept;

      <ins>constexpr bool empty() const noexcept;</ins>
      constexpr auto size() const
        requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
    };
  }
</pre>
</blockquote>
[&hellip;]
<pre>
constexpr default_sentinel_t end() const noexcept;
</pre>
<blockquote>
<p>
-3- <i>Returns</i>: <code>default_sentinel</code>.
</p>
</blockquote>
<pre>
<ins>constexpr bool empty() const noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Equivalent to: <code>return <i>parent_</i>-&gt;<i>remainder_</i> == 0;</code></ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4020"><a href="#4020">4020</a><sup><a href="https://cplusplus.github.io/LWG/issue4020">(i)</a></sup>. <code>extents::<i>index-cast</i></code> weirdness</h3>
<p><b>Section:</b> 23.7.3.3.2 <a href="https://wg21.link/mdspan.extents.expo">[mdspan.extents.expo]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2023-11-29 <b>Last modified:</b> 2025-10-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The exposition-only static member <code><i>index-cast</i></code> of <code>extents</code> is specified as 
(23.7.3.3.2 <a href="https://wg21.link/mdspan.extents.expo">[mdspan.extents.expo]</a>/9):
</p>
<blockquote>
<pre>
template&lt;class OtherIndexType&gt;
static constexpr auto <i>index-cast</i>(OtherIndexType&amp;&amp; i) noexcept;
</pre>
<blockquote>
<p>
-9- <i>Effects</i>:
</p>
<ol style="list-style-type: none">
<li><p>(9.1) &mdash; If <code>OtherIndexType</code> is an integral type other than <code>bool</code>, then equivalent 
to <code>return i;</code>,</p></li>
<li><p>(9.2) &mdash; otherwise, equivalent to <code>return static_cast&lt;index_type&gt;(i);</code>.</p></li>
</ol>
<p>
[<i>Note 1</i>: This function will always return an integral type other than <code>bool</code>. Since this function's 
call sites are constrained on convertibility of <code>OtherIndexType</code> to <code>index_type</code>, integer-class types 
can use the <code>static_cast</code> branch without loss of precision. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
<p>
This function returns <code>T</code> when passed an rvalue of <i>cv</i>-unqualified integral type <code>T</code>, 
but <code>index_type</code> when passed a <i>cv</i>-qualified and/or lvalue argument of any integral type. It 
would seem more consistent and easier to reason about if 9.1 was instead conditional on 
<code>remove_cvref_t&lt;OtherIndexType&gt;</code>.
</p>

<p><i>[2025-10-17; Reflector poll.]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>
<p>
"Doesn't matter in this case, but logically <code class='backtick'>decay_t</code> seems like a better fit."
</p>


<p id="res-4020"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages — C++">N4964</a>.
</p>

<ol>

<li><p>Modify 23.7.3.3.2 <a href="https://wg21.link/mdspan.extents.expo">[mdspan.extents.expo]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherIndexType&gt;
  static constexpr auto <i>index-cast</i>(OtherIndexType&amp;&amp; i) noexcept;
</pre>
<blockquote>
<p>
-9- <i>Effects</i>:
</p>
<ol style="list-style-type: none">
<li><p>(9.1) &mdash; If <code><ins>remove_cvref_t&lt;</ins>OtherIndexType<ins>&gt;</ins></code> 
is an integral type other than <code>bool</code>, then equivalent to <code>return i;</code>,</p></li>
<li><p>(9.2) &mdash; otherwise, equivalent to <code>return static_cast&lt;index_type&gt;(i);</code>.</p></li>
</ol>
<p>
[<i>Note 1</i>: This function will always return an integral type other than <code>bool</code>. Since this function's 
call sites are constrained on convertibility of <code>OtherIndexType</code> to <code>index_type</code>, integer-class types 
can use the <code>static_cast</code> branch without loss of precision. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4095"><a href="#4095">4095</a><sup><a href="https://cplusplus.github.io/LWG/issue4095">(i)</a></sup>. <code>ranges::fold_<i>meow</i></code> should explicitly spell out the return type</h3>
<p><b>Section:</b> 26.4 <a href="https://wg21.link/algorithm.syn">[algorithm.syn]</a>, 26.6.18 <a href="https://wg21.link/alg.fold">[alg.fold]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-05-03 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithm.syn">active issues</a> in [algorithm.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithm.syn">issues</a> in [algorithm.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unlike other algorithms, the return types of <code>ranges::fold_<i>meow</i></code> are specified in terms of
<code>auto</code> and <code><i>see below</i></code>, and its implementation details depend on the return types of 
other overloads through <code>decltype(fold_<i>meow</i>(...))</code>.
<p/>
This makes determining the return type of a certain overload (such as <code>fold_right_last</code>) 
extremely difficult even for experts, requiring several trips back and forth to different overloads 
to finally understand what the actual return type is. The situation is even worse for newbies because 
such a form of specifying the return type makes it impossible for the IDE to deduce the real return type, 
which is extremely user-unfriendly.
<p/>
I think that explicitly specifying the return type for these overloads not only greatly improves 
readability but also offloads the compiler from deducing the return type, which can definitely be 
considered an improvement.
<p/>
The proposed resolution does not touch the <i>Effects</i> clause and only changes the function signature 
to seek minimal changes.
</p>

<p><i>[2024-06-24; Reflector poll: NAD]</i></p>

<p>Implementations are free to spell this out if desired.</p>



<p id="res-4095"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages — C++">N4981</a>.
</p>

<ol>

<li><p>Modify 26.4 <a href="https://wg21.link/algorithm.syn">[algorithm.syn]</a>, header <code>&lt;algorithm&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
#include &lt;initializer_list&gt;     // <i>see 17.11.2 <a href="https://wg21.link/initializer.list.syn">[initializer.list.syn]</a></i>

namespace std {
  [&hellip;]
  namespace ranges {
    [&hellip;]
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T = iter_value_t&lt;I&gt;,
             <i>indirectly-binary-left-foldable</i>&lt;T, I&gt; F&gt;
      constexpr auto fold_left(I first, S last, T init, F f) <ins>-&gt;
        decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;</ins>;

    template&lt;input_range R, class T = range_value_t&lt;R&gt;,
             <i>indirectly-binary-left-foldable</i>&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
      constexpr auto fold_left(R&amp;&amp; r, T init, F f) <ins>-&gt;
        decay_t&lt;invoke_result_t&lt;F&amp;, T, range_reference_t&lt;R&gt;&gt;&gt;</ins>;

    template&lt;input_iterator I, sentinel_for&lt;I&gt; S,
             <i>indirectly-binary-left-foldable</i>&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
      requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
      constexpr auto fold_left_first(I first, S last, F f) <ins>-&gt;
        optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;&gt;&gt;</ins>;

    template&lt;input_range R, <i>indirectly-binary-left-foldable</i>&lt;range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; F&gt;
      requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
      constexpr auto fold_left_first(R&amp;&amp; r, F f) <ins>-&gt;
        optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;&gt;&gt;</ins>;

    template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S, class T = iter_value_t&lt;I&gt;,
             <i>indirectly-binary-right-foldable</i>&lt;T, I&gt; F&gt;
      constexpr auto fold_right(I first, S last, T init, F f) <ins>-&gt;
        decay_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt;&gt;</ins>;

    template&lt;bidirectional_range R, class T = range_value_t&lt;R&gt;,
             <i>indirectly-binary-right-foldable</i>&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
      constexpr auto fold_right(R&amp;&amp; r, T init, F f) <ins>-&gt;
        decay_t&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;R&gt;, T&gt;&gt;</ins>;

    template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S,
             <i>indirectly-binary-right-foldable</i>&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
      requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
    constexpr auto fold_right_last(I first, S last, F f) <ins>-&gt;
      optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, iter_value_t&lt;I&gt;&gt;&gt;&gt;</ins>;

    template&lt;bidirectional_range R,
             <i>indirectly-binary-right-foldable</i>&lt;range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; F&gt;
      requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
    constexpr auto fold_right_last(R&amp;&amp; r, F f) <ins>-&gt;
      optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;R&gt;, range_value_t&lt;R&gt;&gt;&gt;&gt;</ins>;

    template&lt;class I, class T&gt;
      using fold_left_with_iter_result = in_value_result&lt;I, T&gt;;
    template&lt;class I, class T&gt;
      using fold_left_first_with_iter_result = in_value_result&lt;I, T&gt;;

    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T = iter_value_t&lt;I&gt;,
             <i>indirectly-binary-left-foldable</i>&lt;T, I&gt; F&gt;
      constexpr <del><i>see below</i></del><ins>auto</ins> fold_left_with_iter(I first, S last, T init, F f) <ins>-&gt;
        fold_left_with_iter_result&lt;I, decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt;</ins>;

    template&lt;input_range R, class T = range_value_t&lt;R&gt;,
             <i>indirectly-binary-left-foldable</i>&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
      constexpr <del><i>see below</i></del><ins>auto</ins> fold_left_with_iter(R&amp;&amp; r, T init, F f) <ins>-&gt;
        fold_left_with_iter_result&lt;borrowed_iterator_t&lt;R&gt;,
                                   decay_t&lt;invoke_result_t&lt;F&amp;, T, range_reference_t&lt;R&gt;&gt;&gt;&gt;</ins>;

    template&lt;input_iterator I, sentinel_for&lt;I&gt; S,
             <i>indirectly-binary-left-foldable</i>&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
      requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
      constexpr <del><i>see below</i></del><ins>auto</ins> fold_left_first_with_iter(I first, S last, F f) <ins>-&gt;
        fold_left_first_with_iter_result&lt;
          I, optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;&gt;&gt;&gt;</ins>;

    template&lt;input_range R,
             <i>indirectly-binary-left-foldable</i>&lt;range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; F&gt;
      requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
      constexpr <del><i>see below</i></del><ins>auto</ins> fold_left_first_with_iter(R&amp;&amp; r, F f) <ins>-&gt;
        fold_left_first_with_iter_result&lt;
          borrowed_iterator_t&lt;R&gt;,
          optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;&gt;&gt;&gt;</ins>;
  }
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 26.6.18 <a href="https://wg21.link/alg.fold">[alg.fold]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T = iter_value_t&lt;I&gt;,
         <i>indirectly-binary-left-foldable</i>&lt;T, I&gt; F&gt;
constexpr auto ranges::fold_left(I first, S last, T init, F f) <ins>-&gt;
  decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;</ins>;

template&lt;input_range R, class T = range_value_t&lt;R&gt;,
         <i>indirectly-binary-left-foldable</i>&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
constexpr auto ranges::fold_left(R&amp;&amp; r, T init, F f) <ins>-&gt;
  decay_t&lt;invoke_result_t&lt;F&amp;, T, range_reference_t&lt;R&gt;&gt;&gt;</ins>;
</pre>
<blockquote>
<p>
-1- <i>Returns</i>:
</p>
<blockquote><pre>
ranges::fold_left_with_iter(std::move(first), last, std::move(init), f).value
</pre></blockquote>
</blockquote>
<pre>
template&lt;input_iterator I, sentinel_for&lt;I&gt; S,
         <i>indirectly-binary-left-foldable</i>&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
  requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
  constexpr auto ranges::fold_left_first(I first, S last, F f) <ins>-&gt;
    optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;&gt;&gt;</ins>;

template&lt;input_range R, <i>indirectly-binary-left-foldable</i>&lt;range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; F&gt;
  requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
  constexpr auto ranges::fold_left_first(R&amp;&amp; r, F f) <ins>-&gt;
    optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;&gt;&gt;</ins>;
</pre>
<blockquote>
<p>
-2- <i>Returns</i>:
</p>
<blockquote><pre>
ranges::fold_left_first_with_iter(std::move(first), last, f).value
</pre></blockquote>
</blockquote>
<pre>
template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S, class T = iter_value_t&lt;I&gt;,
         <i>indirectly-binary-right-foldable</i>&lt;T, I&gt; F&gt;
  constexpr auto ranges::fold_right(I first, S last, T init, F f) <ins>-&gt;
    decay_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt;&gt;</ins>;

template&lt;bidirectional_range R, class T = range_value_t&lt;R&gt;,
        <i>indirectly-binary-right-foldable</i>&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
  constexpr auto ranges::fold_right(R&amp;&amp; r, T init, F f) <ins>-&gt;
    decay_t&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;R&gt;, T&gt;&gt;</ins>;  
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
using U = decay_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt;&gt;;
if (first == last)
  return U(std::move(init));
I tail = ranges::next(first, last);
U accum = invoke(f, *--tail, std::move(init));
while (first != tail)
  accum = invoke(f, *--tail, std::move(accum));
return accum;
</pre></blockquote>
</blockquote>
<pre>
template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S,
        <i>indirectly-binary-right-foldable</i>&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
  requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
constexpr auto ranges::fold_right_last(I first, S last, F f) <ins>-&gt;
  optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, iter_value_t&lt;I&gt;&gt;&gt;&gt;</ins>;

template&lt;bidirectional_range R,
         <i>indirectly-binary-right-foldable</i>&lt;range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; F&gt;
 requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
constexpr auto ranges::fold_right_last(R&amp;&amp; r, F f) <ins>-&gt;
  optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;R&gt;, range_value_t&lt;R&gt;&gt;&gt;&gt;</ins>;
</pre>
<blockquote>
<p>
-4- Let <code>U</code> be <code>decltype(ranges::fold_right(first, last, iter_value_t&lt;I&gt;(*first), f))</code>.
<p/>
-5- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (first == last)
  return optional&lt;U&gt;();
I tail = ranges::prev(ranges::next(first, std::move(last)));
return optional&lt;U&gt;(in_place,
  ranges::fold_right(std::move(first), tail, iter_value_t&lt;I&gt;(*tail), std::move(f)));
</pre></blockquote>
</blockquote>
<pre>
template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T = iter_value_t&lt;I&gt;,
         <i>indirectly-binary-left-foldable</i>&lt;T, I&gt; F&gt;
  constexpr <del><i>see below</i></del><ins>auto</ins> ranges::fold_left_with_iter(I first, S last, T init, F f) <ins>-&gt;
    fold_left_with_iter_result&lt;I, decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt;</ins>;

template&lt;input_range R, class T = range_value_t&lt;R&gt;,
         <i>indirectly-binary-left-foldable</i>&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
  constexpr <del><i>see below</i></del><ins>auto</ins> ranges::fold_left_with_iter(R&amp;&amp; r, T init, F f) <ins>-&gt;
    fold_left_with_iter_result&lt;borrowed_iterator_t&lt;R&gt;,
                               decay_t&lt;invoke_result_t&lt;F&amp;, T, range_reference_t&lt;R&gt;&gt;&gt;&gt;</ins>;
</pre>
<blockquote>
<p>
-6- Let <code>U</code> be <code>decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;</code>.
<p/>
-7- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (first == last)
  return {std::move(first), U(std::move(init))};
U accum = invoke(f, std::move(init), *first);
for (++first; first != last; ++first)
  accum = invoke(f, std::move(accum), *first);
return {std::move(first), std::move(accum)};
</pre></blockquote>
<p>
<del>-8- <i>Remarks</i>: The return type is <code>fold_left_with_iter_result&lt;I, U&gt;</code>
for the first overload and <code>fold_left_with_iter_result&lt;borrowed_iterator_t&lt;R&gt;, U&gt;</code> 
for the second overload.</del>
</p>
</blockquote>
<pre>
template&lt;input_iterator I, sentinel_for&lt;I&gt; S,
         <i>indirectly-binary-left-foldable</i>&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
  requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
  constexpr <del><i>see below</i></del><ins>auto</ins> ranges::fold_left_first_with_iter(I first, S last, F f) <ins>-&gt;
    fold_left_first_with_iter_result&lt;
      I, optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;&gt;&gt;&gt;</ins>;

template&lt;input_range R,
         <i>indirectly-binary-left-foldable</i>&lt;range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; F&gt;
  requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
  constexpr <del><i>see below</i></del><ins>auto</ins> ranges::fold_left_first_with_iter(R&amp;&amp; r, F f) <ins>-&gt;
    fold_left_first_with_iter_result&lt;
      borrowed_iterator_t&lt;R&gt;,
      optional&lt;decay_t&lt;invoke_result_t&lt;F&amp;, range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;&gt;&gt;&gt;</ins>;
</pre>
<blockquote>
<p>
-9- Let <code>U</code> be
</p>
<blockquote><pre>
decltype(ranges::fold_left(std::move(first), last, iter_value_t&lt;I&gt;(*first), f))
</pre></blockquote>
<p>
-10- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (first == last)
  return {std::move(first), optional&lt;U&gt;()};
optional&lt;U&gt; init(in_place, *first);
for (++first; first != last; ++first)
  *init = invoke(f, std::move(*init), *first);
return {std::move(first), std::move(init)};
</pre></blockquote>
<p>
<del>-11- <i>Remarks</i>: The return type is <code>fold_left_first_with_iter_result&lt;I, optional&lt;U&gt;&gt;</code>
for the first overload and <code>fold_left_first_with_iter_result&lt;borrowed_iterator_t&lt;R&gt;,
  optional&lt;U&gt;&gt;</code> for the second overload.</del>
</p>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3 id="4163"><a href="#4163">4163</a><sup><a href="https://cplusplus.github.io/LWG/issue4163">(i)</a></sup>. Can the overload of <code>std::num_get::do_get</code> for <code>bool</code> call the overload for <code>long</code>?</h3>
<p><b>Section:</b> 28.3.4.3.2.3 <a href="https://wg21.link/facet.num.get.virtuals">[facet.num.get.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-09-29 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.3.4.3.2.3 <a href="https://wg21.link/facet.num.get.virtuals">[facet.num.get.virtuals]</a>/6 currently says:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<i>Effects</i>: If <code>(str.flags()&amp;ios_base::boolalpha) == 0</code> then input proceeds as it would for a 
<code>long</code> except that if a value is being stored into <code>val</code>, [&hellip;]
</p>
</blockquote>
<p>
It is unclear whether an implementation is allowed to call the overload for <code>long</code> in this case. 
Currently, libc++'s version calls that overload, while libstdc++ and MSVC STL's don't 
(<a href="https://godbolt.org/z/83M1hKThv">example</a>).
<p/>
As the divergence implementation strategies is observable, perhaps we should clarify on this.
</p>

<p><i>[2025-02-07; Reflector poll: NAD]</i></p>

<p>
I think this is just a libc++ bug.
The wording says it "proceeds as it would for <code class='backtick'>long</code>", which is not the same as
actually making a virtual call to <code class='backtick'>do_get</code> for <code class='backtick'>long</code>. It can either duplicate
the code from <code class='backtick'>do_get</code> for <code class='backtick'>long</code>, or make a non-virtual (i.e. qualified) call
to <code class='backtick'>num_get::do_get</code>.
</p>



<p id="res-4163"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4184"><a href="#4184">4184</a><sup><a href="https://cplusplus.github.io/LWG/issue4184">(i)</a></sup>. Domain of <code>ranges::c<i>meow</i></code> doesn't match <code>ranges::<i>meow</i></code></h3>
<p><b>Section:</b> 25.3 <a href="https://wg21.link/range.access">[range.access]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-12-17 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>ranges::begin/rbegin/data</code> can be used on non-ranges as long as the object has a
<code class='backtick'>begin/rbegin/data</code> member, this is also true for their const versions before C++23.
<p/>
However, in C++23 the const version always applied <code><i>possibly-const-range</i></code> to the object,
which no longer worked for non-ranges due to this function requiring <code class='backtick'>input_range</code>, 
which seems to be a breaking change (<a href="https://godbolt.org/z/KKe4nG9W8">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;

struct NotRange {
        int* begin();
  const int* begin() const;
        int* rbegin();
  const int* rbegin() const;
        int* data();
  const int* data() const;
};

int main() {
  NotRange r;

  (void) std::ranges::begin(r);
  (void) std::ranges::rbegin(r);
  (void) std::ranges::data(r);

  // <span  style="color:#C80000;font-weight:bold">The following works in C++20, fails in C++23</span>
  (void) std::ranges::cbegin(r);
  (void) std::ranges::crbegin(r);
  (void) std::ranges::cdata(r);
}
</pre></blockquote>

<p><i>[2025-02-07; Reflector poll: NAD]</i></p>

<p>
"We don't need to support <code class='backtick'>ranges::cbegin</code> on non-ranges."
</p>
<p>
"Seems to be very similar to LWG <a href="lwg-closed.html#3913" title="ranges::const_iterator_t&lt;range R&gt; fails to accept arrays of unknown bound (Status: NAD)">3913</a><sup><a href="https://cplusplus.github.io/LWG/issue3913" title="Latest snapshot">(i)</a></sup> which LWG closed as NAD."
</p>



<p id="res-4184"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4194"><a href="#4194">4194</a><sup><a href="https://cplusplus.github.io/LWG/issue4194">(i)</a></sup>. <code>atomic&lt;void*&gt;</code> should use generic class template</h3>
<p><b>Section:</b> 32.5.8.5 <a href="https://wg21.link/atomics.types.pointer">[atomics.types.pointer]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Gonzalo Brito <b>Opened:</b> 2025-01-16 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.pointer">active issues</a> in [atomics.types.pointer].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.pointer">issues</a> in [atomics.types.pointer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
32.5.8.5 <a href="https://wg21.link/atomics.types.pointer">[atomics.types.pointer]</a> p1 states (emphasis mine):
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
There is a partial specialization of the <code class='backtick'>atomic</code> class template for <b>pointers</b>.
</p>
</blockquote>
<p>
which requires <code>atomic&lt;void*&gt;</code> to use the <code class='backtick'>atomic</code> class template for pointers.
However, the <code class='backtick'>fetch_add</code>/<code class='backtick'>_sub</code> member functions add a <code class='backtick'>difference_type</code> to a <code class='backtick'>T*</code> 
which requires a pointer-to-object type (these member functions are <code class='backtick'>constexpr</code>, 
so trying to support this seems unimplementable).
<p/>
For <code class='backtick'>atomic_ref</code>, the 32.5.7.5 <a href="https://wg21.link/atomics.ref.pointer">[atomics.ref.pointer]</a> p1 states (emphasis mine):
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
There are specializations of the <code class='backtick'>atomic_ref</code>`  class template for all <b>pointer-to-object types</b>.
</p>
</blockquote>
<p>
which avoids this issue and applying the same form to 32.5.8.5 <a href="https://wg21.link/atomics.types.pointer">[atomics.types.pointer]</a> would make 
<code>atomic&lt;void*&gt;</code> and <code>atomic_ref&lt;void*&gt;</code> consistent.
<p/>
Technically this would be a breaking change, but all C++ standard library implementations surveyed are broken, 
and the proposed fix would make them compliant: see libstdc++, libc++ and MSVC STL errors 
<a href="https://godbolt.org/z/dso3P6fKf">here</a>. These standard libraries require a 
pointer-to-object type, <code>atomic&lt;void*&gt;</code> uses the general template. Therefore, no user 
code seems to be impacted.
</p>

<p><i>[2025-02-07; Reflector poll: NAD]</i></p>

<p>
The <code class='backtick'>fetch_OP</code> members have "<i>Mandates</i>: <code class='backtick'>T</code> is a complete object type."
and a note explaining that this means arithmetic on <code class='backtick'>void*</code> is ill-formed.
So implementations are expected to use the partial specialization for <code class='backtick'>void*</code>
but to reject attempts at arithmetic. They all do this correctly today.
</p>


<p id="res-4194"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages — C++">N5001</a>.
</p>

<ol>

<li><p>Modify 32.5.8.5 <a href="https://wg21.link/atomics.types.pointer">[atomics.types.pointer]</a> as indicated:</p>

<blockquote><p>
-1- There is a partial specialization of the <code class='backtick'>atomic</code> class template for 
<del>pointers</del><ins>pointer-to-object types</ins>. Specializations of this partial
specialization are standard-layout structs. They each have a trivial destructor.
</p></blockquote>
</li>

</ol>





<hr>
<h3 id="4228"><a href="#4228">4228</a><sup><a href="https://cplusplus.github.io/LWG/issue4228">(i)</a></sup>. Does <code>vector&lt;bool, Allocator&gt;</code> mandate that <code class='backtick'>Allocator::value_type</code> is <code class='backtick'>bool</code>?</h3>
<p><b>Section:</b> 23.3.14.1 <a href="https://wg21.link/vector.bool.pspc">[vector.bool.pspc]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2025-03-18 <b>Last modified:</b> 2025-06-13</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.bool.pspc">issues</a> in [vector.bool.pspc].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages — C++">N5008</a> 23.3.14.1 <a href="https://wg21.link/vector.bool.pspc">[vector.bool.pspc]</a>/2 says:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
Unless described below, all operations have the same requirements and semantics as the primary <code class='backtick'>vector</code> template, 
except that operations dealing with the <code class='backtick'>bool</code> value type map to bit values in the container storage and 
<code class='backtick'>allocator_traits::construct</code> (20.2.9.3 <a href="https://wg21.link/allocator.traits.members">[allocator.traits.members]</a>) is not used to construct these values.
</p>
</blockquote>
<p>
23.2.2.5 <a href="https://wg21.link/container.alloc.reqmts">[container.alloc.reqmts]</a>/5 says:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<i>Mandates</i>: <code class='backtick'>allocator_type::value_type</code> is the same as <code class='backtick'>X::value_type</code>.
</p>
</blockquote>
<p>
Is <code>vector&lt;bool, allocator&lt;int&gt;&gt;</code> forbidden? There's implementation divergence: 
MSVC's STL enforces the mandate, while libc++ and libstdc++ accept this code, discovered while 
running libc++'s tests with MSVC's STL.
<p/>
Preferred resolution: I would be satisfied with resolving this as NAD, with a record that LWG believes 
that "all operations have the same requirements" means that the <i>Mandate</i> applies. I suppose that 
an editorial note could also be added to this effect, although I don't believe it's necessary.
<p/>
Alternate resolution: If LWG believes that the <i>Mandate</i> does not apply, and that <code>vector&lt;bool&gt;</code> 
should be unique among containers in accepting <code>allocator&lt;Anything&gt;</code>, then I believe that 
a normative sentence should be added to 23.3.14.1 <a href="https://wg21.link/vector.bool.pspc">[vector.bool.pspc]</a>/2, specifically creating an exemption 
to 23.2.2.5 <a href="https://wg21.link/container.alloc.reqmts">[container.alloc.reqmts]</a>/5.
</p>

<p><i>[2025-06-13; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD. This is just a bug in some implementations
(now fixed in libstdc++).
</p>



<p id="res-4228"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4246"><a href="#4246">4246</a><sup><a href="https://cplusplus.github.io/LWG/issue4246">(i)</a></sup>. Redundant constraint in <code class='backtick'>range_formatter::format</code></h3>
<p><b>Section:</b> 28.5.7.2 <a href="https://wg21.link/format.range.formatter">[format.range.formatter]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-04-18 <b>Last modified:</b> 2025-06-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#format.range.formatter">issues</a> in [format.range.formatter].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the signature of <code class='backtick'>range_formatter::format</code> is as follows:
</p>
<blockquote><pre>
template&lt;ranges::input_range R, class FormatContext&gt;
  requires formattable&lt;ranges::range_reference_t&lt;R&gt;, charT&gt; &amp;&amp;
           same_as&lt;remove_cvref_t&lt;ranges::range_reference_t&lt;R&gt;&gt;, T&gt;
typename FormatContext::iterator
  format(R&amp;&amp; r, FormatContext&amp; ctx) const;
</pre></blockquote>
<p>
which requires that the reference type of the range parameter must be <code class='backtick'>formattable</code>,
and such type must be exactly <code class='backtick'>T</code> after removing the <i>cvref</i>-qualifiers.
</p>
<p>
However, satisfying the latter always implies satisfying the former, as the <code class='backtick'>range_formatter</code> class
already requires that <code class='backtick'>T</code> must be <code class='backtick'>formattable</code>.
</p>
<p>
There is no need to perform a redundant check here.
</p>

<p><i>[2025-06-12; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD. This is not redundant, it might check that
<code class='backtick'>const T</code> is formattable, which is not the same as checking that
<code class='backtick'>T</code> is formattable.
</p>



<p id="res-4246"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages — C++">N5008</a>.
</p>

<ol>

<li><p>Modify 28.5.7.2 <a href="https://wg21.link/format.range.formatter">[format.range.formatter]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std {
  template&lt;class T, class charT = char&gt;
    requires same_as&lt;remove_cvref_t&lt;T>, T> &amp;&amp; formattable&lt;T, charT&gt;
  class range_formatter {
    [&hellip;]
    template&lt;ranges::input_range R, class FormatContext&gt;
        requires <del>formattable&lt;ranges::range_reference_t&lt;R&gt;, charT&gt; &amp;&amp;</del>
                 same_as&lt;remove_cvref_t&lt;ranges::range_reference_t&lt;R&gt;&gt;, T&gt;
      typename FormatContext::iterator
        format(R&amp;&amp; r, FormatContext&amp; ctx) const;
  };
}
</pre>
</blockquote>
[&hellip;]
<pre>
template&lt;ranges::input_range R, class FormatContext&gt;
  requires <del>formattable&lt;ranges::range_reference_t&lt;R&gt;, charT&gt; &amp;&amp;</del>
           same_as&lt;remove_cvref_t&lt;ranges::range_reference_t&lt;R&gt;&gt;, T&gt;
typename FormatContext::iterator
  format(R&amp;&amp; r, FormatContext&amp; ctx) const;
</pre>
<blockquote>
<p>
-11- <i>Effects</i>: Writes the following into <code>ctx.out()</code>, adjusted according to the
<i>range-format-spec</i>:
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4253"><a href="#4253">4253</a><sup><a href="https://cplusplus.github.io/LWG/issue4253">(i)</a></sup>. <code class='backtick'>basic_const_iterator</code> should provide <code class='backtick'>iterator_type</code></h3>
<p><b>Section:</b> 24.5.3.3 <a href="https://wg21.link/const.iterators.iterator">[const.iterators.iterator]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-04-29 <b>Last modified:</b> 2025-06-13</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#const.iterators.iterator">active issues</a> in [const.iterators.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#const.iterators.iterator">issues</a> in [const.iterators.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, iterator adaptors in <code>&lt;iterator&gt;</code> that wrap a single iterator
such as <code class='backtick'>reverse_iterator</code>, <code class='backtick'>move_iterator</code>, and <code class='backtick'>counted_iterator</code> all provide a
public <code class='backtick'>iterator_type</code> member for users to access the underlying iterator type, except for
<code class='backtick'>basic_const_iterator</code> (<a href="https://godbolt.org/z/4hY4qhnPG">demo</a>):
</p>
<blockquote><pre>
#include &lt;iterator&gt;

using I  = int*;
using RI = std::reverse_iterator&lt;I&gt;;
using MI = std::move_iterator&lt;I&gt;;
using CI = std::counted_iterator&lt;I&gt;;
using BI = std::basic_const_iterator&lt;I&gt;;

static_assert(std::same_as&lt;RI::iterator_type, I&gt;);
static_assert(std::same_as&lt;MI::iterator_type, I&gt;);
static_assert(std::same_as&lt;CI::iterator_type, I&gt;);
static_assert(std::same_as&lt;BI::iterator_type, I&gt;); // <span  style="color:#C80000;font-weight:bold">error</span>
</pre></blockquote>
<p>
It seems reasonable to add one for <code class='backtick'>basic_const_iterator</code> for consistency.
</p>

<p><i>[2025-06-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p id="res-4253"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages — C++">N5008</a>.
</p>
<ol>

<li><p>Modify 24.5.3.3 <a href="https://wg21.link/const.iterators.iterator">[const.iterators.iterator]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  [&hellip;]
  template&lt;input_iterator Iterator&gt;
  class basic_const_iterator {
    Iterator <i>current_</i> = Iterator();                             // <i>exposition only</i>
    using <i>reference</i> = iter_const_reference_t&lt;Iterator&gt;;         // <i>exposition only</i>
    using <i>rvalue-reference</i> =                                    // <i>exposition only</i>
      <i>iter-const-rvalue-reference-t</i>&lt;Iterator&gt;;
          
    public:
      <ins>using iterator_type = Iterator;</ins>
      using iterator_concept = <i>see below</i>;
      using iterator_category = <i>see below</i>;  // <i>not always present</i>
      using value_type = iter_value_t&lt;Iterator&gt;;
      using difference_type = iter_difference_t&lt;Iterator&gt;;
      [&hellip;]
  };
}
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4257"><a href="#4257">4257</a><sup><a href="https://cplusplus.github.io/LWG/issue4257">(i)</a></sup>. Stream insertion for <code class='backtick'>chrono::local_time</code> should be constrained</h3>
<p><b>Section:</b> 30.7.9 <a href="https://wg21.link/time.clock.local">[time.clock.local]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-05-16 <b>Last modified:</b> 2025-08-26</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Stream insertion for <code class='backtick'>chrono::local_time</code> is defined in terms of conversion to
<code class='backtick'>chrono::sys_time</code>, but not all <code class='backtick'>chrono::sys_time</code> specializations
can be inserted into an ostream, because one of the overloads is
constrained and the other requires convertibility to <code class='backtick'>chrono::sys_days</code>
(see 30.7.2.3 <a href="https://wg21.link/time.clock.system.nonmembers">[time.clock.system.nonmembers]</a>).
</p>
<p>
This means the following code fails to compile:
<pre><code>
#include &lt;iostream&gt;
#include &lt;chrono&gt;

template&lt;typename T&gt;
concept ostream_insertable = requires (std::ostream&amp; o, const T&amp; t) { o &lt;&lt; t; };

using D = std::chrono::duration&lt;double&gt;;

int main() {
  if constexpr (ostream_insertable&lt;std::chrono::sys_time&lt;D&gt;&gt;)
    std::cout &lt;&lt; std::chrono::sys_time&lt;D&gt;{};
  if constexpr (ostream_insertable&lt;std::chrono::local_time&lt;D&gt;&gt;)
    std::cout &lt;&lt; std::chrono::local_time&lt;D&gt;{}; // <b>FAIL</b>
}
</code></pre>
The first condition is false, because there's no overload that's suitable.
The second is true, because the <code>operator&lt;&lt;</code> overload for
<code class='backtick'>chrono::local_time</code> isn't constrained and so insertion appears to be valid.
But actually trying to use it is ill-formed, because it tries to convert the
<code>local_time&lt;D&gt;</code> to a <code>sys_time&lt;D&gt;</code>
and then insert that, which isn't valid.
</p>

<p><i>[2025-08-21; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-4257"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages — C++">N5008</a>.
</p>

<ol>
<li><p>Modify 30.7.9 <a href="https://wg21.link/time.clock.local">[time.clock.local]</a> as indicated:</p>

<blockquote>
<pre><code>
template&lt;class charT, class traits, class Duration&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const local_time&lt;Duration&gt;&amp; lt);
</code></pre>
<p><ins>-?- <i>Constraints</i>:
<code>os &lt;&lt; sys_time&lt;Duration&gt;{lt.time_since_epoch()}</code>
is a valid expression.</ins>
</p>
<p>-2- <i>Effects</i>:
<pre><code> os &lt;&lt; sys_time&lt;Duration&gt;{lt.time_since_epoch()};
</code></pre>
</p>
<p>-3- <i>Returns</i>: <code class='backtick'>os</code>.</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4266"><a href="#4266">4266</a><sup><a href="https://cplusplus.github.io/LWG/issue4266">(i)</a></sup>. <code class='backtick'>layout_stride::mapping</code> should treat empty mappings as exhaustive</h3>
<p><b>Section:</b> 23.7.3.4.7 <a href="https://wg21.link/mdspan.layout.stride">[mdspan.layout.stride]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tomasz Kamiński <b>Opened:</b> 2025-05-22 <b>Last modified:</b> 2025-06-13</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#mdspan.layout.stride">issues</a> in [mdspan.layout.stride].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Mapping over an empty multidimensional index space is always exhaustive according to the 
corresponding definitions from 23.7.3.4.2 <a href="https://wg21.link/mdspan.layout.reqmts">[mdspan.layout.reqmts]</a> p16.
<p/>
However, the current specification of <code class='backtick'>layout_stride::mapping</code> does not consider whether 
some of the empty multidimensional index spaces are unique or exhaustive. For illustration, 
the mapping with the following configuration is not considered exhaustive according to the 
current specification of 23.7.3.4.7.4 <a href="https://wg21.link/mdspan.layout.stride.obs">[mdspan.layout.stride.obs]</a> bullet 5.2:
</p>
<blockquote><pre>
extents: 2, 2, 0
strides: 2, 6, 20
</pre></blockquote>
<p>
This prevents the implementation from implementing <code class='backtick'>sm.is_exhaustive()</code> as 
<code>sm.<i>fwd-prod-of-extents</i>(sm::extents_type::rank()) == sm.required_span_size()</code>. 
For all mappings with size greater than zero, such an expression provides an answer consistent 
with the standard. However, it always returns <code class='backtick'>true</code> for an empty mapping, such as shown 
in the example.
<p/>
We should make such implementation conforming, and require <code class='backtick'>is_exhaustive()</code> to return 
<code class='backtick'>true</code> for empty mappings.
<p/>
For consistency, we could update <code class='backtick'>is_always_exhaustive()</code> to recognize mapping with 
<code class='backtick'>rank() == 0</code>, and one for which at least one of the static extents is equal to zero 
(i.e., they always represent a multidimensional index space).
</p>

<p><i>[2025-06-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-4266"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages — C++">N5008</a>.
</p>
<ol>

<li><p>Modify 23.7.3.4.7.1 <a href="https://wg21.link/mdspan.layout.stride.overview">[mdspan.layout.stride.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Extents&gt;
  class layout_stride::mapping {
    [&hellip;]
    static constexpr bool is_always_unique() noexcept { return true; }
    static constexpr bool is_always_exhaustive() noexcept<ins>;</ins> <del>{ return false; }</del>
    static constexpr bool is_always_strided() noexcept { return true; }
    [&hellip;]
  };
}
</pre>
</blockquote>

</li>

<li><p>Modify 23.7.3.4.7.4 <a href="https://wg21.link/mdspan.layout.stride.obs">[mdspan.layout.stride.obs]</a> as indicated:</p>

<blockquote>
<p>
[&hellip;]
</p>
<pre>
<ins>static constexpr bool is_always_exhaustive() noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <code class='backtick'>true</code> if <code><i>rank_</i></code> is <code class='backtick'>0</code> or if there is a rank index 
<code class='backtick'>r</code> of <code class='backtick'>extents()</code> such that <code class='backtick'>extents_type::static_extent(r)</code> is <code class='backtick'>0</code>, otherwise <code class='backtick'>false</code>.</ins>
</p>
</blockquote>
<pre>
constexpr bool is_exhaustive() const noexcept;
</pre>
<blockquote>
<p>
-5- <i>Returns</i>:
</p>
<ol style="list-style-type: none">
<li><p>(5.1) &mdash; <code class='backtick'>true</code> if <code><i>rank_</i></code> <ins>or the size of the multidimensional 
index space <code class='backtick'>m.extents()</code></ins> is <code class='backtick'>0</code>.</p></li>
<li><p>(5.2) &mdash; [&hellip;]</p></li>
<li><p>(5.3) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>
</blockquote>

</li>

</ol>






<hr>
<h3 id="4269"><a href="#4269">4269</a><sup><a href="https://cplusplus.github.io/LWG/issue4269">(i)</a></sup>. <code class='backtick'>unique_copy</code> passes arguments to its predicate backwards</h3>
<p><b>Section:</b> 26.7.9 <a href="https://wg21.link/alg.unique">[alg.unique]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-05-29 <b>Last modified:</b> 2025-10-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.unique">active issues</a> in [alg.unique].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For the <code class='backtick'>unique</code> algorithms, 26.7.9 <a href="https://wg21.link/alg.unique">[alg.unique]</a> p1 says:
</p>
<blockquote>
1. Let <code class='backtick'>pred</code> be <code class='backtick'>equal_to{}</code> for the overloads with no parameter <code class='backtick'>pred</code>,
and let <i>E</i> be
<ol style="list-style-type: none">
<li> (1.1)
 &mdash; <code class='backtick'>bool(pred(*(i - 1), *i))</code> for the overloads in namespace <code class='backtick'>std</code>;
</li>
<li>(1.2)
 &mdash; <code class='backtick'>bool(invoke(comp, invoke(proj, *(i - 1)), invoke(proj, *i)))</code>
 for the overloads in namespace <code class='backtick'>ranges</code>.
</li>
</ol>
</blockquote>
<p>
However for the <code class='backtick'>unique_copy</code> algorithms, 26.7.9 <a href="https://wg21.link/alg.unique">[alg.unique]</a> p6 says
that the arguments <code class='backtick'>*i</code> and <code class='backtick'>*(i-1)</code> should be reversed:
</p>
<blockquote>
6. Let <code class='backtick'>pred</code> be <code class='backtick'>equal_to{}</code> for the overloads with no parameter <code class='backtick'>pred</code>,
and let <i>E</i> be
<ol style="list-style-type: none">
<li> (6.1)
 &mdash; <code class='backtick'>bool(pred(*i, *(i - 1)))</code> for the overloads in namespace <code class='backtick'>std</code>;
</li>
<li>(6.2)
 &mdash; <code class='backtick'>bool(invoke(comp, invoke(proj, *i), invoke(proj, *(i - 1))))</code>
 for the overloads in namespace <code class='backtick'>ranges</code>.
</li>
</ol>
</blockquote>
<p>
This reversed order is consistent with the documentation for
<a href="https://stl.boost.org/unique_copy.html">SGI STL <code class='backtick'>unique_copy</code></a>,
although the docs for 
<a href="https://stl.boost.org/unique_copy.html">SGI STL <code class='backtick'>unique</code></a>
show reversed arguments too, and the C++ standard doesn't match that.
</p>
<p>
A survey of known implementations shows that all three of libstdc++, libc++,
and MSVC STL use the <code class='backtick'>pred(*(i - 1), *i)</code> order for all of <code class='backtick'>std::unique</code>,
<code class='backtick'>std::unique_copy</code>, <code class='backtick'>ranges::unique</code>, and <code class='backtick'>ranges::unique_copy</code>. The range-v3
library did the same, and even the SGI STL did too (despite what its docs said).
Only two implementations were found which match the spec and use a different
argument order for <code class='backtick'>unique</code> and <code class='backtick'>unique_copy</code>, Casey Carter's (cmcstl2) and
Fraser Gordon's.
</p>
<p>
In the absence of any known rationale for <code class='backtick'>unique</code> and <code class='backtick'>unique_copy</code> to differ,
it seems sensible to make <code class='backtick'>unique_copy</code> more consistent with <code class='backtick'>unique</code>
(and with the majority of implementations stretching back three decades).
</p>

<p><i>[2025-10-17; Reflector poll.]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>
<p>
Fixed misplaced <code class='backtick'>)</code> in the (6.1) change as pointed out on reflector,
and rebased on <a href="https://wg21.link/N5014">N5014</a>.
</p>
<p>
"I remain inconvinced that this actually matters given the equivalence relation requirement."
</p>


<p id="res-4269"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>
<li><p>Modify 26.7.9 <a href="https://wg21.link/alg.unique">[alg.unique]</a> as indicated:</p>
<blockquote>
6. Let <code class='backtick'>pred</code> be <code class='backtick'>equal_to{}</code> for the overloads with no parameter <code class='backtick'>pred</code>,
and let <i>E</i>(<code class='backtick'>i</code>) be
<ol style="list-style-type: none">
<li> (6.1)
 &mdash; <code>bool(pred(<del>*i,</del> *(i - 1)<ins>, *i</ins>))</code>
 for the overloads in namespace <code class='backtick'>std</code>;
</li>
<li>(6.2)
 &mdash; <code>bool(invoke(comp, <del>invoke(proj, *i),</del>
 invoke(proj, *(i - 1))<ins>, invoke(proj, *i)</ins>))</code>
 for the overloads in namespace <code class='backtick'>ranges</code>.
</li>
</ol>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4274"><a href="#4274">4274</a><sup><a href="https://cplusplus.github.io/LWG/issue4274">(i)</a></sup>. The <code class='backtick'>chrono::hh_mm_ss</code> constructor is ill-formed for unsigned durations</h3>
<p><b>Section:</b> 30.9.2 <a href="https://wg21.link/time.hms.members">[time.hms.members]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Michael Welsh Duggan <b>Opened:</b> 2025-06-04 <b>Last modified:</b> 2025-06-13</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 30.9.2 <a href="https://wg21.link/time.hms.members">[time.hms.members]</a>, paragraph 3, the current wording for the
constructor of <code class='backtick'>hh_mm_ss</code> expresses some of its requirements in terms of
<code class='backtick'>abs(d)</code>, which is assumed to be <code class='backtick'>chrono::abs(chrono::duration)</code>.
<code class='backtick'>chrono::abs</code> is not defined, however, for durations with an unsigned
representation. I believe that not being able to create <code class='backtick'>hh_mm_ss</code>
objects from unsigned durations is unintentional.
<p/>
Moreover, <code>is_constructible_v&lt;hh_mm_ss&lt;ud&gt;, ud&gt;</code> is required 
to be true by the standard for any duration, so making it actually work makes 
a lot of sense.
</p>

<p><i>[2025-06-13; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-4274"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages — C++">N5008</a>.
</p>

<ol>
<li><p>Modify 30.9.2 <a href="https://wg21.link/time.hms.members">[time.hms.members]</a> as indicated:</p>

<blockquote>
<pre>
constexpr explicit hh_mm_ss(Duration d);
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Constructs an object of type <code class='backtick'>hh_mm_ss</code> which represents the <code class='backtick'>Duration d</code> 
with precision <code class='backtick'>precision</code>.
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; Initializes <code class='backtick'>is_neg</code> with <code>d &lt; Duration::zero()</code>. <ins>Let 
<code><i>ABS_D</i></code> represent <code class='backtick'>-d</code> if <code class='backtick'>is_neg</code> is <code class='backtick'>true</code> and <code class='backtick'>d</code> otherwise.</ins></p></li>
<li><p>(3.2) &mdash; Initializes <code class='backtick'>h</code> with <code>duration_cast&lt;chrono::hours&gt;(<del>abs(d)</del><ins><i>ABS_D</i></ins>)</code>.</p></li>
<li><p>(3.3) &mdash; Initializes <code class='backtick'>m</code> with <code>duration_cast&lt;chrono::minutes&gt;(<del>abs(d)</del><ins><i>ABS_D</i></ins> - hours())</code>.</p></li>
<li><p>(3.4) &mdash; Initializes <code class='backtick'>s</code> with <code>duration_cast&lt;chrono::seconds&gt;(<del>abs(d)</del><ins><i>ABS_D</i></ins> - hours() - minutes())</code>.</p></li>
<li><p>(3.5) &mdash; If <code>treat_as_floating_point_v&lt;precision::rep&gt;</code> is <code class='backtick'>true</code>, initializes 
<code class='backtick'>ss</code> with <code><del>abs(d)</del><ins><i>ABS_D</i></ins> - hours() - minutes() - seconds()</code>. Otherwise, initializes <code class='backtick'>ss</code> with 
<code>duration_cast&lt;precision&gt;(<del>abs(d)</del><ins><i>ABS_D</i></ins> - hours() - minutes() - seconds())</code>.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4275"><a href="#4275">4275</a><sup><a href="https://cplusplus.github.io/LWG/issue4275">(i)</a></sup>. <code class='backtick'>std::dynamic_extent</code> should also be defined in <code>&lt;mdspan&gt;</code></h3>
<p><b>Section:</b> 23.7.3.2 <a href="https://wg21.link/mdspan.syn">[mdspan.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Aiden Grossman <b>Opened:</b> 2025-06-06 <b>Last modified:</b> 2025-10-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#mdspan.syn">issues</a> in [mdspan.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>std::dynamic_extent</code> can be used in certain circumstances in <code class='backtick'>std::mdspan</code>, 
such as with padded layouts. However, <code class='backtick'>std::dynamic_extent</code> is currently only 
defined in <code>&lt;span&gt;</code> which necessitates including <code>&lt;span&gt;</code> 
solely for the <code class='backtick'>std::dynamic_extent</code> definition.
</p>
<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages — C++">N5008</a>.
</p>

<ol>
<li><p>Modify 23.7.3.2 <a href="https://wg21.link/mdspan.syn">[mdspan.syn]</a>, header <code>&lt;span&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
<i>// all freestanding</i>
namespace std {
  <ins><i>// constants</i></ins>
  <ins>inline constexpr size_t dynamic_extent = numeric_limits&lt;size_t&gt;::max();</ins>
  
  <i>// 23.7.3.3 <a href="https://wg21.link/mdspan.extents">[mdspan.extents]</a>, class template extents</i>
  template&lt;class IndexType, size_t... Extents&gt;
  class extents;

  [&hellip;]
}
</pre>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2025-06-10; Jonathan provides improved wording]</i></p>



<p><i>[2025-10-15; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>


<p><i>[2025-10-17; Reflector poll.]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>


<p id="res-4275"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages — C++">N5008</a>.
</p>

<ol>
<li><p>Modify 23.7.1 <a href="https://wg21.link/views.general">[views.general]</a> as indicated:</p>

<blockquote>
<p>
The header <code>&lt;span&gt;</code> (23.7.2.1 <a href="https://wg21.link/span.syn">[span.syn]</a>)
defines the view <code class='backtick'>span</code>.
The header <code>&lt;mdspan&gt;</code> (23.7.3.2 <a href="https://wg21.link/mdspan.syn">[mdspan.syn]</a>)
defines the class template <code class='backtick'>mdspan</code> and other facilities for interacting
with these multidimensional views.
</p>
<p>
<ins>
-?-
In addition to being available via inclusion of the <code>&lt;span&gt;</code>
header,
<code class='backtick'>dynamic_extent</code> is available when the header <code>&lt;mdspan&gt;</code>
is included.
</ins>
</p>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4276"><a href="#4276">4276</a><sup><a href="https://cplusplus.github.io/LWG/issue4276">(i)</a></sup>. <code class='backtick'>front()</code> and <code class='backtick'>back()</code> are not hardened for zero-length <code class='backtick'>std::array</code>s</h3>
<p><b>Section:</b> 23.3.3.5 <a href="https://wg21.link/array.zero">[array.zero]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jan Schultke <b>Opened:</b> 2025-06-08 <b>Last modified:</b> 2025-08-26</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#array.zero">active issues</a> in [array.zero].</p>
<p><b>View all other</b> <a href="lwg-index.html#array.zero">issues</a> in [array.zero].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The intent of <a href="https://wg21.link/P3471" title=" Standard Library Hardening">P3471</a> "Standard library hardening" is clearly to provide hardened preconditions 
for members of sequence containers, including <code class='backtick'>std::array</code>. However, a zero-length <code class='backtick'>std::array</code> dodges this 
hardening by having undefined behavior for <code class='backtick'>front()</code> and <code class='backtick'>back()</code> explicitly specified in 
23.3.3.5 <a href="https://wg21.link/array.zero">[array.zero]</a> paragraph 3.
<p/>
Without this paragraph, <code class='backtick'>front()</code> and <code class='backtick'>back()</code> would be hardened as well, as specified in 23.2.4 <a href="https://wg21.link/sequence.reqmts">[sequence.reqmts]</a>.
</p>

<p><i>[2025-08-21; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p id="res-4276"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages — C++">N5008</a>.
</p>

<ol>
<li><p>Modify 23.3.3.5 <a href="https://wg21.link/array.zero">[array.zero]</a> as indicated:</p>

<blockquote>
<p>
<del>-3- The effect of calling <code class='backtick'>front()</code> or <code class='backtick'>back()</code> for a zero-sized array is undefined.</del>
</p>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4280"><a href="#4280">4280</a><sup><a href="https://cplusplus.github.io/LWG/issue4280">(i)</a></sup>. <code class='backtick'>simd::partial_load</code> uses undefined identifier <code class='backtick'>T</code></h3>
<p><b>Section:</b> 29.10.8.7 <a href="https://wg21.link/simd.loadstore">[simd.loadstore]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2025-06-21 <b>Last modified:</b> 2025-08-26</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#simd.loadstore">active issues</a> in [simd.loadstore].</p>
<p><b>View all other</b> <a href="lwg-index.html#simd.loadstore">issues</a> in [simd.loadstore].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <i>Effects:</i> element of <code class='backtick'>std::simd::partial_load</code> (after the latest rename) uses <code class='backtick'>T</code> 
but that is not defined anywhere. It should be <code class='backtick'>V::value_type</code>.
<p/>
Also, this paragraph should be a <i>Returns:</i> element.
</p>

<p><i>[2025-08-21; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after nine votes in favour during reflector poll.
</p>



<p id="res-4280"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages — C++">N5008</a>.
</p>

<ol>
<li><p>Modify 29.10.8.7 <a href="https://wg21.link/simd.loadstore">[simd.loadstore]</a> as indicated:</p>

<blockquote>
<pre><code>
template&lt;class V = <i>see below</i>, ranges::contiguous_range R, class... Flags&gt;
  requires ranges::sized_range&lt;R&gt;
  constexpr V partial_load(R&amp;&amp; r, flags&lt;Flags...&gt; f = {});
[&hellip;]
template&lt;class V = <i>see below</i>, contiguous_iterator I, sized_sentinel_for&lt;I&gt; S, class... Flags&gt;
  constexpr V partial_load(I first, S last, const typename V::mask_type&amp; mask,
                           flags&lt;Flags...&gt; f = {});
</code></pre>
<blockquote>
<p>
-6- [&hellip;]
<p/>
-7- <i>Mandates</i>: [&hellip;]
<p/>
-8- <i>Preconditions</i>: [&hellip;]
<p/>
-9- <del><i>Effects</i>: Initializes the</del><ins><i>Returns</i>: A <code class='backtick'>basic_simd</code> object 
whose</ins> <code><i>i</i></code><sup>th</sup> element <ins>is initialized</ins> with
<code>mask[<i>i</i>] &amp;&amp; <i>i</i> &lt; ranges::size(r) ? static_cast&lt;T&gt;(ranges::data(r)[<i>i</i>]) : T()</code> 
for all <code><i>i</i></code> in the range of <code>[0, V::size())</code><ins>, where <code class='backtick'>T</code> is <code class='backtick'>V::value_type</code></ins>.
<p/>
-10- <i>Remarks</i>: The default argument for template parameter <code class='backtick'>V</code> is <code>basic_simd&lt;ranges::range_value_t&lt;R&gt;&gt;</code>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4286"><a href="#4286">4286</a><sup><a href="https://cplusplus.github.io/LWG/issue4286">(i)</a></sup>. Some more feature-test macros for fully freestanding features are not marked freestanding</h3>
<p><b>Section:</b> 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a>, 20.2.2 <a href="https://wg21.link/memory.syn">[memory.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Yihe Li <b>Opened:</b> 2025-06-17 <b>Last modified:</b> 2025-10-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#version.syn">active issues</a> in [version.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#version.syn">issues</a> in [version.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P1642R11" title=" Freestanding Library: Easy [utilities], [ranges], and [iterators]">P1642R11</a> (accepted in C++23) plus LWG <a href="lwg-defects.html#4189" title="cache_latest_view should be freestanding (Status: WP)">4189</a><sup><a href="https://cplusplus.github.io/LWG/issue4189" title="Latest snapshot">(i)</a></sup> (accepted in Hagenberg) added nearly the entire 
<code>&lt;ranges&gt;</code> header to freestanding. 
However, the only feature-test macro being added to freestanding is <code class='backtick'>__cpp_lib_ranges_cache_latest</code>, which seems weird, 
since <code class='backtick'>views::enumerate</code> is also added to freestanding following the blanket comment strategy, but its feature-test 
macro remains not in freestanding. In retrospective, since all range algorithms are in freestanding via 
<a href="https://wg21.link/P2976" title=" Freestanding Library: algorithm, numeric, and random">P2976</a>, all <code class='backtick'>__cpp_lib_ranges_*</code> FTMs (except <code class='backtick'>__cpp_lib_ranges_generate_random</code> since 
<code class='backtick'>ranges::generate_random</code> is not in freestanding) should probably be marked as freestanding.
<p/>
Furthermore, LWG <a href="lwg-defects.html#4126" title="Some feature-test macros for fully freestanding features are not yet marked freestanding (Status: WP)">4126</a><sup><a href="https://cplusplus.github.io/LWG/issue4126" title="Latest snapshot">(i)</a></sup> left out some other FTMs for fully freestanding features. They are also added 
in the following wording.
<p/>
A note about <code class='backtick'>is_sufficiently_aligned</code>: <a href="https://wg21.link/P2897R7" title=" aligned_accessor: An mdspan accessor expressing pointer overalignment">P2897R7</a> does indicate in 5.7.6.1 that the function should be 
freestanding, but somehow the wording didn't say so. The following wording includes the function and its FTM anyway 
since hopefully this is just an omission when wording the paper.
</p>

<p><i>[2025-10-14; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after nine votes in favour during reflector poll.
</p>



<p id="res-4286"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages — C++">N5008</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a>, header <code>&lt;version&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_aligned_accessor             202411L <i>// <ins>freestanding,</ins> also in &lt;mdspan&gt;</i>
[&hellip;]                                     
#define __cpp_lib_array_constexpr              201811L <i>// <ins>freestanding,</ins> also in &lt;iterator&gt;, &lt;array&gt;</i>
[&hellip;]                                     
#define __cpp_lib_clamp                        201603L <i>// <ins>freestanding,</ins> also in &lt;algorithm&gt;</i>
[&hellip;]                                     
#define __cpp_lib_constexpr_numeric            201911L <i>// <ins>freestanding,</ins> also in &lt;numeric&gt;</i>
[&hellip;]                                     
#define __cpp_lib_function_ref                 202306L <i>// <ins>freestanding,</ins> also in &lt;functional&gt;</i>
#define __cpp_lib_gcd_lcm                      201606L <i>// <ins>freestanding,</ins> also in &lt;numeric&gt;</i>
[&hellip;]
#define __cpp_lib_integer_comparison_functions 202002L <i>// <ins>freestanding,</ins> also in &lt;utility&gt;</i>
[&hellip;]
#define __cpp_lib_is_sufficiently_aligned      202411L <i>// <ins>freestanding,</ins> also in &lt;memory&gt;</i>
[&hellip;]
#define __cpp_lib_ranges_contains              202207L <i>// <ins>freestanding,</ins> also in &lt;algorithm&gt;</i>
#define __cpp_lib_ranges_enumerate             202302L <i>// <ins>freestanding,</ins> also in &lt;ranges&gt;</i>
#define __cpp_lib_ranges_find_last             202207L <i>// <ins>freestanding,</ins> also in &lt;algorithm&gt;</i>
#define __cpp_lib_ranges_fold                  202207L <i>// <ins>freestanding,</ins> also in &lt;algorithm&gt;</i>
[&hellip;]
#define __cpp_lib_ranges_iota                  202202L <i>// <ins>freestanding,</ins> also in &lt;numeric&gt;</i>
[&hellip;]
#define __cpp_lib_ranges_starts_ends_with      202106L <i>// <ins>freestanding,</ins> also in &lt;algorithm&gt;</i>
[&hellip;]
#define __cpp_lib_robust_nonmodifying_seq_ops  201304L <i>// <ins>freestanding,</ins> also in &lt;algorithm&gt;</i>
#define __cpp_lib_sample                       201603L <i>// <ins>freestanding,</ins> also in &lt;algorithm&gt;</i>
#define __cpp_lib_saturation_arithmetic        202311L <i>// <ins>freestanding,</ins> also in &lt;numeric&gt;</i>
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 20.2.2 <a href="https://wg21.link/memory.syn">[memory.syn]</a>, header <code>&lt;memory&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;size_t Alignment, class T&gt;
  bool is_sufficiently_aligned(T* ptr);      <ins><i>// freestanding</i></ins>
[&hellip;]
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4291"><a href="#4291">4291</a><sup><a href="https://cplusplus.github.io/LWG/issue4291">(i)</a></sup>.  <code>explicit map(const Allocator&amp;)</code> should be <code>constexpr</code> </h3>
<p><b>Section:</b> 23.4.3.1 <a href="https://wg21.link/map.overview">[map.overview]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-07-10 <b>Last modified:</b> 2025-08-26</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#map.overview">active issues</a> in [map.overview].</p>
<p><b>View all other</b> <a href="lwg-index.html#map.overview">issues</a> in [map.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The intent of <a href="https://wg21.link/P3372R3" title=" constexpr containers and adapters">P3372R3</a> was for all container constructors to be
constexpr, but during application of the paper to the working draft
it was observed that one <code class='backtick'>map</code> constructor was missed.
</p>

<p><i>[2025-08-21; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-4291"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages — C++">N5008</a>.
</p>

<ol>

<li><p>Modify 23.4.3.1 <a href="https://wg21.link/map.overview">[map.overview]</a> as indicated:</p>
<blockquote>
<pre><code>
<i>// 23.4.3.2, construct/copy/destroy</i>
constexpr map() : map(Compare()) { }
constexpr explicit map(const Compare&amp; comp, const Allocator&amp; = Allocator());
template&lt;class InputIterator&gt;
  constexpr map(InputIterator first, InputIterator last,
                const Compare&amp; comp = Compare(), const Allocator&amp; = Allocator());
template&lt;<i>container-compatible-range</i> &lt;value_type&gt; R&gt;
  constexpr map(from_range_t, R&amp;&amp; rg, const Compare&amp; comp = Compare(),
                const Allocator&amp; = Allocator());
constexpr map(const map&amp; x);
constexpr map(map&amp;&amp; x);
<ins>constexpr</ins> explicit map(const Allocator&amp;);
constexpr map(const map&amp;, const type_identity_t&lt;Allocator&gt;&amp;);
constexpr map(map&amp;&amp;, const type_identity_t&lt;Allocator&gt;&amp;);
constexpr map(initializer_list&lt;value_type&gt;, const Compare&amp; = Compare(),
              const Allocator&amp; = Allocator());
</code></pre>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4292"><a href="#4292">4292</a><sup><a href="https://cplusplus.github.io/LWG/issue4292">(i)</a></sup>. Unordered container local iterators should be constexpr iterators</h3>
<p><b>Section:</b> 23.5.3.1 <a href="https://wg21.link/unord.map.overview">[unord.map.overview]</a>, 23.5.4.1 <a href="https://wg21.link/unord.multimap.overview">[unord.multimap.overview]</a>, 23.5.6.1 <a href="https://wg21.link/unord.set.overview">[unord.set.overview]</a>, 23.5.7.1 <a href="https://wg21.link/unord.multiset.overview">[unord.multiset.overview]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-07-10 <b>Last modified:</b> 2025-08-29</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The intent of <a href="https://wg21.link/P3372R3" title=" constexpr containers and adapters">P3372R3</a> was for all container iterators to be
constexpr iterators, but during application of the paper to the working draft
it was observed that unordered containers don't say it for their
local iterators.
</p>

<p><i>[2025-08-29; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p id="res-4292"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages — C++">N5008</a>.
</p>

<ol>

<li><p>Modify 23.5.3.1 <a href="https://wg21.link/unord.map.overview">[unord.map.overview]</a> as indicated:</p>
<blockquote>
<p>-4-
The types <code class='backtick'>iterator</code><ins>,</ins> <del>and</del> <code class='backtick'>const_iterator</code><ins>,
<code class='backtick'>local_iterator</code>, and <code class='backtick'>const_local_iterator</code></ins>
meet the constexpr iterator requirements
(24.3.1 <a href="https://wg21.link/iterator.requirements.general">[iterator.requirements.general]</a>).
</p>
</blockquote>
</li>

<li><p>Modify 23.5.4.1 <a href="https://wg21.link/unord.multimap.overview">[unord.multimap.overview]</a> as indicated:</p>
<blockquote>
<p>-4-
The types <code class='backtick'>iterator</code><ins>,</ins> <del>and</del> <code class='backtick'>const_iterator</code><ins>,
<code class='backtick'>local_iterator</code>, and <code class='backtick'>const_local_iterator</code></ins>
meet the constexpr iterator requirements
(24.3.1 <a href="https://wg21.link/iterator.requirements.general">[iterator.requirements.general]</a>).
</p>
</blockquote>
</li>

<li><p>Modify 23.5.6.1 <a href="https://wg21.link/unord.set.overview">[unord.set.overview]</a> as indicated:</p>
<blockquote>
<p>-4-
The types <code class='backtick'>iterator</code><ins>,</ins> <del>and</del> <code class='backtick'>const_iterator</code><ins>,
<code class='backtick'>local_iterator</code>, and <code class='backtick'>const_local_iterator</code></ins>
meet the constexpr iterator requirements
(24.3.1 <a href="https://wg21.link/iterator.requirements.general">[iterator.requirements.general]</a>).
</p>
</blockquote>
</li>

<li><p>Modify 23.5.7.1 <a href="https://wg21.link/unord.multiset.overview">[unord.multiset.overview]</a> as indicated:</p>
<blockquote>
<p>-4-
The types <code class='backtick'>iterator</code><ins>,</ins> <del>and</del> <code class='backtick'>const_iterator</code><ins>,
<code class='backtick'>local_iterator</code>, and <code class='backtick'>const_local_iterator</code></ins>
meet the constexpr iterator requirements
(24.3.1 <a href="https://wg21.link/iterator.requirements.general">[iterator.requirements.general]</a>).
</p>
</blockquote>
</li>

</ol>






<hr>
<h3 id="4293"><a href="#4293">4293</a><sup><a href="https://cplusplus.github.io/LWG/issue4293">(i)</a></sup>. span::subspan/first/last chooses wrong constructor when T is const-qualified bool</h3>
<p><b>Section:</b> 23.7.2.2.4 <a href="https://wg21.link/span.sub">[span.sub]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Yuhan Liu <b>Opened:</b> 2025-07-11 <b>Last modified:</b> 2025-08-26</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#span.sub">issues</a> in [span.sub].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 23.7.2.2.4 <a href="https://wg21.link/span.sub">[span.sub]</a>, paragraphs p12, p14, and p16 erroneously
use the initializer list constructor for span instead of the intended
iterator/count constructor.
</p>
<p>
Specifically, in these paragraphs, the standard states:
<blockquote>
<i>Effects</i>: Equivalent to: <code class='backtick'>return {data(), count};</code>
</blockquote>
or some variant of <code class='backtick'>return {pointer, size}</code>.  As reported in
<a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=120997">GCC bug 120997</a>
this results in a span that points to invalid stack memory.
This can be reproduced on GCC 15.1 for subspan, first, and last:
<a href="https://godbolt.org/z/r9nrdWscq">https://godbolt.org/z/r9nrdWscq</a>.
</p>
<p>
A proposed fix (thanks to Jonathan Wakely) could look like this following:
<blockquote>
<code>return span&lt;element_type&gt;(data(), count);</code>
</blockquote>
for the affected paragraphs,
which would explicitly specify the constructor used.
</p>

<p><i>[2025-07-11; Jonathan adds proposed resolution]</i></p>

<p>
The meaning of those <i>Effects</i>: paragraphs was changed for C++26 by
<a href="https://wg21.link/P2447R6" title=" std::span over an initializer list">P2447R6</a> which added the <code class='backtick'>span(initializer_list)</code> constructor.
A simpler demo is:
<blockquote><pre><code>bool a[5]{};
std::span&lt;const bool&gt; s(a);
std::span&lt;const bool&gt; s2 = s.first(5);
assert(s2.size() == 5); // OK in C++23, fails in C++26
assert(s2.data() == a); // OK in C++23, fails in C++26
</code></pre></blockquote>
The proposed resolution is to use <code class='backtick'>R(data(), count)</code> instead of
<code class='backtick'>{data(), count}</code>. The former always (uniformly) means the same thing,
but for the latter the meaning of list-initialization depends on the types.
The list-initialization form will choose the initializer-list constructor
when <code class='backtick'>data()</code> and <code class='backtick'>count</code> are both convertible to the element type.
</p>

<p><i>[2025-08-21; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after nine votes in favour during reflector poll.
</p>



<p id="res-4293"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages — C++">N5008</a>.
</p>

<ol>

<li><p>Modify 23.7.2.2.4 <a href="https://wg21.link/span.sub">[span.sub]</a> as indicated:</p>

<blockquote>

<pre><code>
template&lt;size_t Count&gt; constexpr span&lt;element_type, Count&gt; first() const;
</code></pre>
<blockquote>
<p>-1- <i>Mandates</i>: <code>Count &lt;= Extent</code> is <code class='backtick'>true</code>.</p>
<p>-2- <i>Hardened preconditions</i>: <code>Count &lt;= size()</code> is <code class='backtick'>true</code>.</p>
<p>-3- <i>Effects</i>: Equivalent to:
<code>return R<ins>(</ins><del>{</del>data(), Count<del>}</del><ins>)</ins>;</code>
where <code class='backtick'>R</code> is the return type.
</p>
</blockquote>

<pre><code>
template&lt;size_t Count&gt; constexpr span&lt;element_type, Count&gt; last() const;
</code></pre>
<blockquote>
<p>-4- <i>Mandates</i>: <code>Count &lt;= Extent</code> is <code class='backtick'>true</code>.</p>
<p>-5- <i>Hardened preconditions</i>: <code>Count &lt;= size()</code> is <code class='backtick'>true</code>.</p>
<p>-6- <i>Effects</i>: Equivalent to:
<code>return R<ins>(</ins><del>{</del>data() + (size() - Count), Count<del>}</del><ins>)</ins>;</code>
where <code class='backtick'>R</code> is the return type.
</p>
</blockquote>

<pre><code>
template&lt;size_t Offset, size_t Count = dynamic_extent&gt;
  constexpr span&lt;element_type, <i>see below</i>&gt; subspan() const;
</code></pre>
<blockquote>
<p>-7- <i>Mandates</i>:
<blockquote><pre><code>Offset &lt;= Extent &amp;&amp; (Count == dynamic_extent || Count &lt;= Extent - Offset)
</code></pre></blockquote>
is <code class='backtick'>true</code>.</p>
<p>-8- <i>Hardened preconditions</i>:
<blockquote><pre><code>Offset &lt;= size() &amp;&amp; (Count == dynamic_extent || Count &lt;= size() - Offset)
</code></pre></blockquote>
is <code class='backtick'>true</code>.</p>
<p>-9- <i>Effects</i>: Equivalent to:
<blockquote><pre><code>return span&lt;ElementType, <i>see below</i>&gt;(
    data() + Offset, Count != dynamic_extent ? Count : size() - Offset);
</code></pre></blockquote>
</p>
<p>-10- <i>Remarks</i>:
The second template argument of the returned <code class='backtick'>span</code> type is:
<blockquote><pre><code>Count != dynamic_extent ? Count
                        : (Extent != dynamic_extent ? Extent - Offset
                                                    : dynamic_extent)
</code></pre></blockquote>
</p>
</blockquote>

<pre><code>
constexpr span&lt;element_type, dynamic_extent&gt; first(size_type count) const;
</code></pre>
<blockquote>
<p>-11- <i>Hardened preconditions</i>: <code>count &lt;= size()</code> is <code class='backtick'>true</code>.</p>
<p>-12- <i>Effects</i>: Equivalent to:
<code>return <ins>R(</ins><del>{</del>data(), count<del>}</del><ins>)</ins>;</code>
<ins>where <code class='backtick'>R</code> is the return type</ins>.
</p>
</blockquote>

<pre><code>
constexpr span&lt;element_type, dynamic_extent&gt; last(size_type count) const;
</code></pre>
<blockquote>
<p>-13- <i>Hardened preconditions</i>: <code>count &lt;= size()</code> is <code class='backtick'>true</code>.</p>
<p>-14- <i>Effects</i>: Equivalent to:
<code>return <ins>R(</ins><del>{</del>data() + (size() - count), count<del>}</del><ins>)</ins>;</code>
<ins>where <code class='backtick'>R</code> is the return type</ins>.
</p>
</blockquote>

<pre><code>
constexpr span&lt;element_type, dynamic_extent&gt; subspan(
  size_type offset, size_type count = dynamic_extent) const;
</code></pre>
<blockquote>
<p>-15- <i>Hardened preconditions</i>:
<blockquote><pre><code>offset &lt;= size() &amp;&amp; (count == dynamic_extent || count &lt;= size() - offset
</code></pre></blockquote>
is <code class='backtick'>true</code>.</p>
<p>-16- <i>Effects</i>: Equivalent to:
<blockquote><pre><code>return <ins>R(</ins><del>{</del>data() + offset, count == dynamic_extent ? size() - offset :  count<del>}</del><ins>)</ins>;
</code></pre></blockquote>
<ins>where <code class='backtick'>R</code> is the return type</ins>.
</p>
</blockquote>

</blockquote>
</li>
</ol>






<hr>
<h3 id="4294"><a href="#4294">4294</a><sup><a href="https://cplusplus.github.io/LWG/issue4294">(i)</a></sup>. <code class='backtick'>bitset(const CharT*)</code> constructor needs to be constrained</h3>
<p><b>Section:</b> 22.9.2.2 <a href="https://wg21.link/bitset.cons">[bitset.cons]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-07-12 <b>Last modified:</b> 2025-08-26</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#bitset.cons">issues</a> in [bitset.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This code might be ill-formed, with an error outside the immediate context
that users cannot prevent:
<blockquote><pre><code>
#include &lt;bitset&gt;
struct NonTrivial { ~NonTrivial() { } };
static_assert( ! std::is_constructible_v&lt;std::bitset&lt;1&gt;, NonTrivial*&gt; );
</code></pre></blockquote>
</p>
<p>
The problem is that the <code class='backtick'>bitset(const CharT*)</code> constructor tries to instantiate
<code>basic_string_view&lt;NonTrivial&gt;</code> to find its <code class='backtick'>size_type</code>,
and that instantiation might ill-formed, e.g. if <code class='backtick'>std::basic_string_view</code> or
<code class='backtick'>std::char_traits</code> has a static assert enforcing the requirement for their
character type to be sufficiently char-like. 27.1 <a href="https://wg21.link/strings.general">[strings.general]</a>
defines a char-like type as "any non-array trivially copyable standard-layout
(6.9.1 <a href="https://wg21.link/basic.types.general">[basic.types.general]</a>) type <code class='backtick'>T</code>
where <code>is_trivially_default_constructible_v&lt;T&gt;</code> is <code class='backtick'>true</code>."
</p>

<p><i>[2025-08-21; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-4294"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages — C++">N5008</a>.
</p>

<ol>

<li><p>Modify 22.9.2.2 <a href="https://wg21.link/bitset.cons">[bitset.cons]</a> as indicated:</p>

<blockquote>
<pre><code>
template&lt;class charT&gt;
  constexpr explicit bitset(
    const charT* str,
    typename basic_string_view&lt;charT&gt;::size_type n = basic_string_view&lt;charT&gt;::npos,
    charT zero = charT(’0’),
    charT one = charT(’1’));
</code></pre>
<blockquote>
<p>
<ins>-?- <i>Constraints</i>:</ins>
<ul>
<li>
<ins><code>is_array_v&lt;charT&gt;</code> is <code class='backtick'>false</code>,</ins>
</li>
<li>
<ins><code>is_trivially_copyable_v&lt;charT&gt;</code> is <code class='backtick'>true</code>,</ins>
</li>
<li>
<ins><code>is_standard_layout_v&lt;charT&gt;</code> is <code class='backtick'>true</code>, and</ins>
</li>
<li>
<ins><code>is_trivially_default_constructible_v&lt;charT&gt;</code> is <code class='backtick'>true</code>.</ins>
</li>
</ul>
</p>
<p>-8- <i>Effects</i>: As if by:
<blockquote>
<pre><code>bitset(n == basic_string_view&lt;charT&gt;::npos
          ? basic_string_view&lt;charT&gt;(str)
          : basic_string_view&lt;charT&gt;(str, n),
       0, n, zero, one)
</code></pre>
</blockquote>
</p>
</blockquote>
</blockquote>
</li>
</ol>







<hr>
<h3 id="4299"><a href="#4299">4299</a><sup><a href="https://cplusplus.github.io/LWG/issue4299">(i)</a></sup>. Missing <i>Mandates:</i> part in <code>optional&lt;T&amp;&gt;::transform</code></h3>
<p><b>Section:</b> 22.5.4.7 <a href="https://wg21.link/optional.ref.monadic">[optional.ref.monadic]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Giuseppe D'Angelo <b>Opened:</b> 2025-07-15 <b>Last modified:</b> 2025-10-16</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#optional.ref.monadic">active issues</a> in [optional.ref.monadic].</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.ref.monadic">issues</a> in [optional.ref.monadic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 22.5.4.7 <a href="https://wg21.link/optional.ref.monadic">[optional.ref.monadic]</a> the specification of <code>optional&lt;T&amp;&gt;::transform</code>
is missing an additional part of the <i>Mandates:</i> element compared to the primary template's
<code class='backtick'>transform</code> (in 22.5.3.8 <a href="https://wg21.link/optional.monadic">[optional.monadic]</a> p8); that is, is missing to enforce that
the <code class='backtick'>U</code> type is a valid contained type for <code class='backtick'>optional</code>.
<p/>
The definition of "valid contained type" comes from <a href="https://wg21.link/P2988R12" title=" std::optional<T&amp;>">P2988R12</a>. The paper
amended the <i>Mandates:</i> element of the primary template's <code class='backtick'>transform</code> to
use this definition. The fact that the same wording has not been applied to 
<code>optional&lt;T&amp;&gt;::transform</code> as well looks like an oversight. I would
suggest to apply it.
</p>

<p><i>[2025-10-16; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>
<p>
As
<code>optional&lt;remove_cv_t&lt;invoke_result_t&lt;F, T&amp;&gt;&gt;&gt;</code>
is part of the signature (return type), we never enter the body to trigger the
<i>Mandates</i>, so it's already implicitly ill-formed if the result of <code class='backtick'>f</code>
is not a valid contained type. It's worth clarifying that though."
</p>



<p id="res-4299"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>

<li><p>Modify 22.5.4.7 <a href="https://wg21.link/optional.ref.monadic">[optional.ref.monadic]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class F&gt;
  constexpr optional&lt;remove_cv_t&lt;invoke_result_t&lt;F, T&amp;&gt;&gt;&gt; transform(F&amp;&amp; f) const;
</pre>
<blockquote>
<p>
-4- Let <code class='backtick'>U</code> be <code>remove_cv_t&lt;invoke_result_t&lt;F, T&amp;&gt;&gt;</code>.
<p/>
-5- <i>Mandates</i>: <ins><code class='backtick'>U</code> is a valid contained type for <code class='backtick'>optional</code>.</ins> The declaration
</p>
<blockquote><pre>
U u(invoke(std::forward&lt;F&gt;(f), *val ));
</pre></blockquote>
<p>
is well-formed for some invented variable <code class='backtick'>u</code>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4300"><a href="#4300">4300</a><sup><a href="https://cplusplus.github.io/LWG/issue4300">(i)</a></sup>. Missing <i>Returns:</i> element in <code>optional&lt;T&amp;&gt;::emplace</code></h3>
<p><b>Section:</b> 22.5.4.3 <a href="https://wg21.link/optional.ref.assign">[optional.ref.assign]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Giuseppe D'Angelo <b>Opened:</b> 2025-07-15 <b>Last modified:</b> 2025-08-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification for <code>optional&lt;T&amp;&gt;::emplace</code> in 22.5.4.3 <a href="https://wg21.link/optional.ref.assign">[optional.ref.assign]</a>
is not specifying the returned value via a <i>Returns</i>: element; however the
function does indeed return something (a <code>T&amp;</code>). Such a <i>Returns</i>: element is there
for the primary template's <code class='backtick'>emplace</code> (cf. 22.5.3.4 <a href="https://wg21.link/optional.assign">[optional.assign]</a>).
</p>

<p><i>[2025-08-27; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after nine votes in favour during reflector poll.
</p>



<p id="res-4300"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>

<li><p>Modify 22.5.4.3 <a href="https://wg21.link/optional.ref.assign">[optional.ref.assign]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U&gt;
  constexpr T&amp; emplace(U&amp;&amp; u) noexcept(is_nothrow_constructible_v&lt;T&amp;, U&gt;);
</pre>
<blockquote>
<p>
-4- <i>Constraints</i>: [&hellip;]
<p/>
-5- <i>Effects</i>: Equivalent to: <code><i>convert-ref-init-val</i>(std::forward&lt;U&gt;(u))</code>.
<p/>
<ins>-?- <i>Returns</i>: <code>*<i>val</i></code>.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4301"><a href="#4301">4301</a><sup><a href="https://cplusplus.github.io/LWG/issue4301">(i)</a></sup>. <code class='backtick'>condition_variable{_any}::wait_{for, until}</code> should take timeout by value</h3>
<p><b>Section:</b> 32.7.4 <a href="https://wg21.link/thread.condition.condvar">[thread.condition.condvar]</a>, 32.7.5 <a href="https://wg21.link/thread.condition.condvarany">[thread.condition.condvarany]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hui Xie <b>Opened:</b> 2025-07-19 <b>Last modified:</b> 2025-08-29</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.condition.condvar">active issues</a> in [thread.condition.condvar].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
At the moment, both <code class='backtick'>condition_variable</code> and <code class='backtick'>condition_variable_any</code>'s 
<code class='backtick'>wait_for</code> and <code class='backtick'>wait_until</code> take the timeout <code class='backtick'>time_point</code>/<code class='backtick'>duration</code> by 
<code class='backtick'>const</code> reference. This can cause surprising behaviour. Given the following 
example (thanks to Tim Song):
</p>
<blockquote><pre>
struct Task {
  system_clock::time_point deadline;
  // stuff
};

std::mutex mtx;
std::condition_variable cv;
std::priority_queue&lt;Task, vector&lt;Task&gt;, CompareDeadlines&gt; queue;

// thread 1
std::unique_lock lck(mtx);
if (queue.empty()) { cv.wait(lck); }
else { cv.wait_until(lck, queue.top().deadline); }

// thread 2
std::lock_guard lck(mtx);
queue.push(/* some task */);
cv.notify_one();
</pre></blockquote>
<p>
From the user's point of view, it is sufficiently locked on both threads. However, 
due to the fact that the <code class='backtick'>time_point</code> is taken by reference, and that both libc++ 
and libstdc++'s implementation will read the value again after waking up, this 
will read a dangling reference of the <code class='backtick'>time_point</code>.
<p/>
Another example related to this issue:
<p/>
We (libc++) recently received a bug report on <code class='backtick'>condition_variable{_any}::wait_{for, until}</code>.
<p/>
Basically the user claims that these functions take <code class='backtick'>time_point</code>/<code class='backtick'>duration</code> by <code class='backtick'>const</code> 
reference, if the user modifies the <code class='backtick'>time_point</code>/<code class='backtick'>duration</code> on another thread with 
the same mutex, they can get unexpected return value for <code class='backtick'>condition_variable</code>, and 
data race for <code class='backtick'>conditional_variable_any</code>.
<p/>
Bug report <a href="https://github.com/llvm/llvm-project/pull/148330#issuecomment-3065062889">here</a>.
<p/>
Reproducer (libstdc++ has the same behaviour as ours) <a href="https://godbolt.org/z/GnY35T3hn">on godbolt</a>.
</p>
<blockquote><pre>
std::mutex mutex;
std::condition_variable cv;
auto timeout = std::chrono::steady_clock::time_point::max();

// Thread 1:
std::unique_lock lock(mutex);
const auto status = cv.wait_until(lock, timeout);

// Thread 2:
std::unique_lock lock(mutex);
cv.notify_one();
timeout = std::chrono::steady_clock::time_point::min();
</pre></blockquote>
<p>
So basically the problem was that when we return whether there is <code class='backtick'>no_timeout</code> or <code class='backtick'>timeout</code> 
at the end of the function, we read the <code class='backtick'>const</code> reference again, which can be changed since 
the beginning of the function. For <code class='backtick'>condition_variable</code>, it is "unexpected results" according 
to the user. And in <code class='backtick'>conditional_variable_any</code>, we actually unlock the user lock and acquire 
our internal lock, then read the input again, so this is actually a data race.
<p/>
For <code class='backtick'>wait_for</code>, the spec has 
</p>
<blockquote>
<p>
<i>Effects</i>: Equivalent to: <code>return wait_until(lock, chrono::steady_clock::now() + rel_time);</code>
</p>
</blockquote>
<p>
So the user can claim our implementation is not conforming because the spec says there needs 
to be a temporary <code class='backtick'>time_point</code> (<code class='backtick'>now + duration</code>) created and since it should operate on this 
temporary <code class='backtick'>time_point</code>. There shouldn't be any unexpected behaviour or data race .
<p/>
For <code class='backtick'>wait_until</code> it is unclear whether the spec has implications that implementations are allowed 
to read <code class='backtick'>abs_time</code> while the user's lock is unlocked. 
<p/>
it is also unclear if an implementation is allowed to return <code class='backtick'>timeout</code> if <code class='backtick'>cv</code> indeed does 
not wait longer than the original value of <code class='backtick'>timeout</code>. If it is not allowed, implementations 
will have to make a local copy of the input <code class='backtick'>rel_time</code> or <code class='backtick'>abs_time</code>, which defeats the purpose 
of taking arguments by <code class='backtick'>const</code> reference.
<p/>
For both of the examples, Ville has a great comment in the reflector:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
It seems like a whole bag of problems goes away if these functions just take the timeout by value?
</p>
</blockquote>
<p>
libc++ implementers have strong preference just changing the API to take these arguments by value, 
and it is not an ABI break for us as the function signature has changed.
</p>

<p><i>[2025-08-29; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after nine votes in favour during reflector poll.
</p>



<p id="res-4301"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>

<li><p>Modify 32.7.4 <a href="https://wg21.link/thread.condition.condvar">[thread.condition.condvar]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std {
  class condition_variable {
  public:
    [&hellip;]
    template&lt;class Predicate&gt;
      void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
    template&lt;class Clock, class Duration&gt;
      cv_status wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                           <del>const</del> chrono::time_point&lt;Clock, Duration&gt;<del>&amp;</del> abs_time);
    template&lt;class Clock, class Duration, class Predicate&gt;
      bool wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                      <del>const</del> chrono::time_point&lt;Clock, Duration&gt;<del>&amp;</del> abs_time,
                      Predicate pred);
    template&lt;class Rep, class Period&gt;
      cv_status wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                         <del>const</del> chrono::duration&lt;Rep, Period&gt;<del>&amp;</del> rel_time);
    template&lt;class Rep, class Period, class Predicate&gt;
      bool wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                    <del>const</del> chrono::duration&lt;Rep, Period&gt;<del>&amp;</del> rel_time,
                    Predicate pred);    
    [&hellip;]
  };
}
</pre>
</blockquote>
[&hellip;]
<pre>
template&lt;class Clock, class Duration&gt;
  cv_status wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                       <del>const</del> chrono::time_point&lt;Clock, Duration&gt;<del>&amp;</del> abs_time);
</pre>
<blockquote>
<p>
-17- <i>Preconditions</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class Rep, class Period&gt;
  cv_status wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                     <del>const</del> chrono::duration&lt;Rep, Period&gt;<del>&amp;</del> rel_time);
</pre>
<blockquote>
<p>
-23- <i>Preconditions</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class Clock, class Duration, class Predicate&gt;
  bool wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                  <del>const</del> chrono::time_point&lt;Clock, Duration&gt;<del>&amp;</del> abs_time,
                  Predicate pred);
</pre>
<blockquote>
<p>
-29- <i>Preconditions</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class Rep, class Period, class Predicate&gt;
  bool wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                <del>const</del> chrono::duration&lt;Rep, Period&gt;<del>&amp;</del> rel_time,
                Predicate pred);    
</pre>
<blockquote>
<p>
-35- <i>Preconditions</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 32.7.5.1 <a href="https://wg21.link/thread.condition.condvarany.general">[thread.condition.condvarany.general]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  class condition_variable_any {
  public:
    [&hellip;]
    // <i>32.7.5.2 <a href="https://wg21.link/thread.condvarany.wait">[thread.condvarany.wait]</a>, noninterruptible waits</i>
    template&lt;class Lock&gt;
      void wait(Lock&amp; lock);
    template&lt;class Lock, class Predicate&gt;
      void wait(Lock&amp; lock, Predicate pred);
    
    template&lt;class Lock, class Clock, class Duration&gt;
      cv_status wait_until(Lock&amp; lock, <del>const</del> chrono::time_point&lt;Clock, Duration&gt;<del>&amp;</del> abs_time);
    template&lt;class Lock, class Clock, class Duration, class Predicate&gt;
      bool wait_until(Lock&amp; lock, <del>const</del> chrono::time_point&lt;Clock, Duration&gt;<del>&amp;</del> abs_time,
                      Predicate pred);
    template&lt;class Lock, class Rep, class Period&gt;
      cv_status wait_for(Lock&amp; lock, <del>const</del> chrono::duration&lt;Rep, Period&gt;<del>&amp;</del> rel_time);
    template&lt;class Lock, class Rep, class Period, class Predicate&gt;
      bool wait_for(Lock&amp; lock, <del>const</del> chrono::duration&lt;Rep, Period&gt;<del>&amp;</del> rel_time, Predicate pred);
   
    // <i>32.7.5.3 <a href="https://wg21.link/thread.condvarany.intwait">[thread.condvarany.intwait]</a>, interruptible waits</i>
    template&lt;class Lock, class Predicate&gt;
      bool wait(Lock&amp; lock, stop_token stoken, Predicate pred);
    template&lt;class Lock, class Clock, class Duration, class Predicate&gt;
      bool wait_until(Lock&amp; lock, stop_token stoken,
                      <del>const</del> chrono::time_point&lt;Clock, Duration&gt;<del>&amp;</del> abs_time, Predicate pred);
    template&lt;class Lock, class Rep, class Period, class Predicate&gt;
      bool wait_for(Lock&amp; lock, stop_token stoken,
                    <del>const</del> chrono::duration&lt;Rep, Period&gt;<del>&amp;</del> rel_time, Predicate pred);
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 32.7.5.2 <a href="https://wg21.link/thread.condvarany.wait">[thread.condvarany.wait]</a> as indicated:</p>

<blockquote>
[&hellip;]
<pre>
template&lt;class Lock, class Clock, class Duration&gt;
  cv_status wait_until(Lock&amp; lock, <del>const</del> chrono::time_point&lt;Clock, Duration&gt;<del>&amp;</del> abs_time);
</pre>
<blockquote>
<p>
-6- <i>Effects</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class Lock, class Rep, class Period&gt;
  cv_status wait_for(Lock&amp; lock, <del>const</del> chrono::duration&lt;Rep, Period&gt;<del>&amp;</del> rel_time);
</pre>
<blockquote>
<p>
-11- <i>Effects</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class Lock, class Clock, class Duration, class Predicate&gt;
  bool wait_until(Lock&amp; lock, <del>const</del> chrono::time_point&lt;Clock, Duration&gt;<del>&amp;</del> abs_time,
                  Predicate pred);
</pre>
<blockquote>
<p>
-16- <i>Effects</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class Lock, class Rep, class Period, class Predicate&gt;
  bool wait_for(Lock&amp; lock, <del>const</del> chrono::duration&lt;Rep, Period&gt;<del>&amp;</del> rel_time, Predicate pred);
</pre>
<blockquote>
<p>
-19- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 32.7.5.3 <a href="https://wg21.link/thread.condvarany.intwait">[thread.condvarany.intwait]</a> as indicated:</p>

<blockquote>
[&hellip;]
<pre>
template&lt;class Lock, class Clock, class Duration, class Predicate&gt;
  bool wait_until(Lock&amp; lock, stop_token stoken,
                  <del>const</del> chrono::time_point&lt;Clock, Duration&gt;<del>&amp;</del> abs_time, Predicate pred);
</pre>
<blockquote>
<p>
-7- <i>Effects</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class Lock, class Rep, class Period, class Predicate&gt;
  bool wait_for(Lock&amp; lock, stop_token stoken,
                <del>const</del> chrono::duration&lt;Rep, Period&gt;<del>&amp;</del> rel_time, Predicate pred);
</pre>
<blockquote>
<p>
-13- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4305"><a href="#4305">4305</a><sup><a href="https://cplusplus.github.io/LWG/issue4305">(i)</a></sup>. Missing user requirements on <code class='backtick'>type_order</code> template</h3>
<p><b>Section:</b> 17.12.7 <a href="https://wg21.link/compare.type">[compare.type]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Krügler <b>Opened:</b> 2025-07-27 <b>Last modified:</b> 2025-10-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The recently approved paper <a href="https://wg21.link/P2830R10" title=" Standardized Constexpr Type Ordering">P2830R10</a> proposes to add the new <code class='backtick'>type_order</code>
type traits to 17.12 <a href="https://wg21.link/cmp">[cmp]</a> (and thus outside of 21.3 <a href="https://wg21.link/type.traits">[type.traits]</a>), 
which has the subtle and most likely unintended effect, that it doesn't fall under the 
general requirement expressed in 21.3.2 <a href="https://wg21.link/meta.rqmts">[meta.rqmts]</a> p4,
</p>
<blockquote><p>
Unless otherwise specified, the behavior of a program that adds specializations for 
any of the templates specified in 21.3.2 <a href="https://wg21.link/meta.rqmts">[meta.rqmts]</a> is undefined.
</p></blockquote>
<p>
and so in principle the explicit allowance specified in 16.4.5.2.1 <a href="https://wg21.link/namespace.std">[namespace.std]</a> p2,
</p>
<blockquote><p>
Unless explicitly prohibited, a program may add a template specialization for any standard 
library class template to namespace <code class='backtick'>std</code> [&hellip;]
</p></blockquote>
<p>
holds. So we need to add extra wording to the <code class='backtick'>type_order</code> specification in 
17.12.7 <a href="https://wg21.link/compare.type">[compare.type]</a> to prohibit such program specializations.
<p/>
This was reported shortly before the Sofia meeting 
<a href="https://lists.isocpp.org/lib/2025/06/31725.php">during reflector discussion</a>  
but seems to be forgotten before the final paper appeared on plenary. 
<p/>
During the reflector discussion two possible ways to solve this issue were pointed out:
</p>
<ol>
<li><p>The most simple one would mimic the wording in 21.3.2 <a href="https://wg21.link/meta.rqmts">[meta.rqmts]</a> p4
quoted above.</p></li>
<li><p>Instead of introducing just another undefined opportunity to run into undefined
behaviour it has been pointed out that we could follow the approach taken by <code class='backtick'>std::initializer_list</code>
and make the program ill-formed in this case, as specified in 17.11.2 <a href="https://wg21.link/initializer.list.syn">[initializer.list.syn]</a> p2:
</p>
<blockquote><p>
If an explicit specialization or partial specialization of <code class='backtick'>initializer_list</code> is declared, 
the program is ill-formed.
</p></blockquote>
</li>
</ol>
Jonathan Wakely responded to the reflector discussion:
<blockquote><p>
I think ill-formed would be better. It shouldn't be difficult for implementations to have special cases that are disallowed. 
</p></blockquote>
<p>
Given the already existing experience with <code class='backtick'>std::initializer_list</code> the proposed wording below
therefore follows the ill-formed program approach.
</p>

<p><i>[2025-10-14; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-4305"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>

<li><p>Modify 17.12.7 <a href="https://wg21.link/compare.type">[compare.type]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class U&gt;
  struct type_order;
</pre>
<blockquote>
<p>
-2- The name <code class='backtick'>type_order</code> denotes a <i>Cpp17BinaryTypeTrait</i> (21.3.2 <a href="https://wg21.link/meta.rqmts">[meta.rqmts]</a>) with a base 
characteristic of <code>integral_constant&lt;strong_ordering, <i>TYPE-ORDER</i>(T, U)&gt;</code>.
<p/>
<ins>-?- If an explicit specialization or partial specialization of <code class='backtick'>type_order</code> is declared, the program is ill-formed.</ins>
<p/>
-3- <i>Recommended practice</i>: The order should be lexicographical on parameter-type-lists and template
argument lists.
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="4312"><a href="#4312">4312</a><sup><a href="https://cplusplus.github.io/LWG/issue4312">(i)</a></sup>. Const and value category mismatch for <code class='backtick'>allocator_arg_t</code>/<code class='backtick'>allocator_arg</code> in the description 
of uses-allocator construction</h3>
<p><b>Section:</b> 20.2.8.2 <a href="https://wg21.link/allocator.uses.construction">[allocator.uses.construction]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-08-06 <b>Last modified:</b> 2025-10-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.uses.construction">active issues</a> in [allocator.uses.construction].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.uses.construction">issues</a> in [allocator.uses.construction].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, 20.2.8.2 <a href="https://wg21.link/allocator.uses.construction">[allocator.uses.construction]</a> bullet 2.2 states:
</p>
<blockquote><p>
Otherwise, if <code class='backtick'>T</code> has a constructor invocable as <code class='backtick'>T(allocator_arg, alloc, args...)</code> (leading-allocator convention), 
[&hellip;]
</p></blockquote>
<p>
However, when forming construction arguments in the utility functions, we're actually using <i>cv</i>-unqualified 
rvalue of <code class='backtick'>allocator_arg_t</code>, which can be inferred from using plain <code class='backtick'>allocator_arg_t</code> but not 
<code>const allocator_arg_t&amp;</code> in 20.2.8.2 <a href="https://wg21.link/allocator.uses.construction">[allocator.uses.construction]</a> bullet 5.2.
<p/>
It seems that such mismatch was present even since C++11 (per <a href="https://wg21.link/N3337" title=" Working Draft, Standard for Programming Language C++">N3337</a> [allocator.uses.construction]/1.2). 
If the use of plain <code class='backtick'>allocator_arg_t</code> is considered correct, I think we should fix the description.
</p>

<p><i>[2025-10-14; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>
<p>
Unless the <code class='backtick'>std::allocator_arg</code> tag object is not supposed to be used,
wouldn't it make more sense to preserve the
"if <code class='backtick'>T</code> has a constructor invocable as <code class='backtick'>T(allocator_arg, alloc, args...)</code>"
wording and change every <code class='backtick'>allocator_arg_t</code> into
<code>const allocator_arg_t&amp;</code>, so that we check for construction
from the const tag object, and then actually use a const value in the
constructor arguments.
Strongly don't care though.
</p>



<p id="res-4312"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>

<li><p>Modify 20.2.8.2 <a href="https://wg21.link/allocator.uses.construction">[allocator.uses.construction]</a> as indicated:</p>

<blockquote>
<p>
-2- The following utility functions support three conventions for passing <code class='backtick'>alloc</code> to a constructor:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; [&hellip;]</p></li>
<li><p>(2.2) &mdash; Otherwise, if <code class='backtick'>T</code> has a constructor invocable as 
<code>T(<del>allocator_arg</del><ins>allocator_arg_t{}</ins>, alloc, args...)</code> 
(leading-allocator convention), then uses-allocator construction chooses this constructor form.</p></li>
<li><p>(2.3) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4317"><a href="#4317">4317</a><sup><a href="https://cplusplus.github.io/LWG/issue4317">(i)</a></sup>. The meaning of "resource" in the <i>Cpp17Destructible</i> requirements is undefined</h3>
<p><b>Section:</b> 16.4.4.2 <a href="https://wg21.link/utility.arg.requirements">[utility.arg.requirements]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-08-15 <b>Last modified:</b> 2025-10-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#utility.arg.requirements">active issues</a> in [utility.arg.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The meaning of "resource" in the <i>Cpp17Destructible</i> requirements cannot be inferred 
from the standard wording and it seems unlikely that the standard will determine its meaning 
in the future. What are considered as resources generally depends on users' intent, so the 
standard shouldn't determine the well-definedness of a program execution due to it. Moreover, 
the wording doesn't seem to consider shared ownership, which can be represented by <code class='backtick'>shared_ptr</code>.
</p>

<p><i>[2025-10-14; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-4317"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>

<li><p>Modify 16.4.4.2 <a href="https://wg21.link/utility.arg.requirements">[utility.arg.requirements]</a>, Table 35 [tab:cpp17.destructible] as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 35 &mdash; <code>Cpp17Destructible</code> requirements [tab:cpp17.destructible]</caption>
<tr>
<th>Expression</th>
<th>Post-condition</th>
</tr>
<tr>
<td>
<code>u.~T()</code>
</td>
<td>
<del>All resources owned by <code class='backtick'>u</code> are reclaimed, n</del><ins>N</ins>o exception is propagated.
</td>
</tr>
<tr>
<td colspan="2">
[<i>Note 3:</i> Array types and non-object types are not <i>Cpp17Destructible</i>. &mdash; <i>end note</i>]
</td>
</tr>
</table>

</blockquote>

</li>

</ol>





<hr>
<h3 id="4318"><a href="#4318">4318</a><sup><a href="https://cplusplus.github.io/LWG/issue4318">(i)</a></sup>. Have <code class='backtick'>hive::erase_if</code> reevaluate <code class='backtick'>end()</code> to avoid UB</h3>
<p><b>Section:</b> 23.3.9.6 <a href="https://wg21.link/hive.erasure">[hive.erasure]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Frank Birbacher <b>Opened:</b> 2025-08-16 <b>Last modified:</b> 2025-08-29</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#hive.erasure">issues</a> in [hive.erasure].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Background:  <a href="https://github.com/cplusplus/draft/pull/8162">https://github.com/cplusplus/draft/pull/8162</a>
<p/>
For 23.3.9.6 <a href="https://wg21.link/hive.erasure">[hive.erasure]</a> p2, the defining code must not cache the end-iterator. In case the last 
element of the sequence is removed, the past-the-end iterator will be invalidated. This will trigger UB 
in the loop condition. Instead, re-evaluate <code class='backtick'>end()</code> each time.
</p>

<p><i>[2025-08-29; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-4318"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> There are other ways to fix this code while keeping the caching behaviour, but I don't 
see any particular reason to do so for the definition of the effects.]
</p>
</blockquote>

<ol>

<li><p>Modify 23.3.9.6 <a href="https://wg21.link/hive.erasure">[hive.erasure]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class Allocator, class Predicate&gt;
  typename hive&lt;T, Allocator&gt;::size_type
    erase_if(hive&lt;T, Allocator&gt;&amp; c, Predicate pred);
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
auto original_size = c.size();
for (auto i = c.begin()<del>, last = c.end()</del>; i != <del>last</del><ins>c.end()</ins>; ) {
  if (pred(*i)) {
    i = c.erase(i);
  } else {
    ++i;
  }
}
return original_size - c.size();
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4340"><a href="#4340">4340</a><sup><a href="https://cplusplus.github.io/LWG/issue4340">(i)</a></sup>. <code>task::promise_type::unhandled_stopped()</code> should be <code>noexcept</code></h3>
<p><b>Section:</b> 33.13.6.5 <a href="https://wg21.link/task.promise">[task.promise]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Dietmar Kühl <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-10-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.promise">active issues</a> in [task.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.promise">issues</a> in [task.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The function <code>task::promise_type::unhandled_stopped()</code>
is called from <code>set_stopped()</code> of a receiver and calls
<code>set_stopped</code> itself. These functions are required to
be <code>noexcept</code>. Thus, <code>unhandled_stopped()</code>
can't throw an exception and should be marked <code>noexcept</code>.
All other declarations of <code>unhandled_stopped()</code> are
already marked <code>noexcept</code> but
<code>task::promise_type::unhandled_stopped()</code> isn't.
</p>

<p><i>[2025-10-17; Reflector poll.]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>


<p id="res-4340"><b>Proposed resolution:</b></p>
<p>
In the synopsis in 33.13.6.5 <a href="https://wg21.link/task.promise">[task.promise]</a> add <code>noexcept</code>
to the declaration of <code>task::promise_type::unhandled_stopped()</code>:
<blockquote><pre>
namespace std::execution {
  template&lt;class T, class Environment&gt;
  class task&lt;T, Environment&gt;::promise_type {
     ...
    coroutine_handle&lt;&gt; unhandled_stopped() <ins>noexcept</ins>;
    ...
  };
}
</pre></blockquote>
</p>
<p>
In the specification in 33.13.6.5 <a href="https://wg21.link/task.promise">[task.promise]</a> paragraph 13 add <code>noexcept</code>:
<blockquote>
<pre>
coroutine_handle&lt;&gt; unhandled_stopped() <ins>noexcept</ins>;
</pre>
<p>-13- <i>Effects</i>: Completes the asynchronous operation
associated with <code><i>STATE</i>(*this)</code> by invoking
<code>set_stopped(std::move(<i>RCVR</i>(*this)))</code>.</p>
</blockquote> 
</p>





<hr>
<h3 id="4341"><a href="#4341">4341</a><sup><a href="https://cplusplus.github.io/LWG/issue4341">(i)</a></sup>. Missing rvalue reference qualification for <code>task::connect()</code></h3>
<p><b>Section:</b> 33.13.6.2 <a href="https://wg21.link/task.class">[task.class]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Dietmar Kühl <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-10-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.class">active issues</a> in [task.class].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.class">issues</a> in [task.class].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Coroutines can't be copied. Thus, a <code>task</code> can be
<code>connect()</code> just once.  To represent that
<code>task::connect()</code> should be rvalue reference qualified
but currently it isn't.
</p>

<p><i>[2025-10-17; Reflector poll.]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>
<p>
"It's nice to rvalue qualify such a function, but it is not strictly necessary."
</p>


<p id="res-4341"><b>Proposed resolution:</b></p>
<p>
In the synopsis in 33.13.6.2 <a href="https://wg21.link/task.class">[task.class]</a> add rvalue
reference qualification to <code>task::connect()</code>:
<blockquote><pre>
namespace std::execution {
  template&lt;class T, class Environment&gt;
  class task {
    ...
    template&lt;receiver Rcvr&gt;
        <i>state</i>&lt;Rcvr&gt; connect(Rcvr&amp;&amp; rcvr) <ins>&amp;&amp;</ins>;
    ...
  }
}
</pre></blockquote>
</p>
<p>
In the specification in 33.13.6.3 <a href="https://wg21.link/task.members">[task.members]</a> paragraph 3 add rvalue
reference qualification to <code>task::connect()</code>:
<blockquote>
<pre>
template&lt;receiver Rcvr&gt;
    <i>state</i>&lt;Rcvr&gt; connect(Rcvr&amp;&amp; rcvr) <ins>&amp;&amp;</ins>;
</pre>
<p>-3- <i>Precondition</i>: <code>bool(handle)</code> is <code>true</code>.</p>
<p>-4- <i>Effects</i>: Equivalent to:</p>
<pre>    return state&lt;Rcvr&gt;(exchange(handle, {}), std::forward&lt;Rcvr&gt;(recv));</pre>
</blockquote>
</p>





<hr>
<h3 id="4342"><a href="#4342">4342</a><sup><a href="https://cplusplus.github.io/LWG/issue4342">(i)</a></sup>. Missing rvalue reference qualification for <code>task_scheduler::ts-sender::connect()</code></h3>
<p><b>Section:</b> 33.13.5 <a href="https://wg21.link/exec.task.scheduler">[exec.task.scheduler]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Dietmar Kühl <b>Opened:</b> 2025-09-01 <b>Last modified:</b> 2025-10-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.task.scheduler">active issues</a> in [exec.task.scheduler].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.task.scheduler">issues</a> in [exec.task.scheduler].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The result of <code>schedule(sched)</code> for a scheduler
<code>sched</code> is only required to be movable. An object of
this type may need to be forwarded to an operation state constructor
by <code>task_scheduler::<i>ts-sender</i>::connect</code>. Thus,
this function should be qualified with an rvalue reference.
</p>

<p><i>[2025-10-17; Reflector poll.]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>


<p id="res-4342"><b>Proposed resolution:</b></p>
<p>
Add an rvalue qualifier to the declaration of <code>connect</code> in 33.13.5 <a href="https://wg21.link/exec.task.scheduler">[exec.task.scheduler]</a> paragraph 8:
<blockquote>
<pre>
namespace std::execution {
  class task_scheduler::ts-sender {     // exposition only
  public:
    using sender_concept = sender_t;

    template&lt;receiver Rcvr&gt;
      <i>state</i>&lt;Rcvr&gt; connect(Rcvr&amp;&amp; rcvr)<ins> &amp;&amp;</ins>;
  };
}
</pre>
</blockquote>
</p>
<p>
In the specification in 33.13.5 <a href="https://wg21.link/exec.task.scheduler">[exec.task.scheduler]</a> paragraph 10 add an rvalue qualifier to <code>connect</code>:
<blockquote>
<pre>
template&lt;receiver Rcvr&gt;
  <i>state</i>&lt;Rcvr&gt; connect(Rcvr&amp;&amp; rcvr)<ins> &amp;&amp;</ins>;
</pre>
<p>-10- <i>Effects</i>: Let <i>r</i> be an object of a type that
models receiver and whose completion handlers result in invoking
the corresponding completion handlers of <code>rcvr</code> or copy thereof.
Returns an object of type <code><i>state</i>&lt;Rcvr&gt;</code> containing an operation state
object initialized with <code>connect(<i>SENDER</i>(*this), std::move(<i>r</i>))</code>.
</p>
</blockquote>
</p>





<hr>
<h3 id="4343"><a href="#4343">4343</a><sup><a href="https://cplusplus.github.io/LWG/issue4343">(i)</a></sup>. Missing default template arguments for <code>task</code></h3>
<p><b>Section:</b> 33.13.6.2 <a href="https://wg21.link/task.class">[task.class]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Dietmar Kühl <b>Opened:</b> 2025-09-01 <b>Last modified:</b> 2025-10-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.class">active issues</a> in [task.class].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.class">issues</a> in [task.class].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The design discussion of <code>task</code> describes defaults for
the two template parameters <code>T</code> and <code>Environment</code>
of <code>task</code> but these defaults are not reflected in the
synopsis of 33.13.6.2 <a href="https://wg21.link/task.class">[task.class]</a>.
This is an oversight and should be fixed.  The default for
<code>T</code> should be <code>void</code> and the default for
<code>Environment</code> should be <code>env&lt;&gt;</code> (the
design paper used <code>empty_env</code> but this <code>struct</code>
was replaced by the class template <code>env</code> by <a href="https://wg21.link/P3325R5" title=" A Utility for Creating Execution Environments">P3325R5</a>).
</p>
<p>
There could be a counter argument to defining a default for the
<code>Environment</code> template parameter: this type is used to
determine various customizations of <code>task</code>, e.g., the
<code>allocator_type</code>, the <code>scheduler_type</code>, and
the <code>stop_source_type</code>. Leaving the type a required
argument means that a future standard could choose a possibly better
default than the types determined when the <code>Environment</code>
doesn't define them. On the other hand, a future standard could
provide a suitable alias with modified types under a different
name and/or a different namespace. Based on the LEWG discussion
on 2025-08-26 the direction is to add the default arguments.
</p>

<p><i>[2025-10-17; Reflector poll.]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>


<p id="res-4343"><b>Proposed resolution:</b></p>
<p>
Add default template arguments for <code>task</code> for
<code>T = void</code> and <code>Environment = env&lt;&gt;</code>
in the synopsis of 33.13.6.2 <a href="https://wg21.link/task.class">[task.class]</a>:
<blockquote><pre>
namespace std::execution {
  template&lt;class T <ins>= void</ins>, class Environment <ins>= env&lt;&gt;</ins>&gt;
  class task {
     ...
  };
}
</pre></blockquote>
</p>





<hr>
<h3 id="4345"><a href="#4345">4345</a><sup><a href="https://cplusplus.github.io/LWG/issue4345">(i)</a></sup>. <code>task::promise_type::return_value</code> default template parameter</h3>
<p><b>Section:</b> 33.13.6.5 <a href="https://wg21.link/task.promise">[task.promise]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Dietmar Kühl <b>Opened:</b> 2025-09-01 <b>Last modified:</b> 2025-10-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.promise">active issues</a> in [task.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.promise">issues</a> in [task.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The template parameter <code>V</code> of
<code>task::promise_type::return_value</code> doesn't have a default
template argument specified. Specifying a default template argument of <code>T</code>
would enable use of <code>co_return { ... }</code> which would be
consistent with normal <code>return</code> statements. This feature
was not discussed in the design paper but based on the LEWG discussion
on 2025-08-26 it is considered to be more a bug fix than a new feature.
</p>

<p><i>[2025-10-17; Reflector poll.]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>


<p id="res-4345"><b>Proposed resolution:</b></p>
<p>
Add a default template argument of <code>T</code> to the template
parameter <code>V</code> of <code>task::promise_type::return_value</code>
in the synopsis of 33.13.6.5 <a href="https://wg21.link/task.promise">[task.promise]</a>:
<blockquote><pre>
namespace std::execution {
  template&lt;class T, class Environment&gt;
  class task&lt;T, Environment&gt;::promise_type {
     ...
    template&lt;typename V <ins>= T</ins>&gt;
    void return_value(V&amp;&amp; value);
    ...
  };

}
</pre></blockquote>
</p>





<hr>
<h3 id="4349"><a href="#4349">4349</a><sup><a href="https://cplusplus.github.io/LWG/issue4349">(i)</a></sup>. <code>task</code> is not actually started lazily</h3>
<p><b>Section:</b> 33.13.6.5 <a href="https://wg21.link/task.promise">[task.promise]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Dietmar Kühl <b>Opened:</b> 2025-09-01 <b>Last modified:</b> 2025-10-18</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.promise">active issues</a> in [task.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.promise">issues</a> in [task.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording for <code>task&lt;...&gt;::promise_type::initial_suspend</code>
in 33.13.6.5 <a href="https://wg21.link/task.promise">[task.promise]</a> paragraph 6
(second bullet) may imply that a task is eagerly started, i.e., that the
awaiter return from <code>initial_suspend()</code> immediately starts
the scheduling operation and cause the <code>task</code> to be resumed. At
the very least the second bullet of the wording should be clarified such
that the scheduling operation is only started when the coroutine gets
resumed.
</p>
<p>
An alternative resolution it have <code>initial_suspend()</code>
return <code>std::suspend_always</code> implicitly requiring that
the <code>task</code> gets <code>start()</code>ed from the correct
execution context. This approach has the advantage of avoiding
unnecessary scheduling operations for the likely common case when
<code>task</code>s are started from the correct context.
</p>

<p><i>[2025-10-18; Reflector poll.]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>


<p id="res-4349"><b>Proposed resolution:</b></p>
<p>
Change the declaration of <code>initial_suspend()</code> in the synopsis
of 33.13.6.5 <a href="https://wg21.link/task.promise">[task.promise]</a> to use
<code>suspend_always</code>, directly provide a definition, and add
various qualifiers:
<blockquote>
<pre>
namespace std::execution {
  template&lt;class T, class Environment&gt;
  class task&lt;T, Environment&gt;::promise_type {
    ...
    <del>auto</del><ins>static constexpr suspend_always</ins> initial_suspend() noexcept<del>;</del><ins>{ return {}; }</ins>
    ...
  };

}
</pre>
</blockquote>
</p>
<p>
Remove 33.13.6.5 <a href="https://wg21.link/task.promise">[task.promise]</a> paragraph 6 entirely:
<blockquote>
<pre><del>auto initial_suspend() noexcept;</del></pre>
<p><del>-6- <i>Returns:</i> An awaitable object of unspecified type ([expr.await]) whose member functions arrange for</del></p>
<p><del>-6.1- - the calling coroutine to be suspended,</del></p>
<p><del>-6.2- - the coroutine to be resumed on an execution agent of the execution resource associated with <code><i>SCHED</i>(*this)</code>.</del></p>
</blockquote>
</p>





<hr>
<h3 id="4351"><a href="#4351">4351</a><sup><a href="https://cplusplus.github.io/LWG/issue4351">(i)</a></sup>. <code><i>integral-constant-like</i></code> needs more <code class='backtick'>remove_cvref_t</code></h3>
<p><b>Section:</b> 23.7.2.1 <a href="https://wg21.link/span.syn">[span.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-09-05 <b>Last modified:</b> 2025-10-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P2781R9" title=" std::constexpr_wrapper">P2781R9</a> tweaked the definition of
<code><i>integral-constant-like</i></code> to work with <code class='backtick'>constant_wrapper</code>,
like so:
</p>
<blockquote>
<pre>
template&lt;class T&gt;
    concept <i>integral-constant-like</i> =                    <i>// exposition only</i>
      is_integral_v&lt;<ins>remove_cvref_t&lt;</ins>decltype(T::value)<ins>&gt;</ins>&gt; &amp;&amp;
      !is_same_v&lt;bool, remove_const_t&lt;decltype(T::value)&gt;&gt; &amp;&amp;
      convertible_to&lt;T, decltype(T::value)&gt; &amp;&amp;
      equality_comparable_with&lt;T, decltype(T::value)&gt; &amp;&amp;
      bool_constant&lt;T() == T::value&gt;::value &amp;&amp;
      bool_constant&lt;static_cast&lt;decltype(T::value)&gt;(T()) == T::value&gt;::value;
</pre>
</blockquote>
<p>
This was done so that <code>cw&lt;5&gt;</code> models the concept,
but it needs an additional tweak so that
<code>cw&lt;true&gt;</code> does not model it.
</p>

<p><i>[2025-10-17; Reflector poll.]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>


<p id="res-4351"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>

<li><p>Modify 23.7.2.1 <a href="https://wg21.link/span.syn">[span.syn]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
    concept <i>integral-constant-like</i> =                    <i>// exposition only</i>
      is_integral_v&lt;remove_cvref_t&lt;decltype(T::value)&gt;&gt; &amp;&amp;
      !is_same_v&lt;bool, remove_<ins>cvref</ins><del>const</del>_t&lt;decltype(T::value)&gt;&gt; &amp;&amp;
      convertible_to&lt;T, decltype(T::value)&gt; &amp;&amp;
      equality_comparable_with&lt;T, decltype(T::value)&gt; &amp;&amp;
      bool_constant&lt;T() == T::value&gt;::value &amp;&amp;
      bool_constant&lt;static_cast&lt;decltype(T::value)&gt;(T()) == T::value&gt;::value;
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4362"><a href="#4362">4362</a><sup><a href="https://cplusplus.github.io/LWG/issue4362">(i)</a></sup>. Inconsistent usage of <code class='backtick'>constexpr</code> for <code class='backtick'>inplace_stop_token</code> and <code class='backtick'>inplace_stop_source</code></h3>
<p><b>Section:</b> 32.3.8 <a href="https://wg21.link/stoptoken.inplace">[stoptoken.inplace]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2025-08-28 <b>Last modified:</b> 2025-10-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code class='backtick'>inplace_stop_source::get_token()</code> member function is declared <code class='backtick'>constexpr</code>, 
but there are no <code class='backtick'>constexpr</code> member-functions declared on <code class='backtick'>inplace_stop_token</code>, 
making the utility of being able to call this member function during constant 
evaluation limited.
<p/>
Should the member functions of <code class='backtick'>inplace_stop_token</code> also be declared <code class='backtick'>constexpr</code>?
i.e. <code class='backtick'>operator==</code>, <code class='backtick'>swap()</code>, <code class='backtick'>stop_possible()</code> and <code class='backtick'>stop_requested()</code>.
<p/>
The <code class='backtick'>operator==</code> and <code class='backtick'>stop_possible()</code> and <code class='backtick'>swap()</code> member functions should be 
able to be made <code class='backtick'>constexpr</code> trivially as they are just required to compare/modify 
pointers to the associated stop source.
<p/>
The <code class='backtick'>stop_requested()</code> member function is specified to be equivalent to calling 
<code class='backtick'>stop_requested()</code> on the associated <code class='backtick'>inplace_stop_source</code> (if any), which is not 
currently declared <code class='backtick'>constexpr</code> primarily because its implementation requires 
synchronisation/atomic operations.
<p/>
Now that <code class='backtick'>std::atomic</code> operations are now <code class='backtick'>constexpr</code>, it may be possible/appropriate 
for <code class='backtick'>stop_requested()</code> on both <code class='backtick'>inplace_stop_source</code> and <code class='backtick'>inplace_stop_token</code> to also 
be declared <code class='backtick'>constexpr</code>.
</p>
<p><i>[2025-10-17; Reflector poll. Status changed: New &rarr; Tentatively NAD.]</i></p>

<p>
This allows constant-initializing a token, it's basically a constructor.
Other member functions don't need to be constexpr,
similar to how <code class='backtick'>std::mutex::lock()</code> doesn't need to be constexpr
for constant-init of <code class='backtick'>std::mutex</code> to be useful.
</p>


<p id="res-4362"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i>: This is the minimum proposed wording change. Additionally, consider adding 
<code class='backtick'>constexpr</code> to the declaration of <code class='backtick'>inplace_stop_token::stop_requested()</code> (in 
32.3.8.1 <a href="https://wg21.link/stoptoken.inplace.general">[stoptoken.inplace.general]</a> and 32.3.8.2 <a href="https://wg21.link/stoptoken.inplace.mem">[stoptoken.inplace.mem]</a>) and to 
<code class='backtick'>inplace_stop_source::stop_requested()</code> (in 32.3.9.1 <a href="https://wg21.link/stopsource.inplace.general">[stopsource.inplace.general]</a> and 
32.3.9.3 <a href="https://wg21.link/stopsource.inplace.mem">[stopsource.inplace.mem]</a>)]
</p>
</blockquote>

<ol>

<li><p>Modify 32.3.8.1 <a href="https://wg21.link/stoptoken.inplace.general">[stoptoken.inplace.general]</a>, class <code class='backtick'>inplace_stop_token</code> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
  class inplace_stop_token {
  public:
    template&lt;class CallbackFn&gt;
      using callback_type = inplace_stop_callback&lt;CallbackFn&gt;;
    
    <ins>constexpr</ins> inplace_stop_token() = default;
    <ins>constexpr</ins> bool operator==(const inplace_stop_token&amp;) const = default;
    
    // <i>32.3.8.2 <a href="https://wg21.link/stoptoken.inplace.mem">[stoptoken.inplace.mem]</a>, member functions</i>
    bool stop_requested() const noexcept;
    <ins>constexpr</ins> bool stop_possible() const noexcept;
    <ins>constexpr</ins> void swap(inplace_stop_token&amp;) noexcept;
    
  private:
    const inplace_stop_source* <i>stop-source</i> = nullptr; // <i>exposition only</i>
  };
}
</pre></blockquote>

</li>


<li><p>Modify 32.3.8.2 <a href="https://wg21.link/stoptoken.inplace.mem">[stoptoken.inplace.mem]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i>: As a drive-by fix this adds the missing return type <code class='backtick'>bool</code> to the
<code class='backtick'>stop_possible()</code> prototype]
</p>
</blockquote>

<blockquote>
<pre>
<ins>constexpr</ins> void swap(inplace_stop_token&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Exchanges the values of <code><i>stop-source</i></code> and <code>rhs.<i>stop-source</i></code>.
</p>
</blockquote>
[&hellip;]
<pre>
<ins>constexpr bool</ins> stop_possible() const noexcept;
</pre>
<blockquote>
<p>
-4- <i>Returns</i>: <code><i>stop-source</i> != nullptr</code>.
</p>
</blockquote>

</blockquote>

</li>

</ol>





<hr>
<h3 id="4366"><a href="#4366">4366</a><sup><a href="https://cplusplus.github.io/LWG/issue4366">(i)</a></sup>. Heterogeneous comparison of <code class='backtick'>expected</code> may be ill-formed</h3>
<p><b>Section:</b> 22.8.6.8 <a href="https://wg21.link/expected.object.eq">[expected.object.eq]</a>, 22.8.7.8 <a href="https://wg21.link/expected.void.eq">[expected.void.eq]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-06 <b>Last modified:</b> 2025-10-16</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
These comparison functions all explicitly <code class='backtick'>static_cast</code> the result of the underlying comparison to
<code class='backtick'>bool</code>. However, the <i>Constraints</i> only require the implicit conversion, not the explicit one 
(i.e., "convertible to <code class='backtick'>bool</code>" rather than "models <code><i>boolean-testable</i></code>").
<p/>
This means that in some pathological cases it will lead to hard errors 
(<a href="https://godbolt.org/z/b9ehzv3h4">demo</a>):
</p>
<blockquote><pre>
#include &lt;expected&gt;

struct E1 {};
struct E2 {};

struct Bool {
  operator bool() const;
  explicit operator bool() = delete;
};
Bool operator==(E1, E2);

int main() {
  std::unexpected e1{E1{}};
  std::unexpected e2{E2{}};
  return std::expected&lt;int, E1&gt;{e1} == e2; // <span style="color:#C80000;font-weight:bold">fire</span>
}
</pre></blockquote>
<p>
It is reasonable to specify return consistency with actual <i>Constraints</i>.
</p>

<p><i>[2025-10-16; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>
<p>
Related to LWG <a href="lwg-active.html#4366" title="Heterogeneous comparison of expected may be ill-formed (Status: Tentatively Ready)">4366</a><sup><a href="https://cplusplus.github.io/LWG/issue4366" title="Latest snapshot">(i)</a></sup>, but the wording styles are inconsistent.
<code class='backtick'>optional</code> uses "<i>Effects</i>: Equivalent to ..." and <code class='backtick'>expected</code> just uses
<i>Returns</i>:.
</p>



<p id="res-4366"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>

<li><p>Modify 22.8.6.8 <a href="https://wg21.link/expected.object.eq">[expected.object.eq]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T2&gt; friend constexpr bool operator==(const expected&amp; x, const T2&amp; v);
</pre>
<blockquote>
<p>
-3- <i>Constraints</i>: <code class='backtick'>T2</code> is not a specialization of <code class='backtick'>expected</code>. The expression <code class='backtick'>*x == v</code> is well-formed
and its result is convertible to <code class='backtick'>bool</code>.
<p/>
[<i>Note 1</i>: <code>T</code> need not be <i>Cpp17EqualityComparable</i>. &mdash; <i>end note</i>]
<p/>
-4- <i>Returns</i>: <ins>If</ins> <code class='backtick'>x.has_value()</code> <ins>is <code class='backtick'>true</code>,</ins>
<code><del>&amp;&amp; static_cast&lt;bool&gt;(</del>*x == v<del>)</del></code><ins>; otherwise <code class='backtick'>false</code></ins>.
</p>
</blockquote>
<pre>
template&lt;class E2&gt; friend constexpr bool operator==(const expected&amp; x, const unexpected&lt;E2&gt;&amp; e);
</pre>
<blockquote>
<p>
-5- <i>Constraints</i>: The expression <code class='backtick'>x.error() == e.error()</code> is well-formed and its result is convertible 
to <code class='backtick'>bool</code>.
<p/>
-6- <i>Returns</i>: <ins>If</ins> <code class='backtick'>!x.has_value()</code> <ins>is <code class='backtick'>true</code>,</ins>
<code><del>&amp;&amp; static_cast&lt;bool&gt;(</del>x.error() == e.error()<del>)</del></code><ins>; otherwise <code class='backtick'>false</code></ins>.
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 22.8.7.8 <a href="https://wg21.link/expected.void.eq">[expected.void.eq]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T2, class E2&gt; requires is_void_v&lt;T2&gt;
  friend constexpr bool operator==(const expected&amp; x, const expected&lt;T2, E2&gt;&amp; y);
</pre>
<blockquote>
<p>
-1- <i>Constraints</i>: The expression <code class='backtick'>x.error() == y.error()</code> is well-formed and its result 
is convertible to <code class='backtick'>bool</code>.
<p/>
-2- <i>Returns</i>: If <code class='backtick'>x.has_value()</code> does not equal <code class='backtick'>y.has_value()</code>, <code class='backtick'>false</code>; 
otherwise <ins>if</ins> <code class='backtick'>x.has_value()</code> <ins>is <code class='backtick'>true</code>, <code class='backtick'>true</code>; otherwise</ins>
<code><del>|| static_cast&lt;bool&gt;(</del>x.error() == y.error()<del>)</del></code>.
</p>
</blockquote>
<pre>
template&lt;class E2&gt;
  friend constexpr bool operator==(const expected&amp; x, const unexpected&lt;E2&gt;&amp; e);
</pre>
<blockquote>
<p>
-3- <i>Constraints</i>: The expression <code class='backtick'>x.error() == e.error()</code> is well-formed and its 
result is convertible to <code class='backtick'>bool</code>.
<p/>
-4- <i>Returns</i>: <ins>If</ins> <code class='backtick'>!x.has_value()</code> <ins>is <code class='backtick'>true</code>,</ins>
<code><del>&amp;&amp; static_cast&lt;bool&gt;(</del>x.error() == e.error()<del>)</del></code>
<ins>; otherwise <code class='backtick'>false</code></ins>.
</p>
</blockquote>
</blockquote>

</li>

</ol>




<hr>
<h3 id="4370"><a href="#4370">4370</a><sup><a href="https://cplusplus.github.io/LWG/issue4370">(i)</a></sup>. Comparison of <code>optional&lt;T&gt;</code> to <code>T</code> may be ill-formed</h3>
<p><b>Section:</b> 22.5.9 <a href="https://wg21.link/optional.comp.with.t">[optional.comp.with.t]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-06 <b>Last modified:</b> 2025-10-16</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.comp.with.t">issues</a> in [optional.comp.with.t].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When comparing an <code class='backtick'>optional</code> with its value type, the current wording specifies that the result is the
ternary expression of <code class='backtick'>x.has_value() ? *x == v : false</code>, where <code class='backtick'>*x == v</code> returns a result that can be 
implicitly converted to <code class='backtick'>bool</code>.
<p/>
However, when the result can also be constructed using <code class='backtick'>bool</code> (which is common), the ternary operation
will be ill-formed due to ambiguity (<a href="https://godbolt.org/z/r55Wh51Y8">demo</a>):
</p>
<blockquote><pre>
#include &lt;optional&gt;

struct Bool {
  Bool(bool);
  operator bool() const;
};

struct S {
  Bool operator==(S) const;
};

int main() {
  return std::optional&lt;S&gt;{} == S{}; // <span style="color:#C80000;font-weight:bold">fire</span>
}
</pre></blockquote>

<p><i>[2025-10-16; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>
<p>
"Alternatively could keep the conditional operator but cast one side to <code class='backtick'>bool</code>,
but that would do an explicit conversion, which might not be what we want."
</p>
<p>
"Should just require <i>boolean-testable</i>."
</p>
<p>
Related to LWG <a href="lwg-active.html#4366" title="Heterogeneous comparison of expected may be ill-formed (Status: Tentatively Ready)">4366</a><sup><a href="https://cplusplus.github.io/LWG/issue4366" title="Latest snapshot">(i)</a></sup>.
</p>



<p id="res-4370"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>

<li><p>Modify 22.5.9 <a href="https://wg21.link/optional.comp.with.t">[optional.comp.with.t]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; x, const U&amp; v);
</pre>
<blockquote>
<p>
-1- <i>Constraints</i>: <code class='backtick'>U</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code class='backtick'>*x == v</code> is well-formed
   and its result is convertible to <code class='backtick'>bool</code>.
<p/>
[<i>Note 1</i>: <code class='backtick'>T</code> need not be <i>Cpp17EqualityComparable</i>. &mdash; end note]
<p/>
-2- <i>Effects</i>: Equivalent to: <del><code class='backtick'>return x.has_value() ? *x == v : false;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return *x == v;
return false;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator==(const T&amp; v, const optional&lt;U&gt;&amp; x);
</pre>
<blockquote>
<p>
-3- <i>Constraints</i>: <code class='backtick'>T</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code class='backtick'>v == *x</code> is well-formed
and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-4- <i>Effects</i>: Equivalent to: <del><code class='backtick'>return x.has_value() ? v == *x : false;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return v == *x;
return false;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp; x, const U&amp; v);
</pre>
<blockquote>
<p>
-5- <i>Constraints</i>: <code class='backtick'>U</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code class='backtick'>*x != v</code> is well-formed
and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-6- <i>Effects</i>: Equivalent to: <del><code class='backtick'>return x.has_value() ? *x != v : true;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return *x != v;
return true;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator!=(const T&amp; v, const optional&lt;U&gt;&amp; x);
</pre>
<blockquote>
<p>
-7- <i>Constraints</i>: <code class='backtick'>T</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code class='backtick'>v != *x</code> is well-formed
and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-8- <i>Effects</i>: Equivalent to: <del><code class='backtick'>return x.has_value() ? v != *x : true;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return v != *x;
return true;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; x, const U&amp; v);
</pre>
<blockquote>
<p>
-9- <i>Constraints</i>: <code class='backtick'>U</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code>*x &lt; v</code> is well-formed
and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-10- <i>Effects</i>: Equivalent to: <del><code>return x.has_value() ? *x &lt; v : true;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return *x &lt; v;
return true;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&lt;(const T&amp; v, const optional&lt;U&gt;&amp; x);
</pre>
<blockquote>
<p>
-11- <i>Constraints</i>: <code class='backtick'>T</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code>v &lt; *x</code> 
is well-formed and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-12- <i>Effects</i>: Equivalent to: <del><code>return x.has_value() ? v &lt; *x : false;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return v &lt; *x;
return false;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp; x, const U&amp; v);
</pre>
<blockquote>
<p>
-13- <i>Constraints</i>: <code class='backtick'>U</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code>*x &gt; v</code> is 
well-formed and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-14- <i>Effects</i>: Equivalent to: <del><code>return x.has_value() ? *x &gt; v : false;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return *x &gt; v;
return false;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&gt;(const T&amp; v, const optional&lt;U&gt;&amp; x);
</pre>
<blockquote>
<p>
-15- <i>Constraints</i>: <code class='backtick'>T</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code>v &gt; *x</code> 
is well-formed and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-16- <i>Effects</i>: Equivalent to: <del><code>return x.has_value() ? v &gt; *x : true;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return v &gt; *x;
return true;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; x, const U&amp; v);
</pre>
<blockquote>
<p>
-17- <i>Constraints</i>: <code class='backtick'>U</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code>*x &lt;= v</code> 
is well-formed and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-18- <i>Effects</i>: Equivalent to: <del><code>return x.has_value() ? *x &lt;= v : true;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return *x &lt;= v;
return true;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&lt;=(const T&amp; v, const optional&lt;U&gt;&amp; x);
</pre>
<blockquote>
<p>
-19- <i>Constraints</i>: <code class='backtick'>T</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code>v &lt;= *x</code> 
is well-formed and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-20- <i>Effects</i>: Equivalent to: <del><code>return x.has_value() ? v &lt;= *x : false;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return v &lt;= *x;
return false;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; x, const U&amp; v);
</pre>
<blockquote>
<p>
-21- <i>Constraints</i>: <code class='backtick'>U</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code>*x &gt;= v</code> 
is well-formed and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-22- <i>Effects</i>: Equivalent to: <del><code>return x.has_value() ? *x &gt;= v : false;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return *x &gt;= v;
return false;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&gt;=(const T&amp; v, const optional&lt;U&gt;&amp; x);
</pre>
<blockquote>
<p>
-23- <i>Constraints</i>: <code class='backtick'>T</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code>v &gt;= *x</code> 
is well-formed and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-24- <i>Effects</i>: Equivalent to: <del><code>return x.has_value() ? v &gt;= *x : true;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return v &gt;= *x;
return true;</ins>
</pre></blockquote>
</blockquote>

</blockquote>

</li>

</ol>




<hr>
<h3 id="4372"><a href="#4372">4372</a><sup><a href="https://cplusplus.github.io/LWG/issue4372">(i)</a></sup>. Weaken <i>Mandates:</i> for dynamic padding values in padded layouts</h3>
<p><b>Section:</b> 23.7.3.4.8.1 <a href="https://wg21.link/mdspan.layout.leftpad.overview">[mdspan.layout.leftpad.overview]</a>, 23.7.3.4.9.1 <a href="https://wg21.link/mdspan.layout.rightpad.overview">[mdspan.layout.rightpad.overview]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Luc Grosheintz <b>Opened:</b> 2025-09-09 <b>Last modified:</b> 2025-10-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Two new layouts were added to <code>&lt;mdspan&gt;</code> in C++26. Both have a template
parameter <code class='backtick'>size_t PaddingValue</code>. This value is allowed to be <code class='backtick'>std::dynamic_extent</code> 
to signal that the padding value isn't known at compile time.
<p/>
A class <i>Mandates:</i> element (in 23.7.3.4.8.1 <a href="https://wg21.link/mdspan.layout.leftpad.overview">[mdspan.layout.leftpad.overview]</a> (5.2)
and 23.7.3.4.9.1 <a href="https://wg21.link/mdspan.layout.rightpad.overview">[mdspan.layout.rightpad.overview]</a> (5.2), respectively) requires 
(unconditionally) that
</p>
<ul>
<li><p><code class='backtick'>PaddingValue</code> is representable as a value of <code class='backtick'>index_type</code>.</p></li>
</ul>
<p>
Since <code class='backtick'>std::dynamic_extent</code> is defined as <code class='backtick'>size_t(-1)</code> (in 23.7.2.1 <a href="https://wg21.link/span.syn">[span.syn]</a>)
this immediately prohibits all dynamically padded layout mappings for
any <code class='backtick'>index_type</code> for which:
</p>
<blockquote><pre>
numeric_limit&lt;index_type&gt;::max() &lt; numeric_limit&lt;size_t&gt;::max()
</pre></blockquote>
<p>
One example is <code class='backtick'>int</code> on a 64-bit system.
<p/>
The proposed resolution states that the modified representability
<i>Mandates:</i> element holds for <code>rank &lt;= 1</code>, even though in that case the 
<code class='backtick'>PaddingValue</code> has no other effect. Hence, the <i>Mandates:</i> element could 
be weakened further.
</p>

<p><i>[2025-10-17; Reflector poll.]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>
<p>
"This matches the wording in 23.7.3.3.1 <a href="https://wg21.link/mdspan.extents.overview">[mdspan.extents.overview]</a> 1.2"
</p>


<p id="res-4372"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>

<li><p>Modify 23.7.3.4.8.1 <a href="https://wg21.link/mdspan.layout.leftpad.overview">[mdspan.layout.leftpad.overview]</a> as indicated:</p>

<blockquote>
<p>
-5- <i>Mandates</i>:
</p>
<ol style="list-style-type: none">
<li><p>(5.1) &mdash; [&hellip;]</p></li>
<li><p>(5.2) &mdash; <ins>if <code class='backtick'>padding_value</code> is not equal to <code class='backtick'>dynamic_extent</code>, then</ins> 
<code class='backtick'>padding_value</code> is representable as a value of type <code class='backtick'>index_type</code>.</p></li>
<li><p>(5.3) &mdash; [&hellip;]</p></li>
<li><p>(5.4) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>

</li>

<li><p>Modify 23.7.3.4.9.1 <a href="https://wg21.link/mdspan.layout.rightpad.overview">[mdspan.layout.rightpad.overview]</a> as indicated:</p>

<blockquote>
<p>
-5- <i>Mandates</i>:
</p>
<ol style="list-style-type: none">
<li><p>(5.1) &mdash; [&hellip;]</p></li>
<li><p>(5.2) &mdash; <ins>if <code class='backtick'>padding_value</code> is not equal to <code class='backtick'>dynamic_extent</code>, then</ins> 
<code class='backtick'>padding_value</code> is representable as a value of type <code class='backtick'>index_type</code>.</p></li>
<li><p>(5.3) &mdash; [&hellip;]</p></li>
<li><p>(5.4) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>

</li>

</ol>




<hr>
<h3 id="4377"><a href="#4377">4377</a><sup><a href="https://cplusplus.github.io/LWG/issue4377">(i)</a></sup>. Misleading note about lock-free property of <code class='backtick'>std::atomic_ref</code></h3>
<p><b>Section:</b> 32.5.7.2 <a href="https://wg21.link/atomics.ref.ops">[atomics.ref.ops]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Brian Bi <b>Opened:</b> 2025-09-15 <b>Last modified:</b> 2025-10-20</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.ref.ops">active issues</a> in [atomics.ref.ops].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.ref.ops">issues</a> in [atomics.ref.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Note 1 to 32.5.7.2 <a href="https://wg21.link/atomics.ref.ops">[atomics.ref.ops]</a> states:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
Hardware could require an object referenced by an <code class='backtick'>atomic_ref</code> to have stricter alignment 
(6.8.3 <a href="https://wg21.link/basic.align">[basic.align]</a>) than other objects of type <code class='backtick'>T</code>. Further, whether operations 
on an <code class='backtick'>atomic_ref</code> are lock-free could depend on the alignment of the referenced object. 
For example, lock-free operations on <code>std::complex&lt;double&gt;</code> could be supported 
only if aligned to <code class='backtick'>2*alignof(double)</code>.
</p>
</blockquote>
<p>
By using the word "Further", the note misleadingly implies that <code class='backtick'>required_alignment</code> may 
need to be greater than <code class='backtick'>alignof(T)</code> even before considering lock freedom, i.e., that 
<code>std::atomic_ref&lt;T&gt;</code> may be completely unimplementable on given hardware if 
the stricter alignment requirement is not met. However, that can never be true because 
falling back to a lock-based implementation is always possible.
<p/>
The note could also be misinterpreted to imply that even though an object may be aligned to 
<code class='backtick'>required_alignment</code> and thus referenceable by an <code class='backtick'>atomic_ref</code>, operations could still fail 
to be lock-free because there is a stricter alignment requirement that the object does not 
meet. Such an interpretation is, however, at odds with p4.
<p/>
The example given by the note is also confusing in that it does not necessarily demonstrate 
a situation in which <code>std::atomic_ref&lt;T&gt;::required_alignment</code> is greater than 
<code class='backtick'>alignof(T)</code>.
<p/>
In conclusion, this note appears to be a convoluted way of saying that, in order to ensure 
that operations on <code>atomic_ref&lt;T&gt;</code> are lock-free, the implementation may 
define <code class='backtick'>required_alignment</code> to a value greater than <code class='backtick'>alignof(T)</code>. The note should be 
modified to say this much more clearly.
</p>

<p><i>[2025-10-20; Reflector poll.]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
Also ask SG1 to take a look.
</p>


<p id="res-4377"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>


<li><p>Modify 32.5.7.2 <a href="https://wg21.link/atomics.ref.ops">[atomics.ref.ops]</a> as indicated:</p>

<blockquote>
<pre>
static constexpr size_t required_alignment;
</pre>
<blockquote>
<p>
-1- The alignment required for an object to be referenced by an atomic reference, which is at least
<code class='backtick'>alignof(T)</code>.
<p/>
-2- [<i>Note 1</i>: <del>Hardware could require an object referenced by an <code class='backtick'>atomic_ref</code> to have stricter 
alignment (6.8.3 <a href="https://wg21.link/basic.align">[basic.align]</a>) than other objects of type <code class='backtick'>T</code>. Further, whether operations 
on an <code class='backtick'>atomic_ref</code> are lock-free could depend on the alignment of the referenced object. For example, 
lock-free operations on <code>std::complex&lt;double&gt;</code> could be supported only if aligned to 
<code class='backtick'>2*alignof(double)</code></del><ins>An implementation can choose to define 
<code>atomic_ref&lt;T&gt;::required_alignment</code> to a value greater than <code class='backtick'>alignof(T)</code> in order to 
ensure that operations on all objects of type <code>atomic_ref&lt;T&gt;</code> are lock-free</ins>. 
&mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4391"><a href="#4391">4391</a><sup><a href="https://cplusplus.github.io/LWG/issue4391">(i)</a></sup>. Ambiguities of <code class='backtick'>simd::basic_vec</code> constructor</h3>
<p><b>Section:</b> 29.10.7.2 <a href="https://wg21.link/simd.ctor">[simd.ctor]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-29 <b>Last modified:</b> 2025-10-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#simd.ctor">active issues</a> in [simd.ctor].</p>
<p><b>View all other</b> <a href="lwg-index.html#simd.ctor">issues</a> in [simd.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The broadcasting, generator-based, and range constructors of <code class='backtick'>simd::basic_vec</code> all take a single
argument, and their constraints are not mutually exclusive.
<p/>
This means that when a type satisfies both characteristics, such as a range that can be converted to a
<code class='backtick'>value_type</code>, this will lead to ambiguity:
</p>
<blockquote>
<pre>
#include &lt;simd&gt;

struct S {
  operator double() const;       // basic_vec(U&amp;&amp; value)
  
  double operator()(int) const;  // basic_vec(G&amp;&amp; gen)

  double* begin() const;         // basic_vec(R&amp;&amp; r, flags&lt;Flags...&gt; = {});
  double* end() const;
  constexpr static int size() { return 2; }
};

int main() {
  std::simd::vec&lt;double&gt; simd(S{}); // <span style="color:#C80000;font-weight:bold">error: call of overloaded 'basic_simd(S)' is ambiguous</span>
}
</pre>
</blockquote>
<p>
Do we need more constraints, similar to the one in <code>string_view(R&amp;&amp; r)</code> that requires
<code class='backtick'>R</code> not to be convertible to <code class='backtick'>const char*</code>, to make the above work, i.e., only invoke the
broadcasting constructor?
</p>

<p><i>[2025-10-17; Reflector poll. Status changed: New &rarr; Tentatively NAD.]</i></p>

<p>
Users of such types should do disambiguation explicitly, <code class='backtick'>basic_vec</code> should not guess what they mean.
</p>


<p id="res-4391"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>


<li><p>Modify 29.10.7.2 <a href="https://wg21.link/simd.ctor">[simd.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class G&gt; constexpr explicit basic_vec(G&amp;&amp; gen);
</pre>
<blockquote>
<p>
-8- Let <code>From<sub><i>i</i></sub></code> denote the type
   <code>decltype(gen(integral_constant&lt;<i>simd-size-type</i>, <i>i</i>&gt;()))</code>.
<p/>
-9- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
   <li><p>
   <ins>(9.?) &mdash; <code>constructible_from&lt;value_type, G&gt;</code> is <code>false</code>.</ins>
   </p></li>
   <li><p>
    <ins>(9.?) &mdash;</ins>
    <code>From<sub><i>i</i></sub></code> satisfies <code>convertible_to&lt;value_type&gt;</code> for all 
    <code><i>i</i></code> in the range of [<code>0, size()</code>). In addition, for all <i>i</i> in the range of
    [<code>0, size()</code>), if <code>From<sub><i>i</i></sub></code> is an arithmetic type, conversion from 
    <code>From<sub><i>i</i></sub></code> to <code>value_type</code> is value-preserving.</p>
   </li>
</ol>
</blockquote>
[&hellip;]
<pre>
template&lt;class R, class... Flags&gt;
  constexpr basic_vec(R&amp;&amp; r, flags&lt;Flags...&gt; = {});
template&lt;class R, class... Flags&gt;
  constexpr basic_vec(R&amp;&amp; r, const mask_type&amp; mask, flags&lt;Flags...&gt; = {});
</pre>
<blockquote>
<p>
-12- Let mask be <code class='backtick'>mask_type(true)</code> for the overload with no <code class='backtick'>mask</code> parameter.
<p/>
-13- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
   <li><p>
   (13.1) &mdash; <code class='backtick'>R</code> models <code class='backtick'>ranges::contiguous_range</code> and <code class='backtick'>ranges::sized_range</code>,
   </p></li>
   <li><p>
   (13.2) &mdash; <code class='backtick'>ranges::size(r)</code> is a constant expression, <del>and</del>
   </p></li>
   <li><p>
   (13.3) &mdash; <code class='backtick'>ranges::size(r)</code> is equal to <code class='backtick'>size()</code><del>.</del><ins>,</ins>
   </p></li>
   <li><p>
   <ins>(13.?) &mdash; <code>constructible_from&lt;value_type, R&gt;</code> is <code class='backtick'>false</code>, and</ins>
   </p></li>
   <li><p>
   <ins>(13.?) &mdash; <code>r(integral_constant&lt;<i>simd-size-type</i>, 0&gt;())</code> is not a valid
            expression.</ins>
   </p></li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4398"><a href="#4398">4398</a><sup><a href="https://cplusplus.github.io/LWG/issue4398">(i)</a></sup>. <code class='backtick'>enable_nonlocking_formatter_optimization</code> should be disabled for container adaptors</h3>
<p><b>Section:</b> 23.6.2 <a href="https://wg21.link/queue.syn">[queue.syn]</a>, 23.6.5 <a href="https://wg21.link/stack.syn">[stack.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tomasz Kamiński <b>Opened:</b> 2025-10-02 <b>Last modified:</b> 2025-10-17</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As the standard currently defines formatters for <code class='backtick'>queue</code>, <code class='backtick'>prioriy_queue</code>, and <code class='backtick'>stack</code>  
<code class='backtick'>enable_nonlocking_formatter_optimization</code> is specialized to <code class='backtick'>true</code> for these adaptors per 
28.5.6.4 <a href="https://wg21.link/format.formatter.spec">[format.formatter.spec]</a> p3:
</p>
<blockquote>
<p>
Unless specified otherwise, for each type <code class='backtick'>T</code> for which a formatter specialization is provided 
by the library, each of the headers provides the following specialization: 
</p>
<blockquote><pre>
template&lt;&gt; inline constexpr bool enable_nonlocking_formatter_optimization&lt;T&gt; = true;
</pre></blockquote>
</blockquote>
<p>
However, formatting an adaptor requires formatting of the underlying range
in terms of <code class='backtick'>ranges::ref_view</code>, and we disable the nonlocking_optimizations for all ranges, including <code class='backtick'>ranges::ref_view</code>.
<p/>
This problem does not occur for the <code class='backtick'>flat_set</code>, <code class='backtick'>flat_map</code> adaptors, which are
also ranges, but unlike <code class='backtick'>stack</code> etc. they do not have a specialized formatter.
They use the <code class='backtick'>formatter</code> specialization for ranges and we already disable the
optimization for that formatter.
<p/>
The proposed wording has recently been implemented in 
<a href="https://gcc.gnu.org/pipermail/libstdc++/2025-October/063758.html">gcc's libstdc++</a>.
</p>

<p><i>[2025-10-14; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>
<p>
This is a duplicate of LWG <a href="lwg-active.html#4146" title="&sect;[format.formatter.spec]/3 unconditionally enables nonlocking for container adaptors (Status: New)">4146</a><sup><a href="https://cplusplus.github.io/LWG/issue4146" title="Latest snapshot">(i)</a></sup>,
with a different proposed resolution.
</p>


<p><i>[2025-10-17; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-4398"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>

<li><p>Modify 23.6.2 <a href="https://wg21.link/queue.syn">[queue.syn]</a>, header <code>&lt;queue&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
// <i>23.6.13 <a href="https://wg21.link/container.adaptors.format">[container.adaptors.format]</a>, formatter specialization for queue</i>
template&lt;class charT, class T, formattable&lt;charT&gt; Container&gt;
  struct formatter&lt;queue&lt;T, Container&gt;, charT&gt;;
  
<ins>template&lt;class T, class Container&gt;
  constexpr bool enable_nonlocking_formatter_optimization&lt;queue&lt;T, Container&gt;&gt; = false;</ins>

// <i>23.6.4 <a href="https://wg21.link/priority.queue">[priority.queue]</a>, class template priority_queue</i>
template&lt;class T, class Container = vector&lt;T&gt;,
         class Compare = less&lt;typename Container::value_type&gt;&gt;
  class priority_queue;
[&hellip;]
// <i>23.6.13 <a href="https://wg21.link/container.adaptors.format">[container.adaptors.format]</a>, formatter specialization for priority_queue</i>
template&lt;class charT, class T, formattable&lt;charT&gt; Container, class Compare&gt;
  struct formatter&lt;priority_queue&lt;T, Container, Compare&gt;, charT&gt;;
  
<ins>template&lt;class T, class Container, class Compare&gt;
  constexpr bool enable_nonlocking_formatter_optimization&lt;priority_queue&lt;T, Container, Compare&gt;&gt; = false;</ins>
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.6.5 <a href="https://wg21.link/stack.syn">[stack.syn]</a>, header <code>&lt;stack&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]

// <i>23.6.13 <a href="https://wg21.link/container.adaptors.format">[container.adaptors.format]</a>, formatter specialization for stack</i>
template&lt;class charT, class T, formattable&lt;charT&gt; Container&gt;
  struct formatter&lt;stack&lt;T, Container&gt;, charT&gt;;

<ins>template&lt;class T, class Container&gt;
  constexpr bool enable_nonlocking_formatter_optimization&lt;stack&lt;T, Container&gt;&gt; = false;</ins>

[&hellip;]
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4399"><a href="#4399">4399</a><sup><a href="https://cplusplus.github.io/LWG/issue4399">(i)</a></sup>. <code class='backtick'>enable_nonlocking_formatter_optimization</code> for <code class='backtick'>pair</code> and <code class='backtick'>tuple</code> needs <code class='backtick'>remove_cvref_t</code></h3>
<p><b>Section:</b> 28.5.9 <a href="https://wg21.link/format.tuple">[format.tuple]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tomasz Kamiński <b>Opened:</b> 2025-10-02 <b>Last modified:</b> 2025-10-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code class='backtick'>enable_nonlocking_formatter_optimization</code> variable template is specialized only for <i>cv</i>-unqualified 
types. However, the specialization for <code class='backtick'>pair</code> and <code class='backtick'>tuple</code> does not remove the references and 
<i>cv</i>-qualifiers from the elements:
</p>
<blockquote><pre>
template&lt;class... Ts&gt; 
  constexpr bool enable_nonlocking_formatter_optimization&lt;<i>pair-or-tuple</i>&lt;Ts...&gt;&gt; = 
    (enable_nonlocking_formatter_optimization&lt;Ts&gt; &amp;&amp; ...);
</pre></blockquote>
<p>
As consequence <code>pair&lt;const std::string, int&gt;</code> or 
<code>pair&lt;const std::string&amp;, int&amp;&gt;</code> (<code class='backtick'>map</code> and <code class='backtick'>flat_map</code> reference types) 
will not use unbuffered prints.
<p/>
The proposed wording has recently been implemented in 
<a href="https://gcc.gnu.org/pipermail/libstdc++/2025-October/063758.html">gcc's libstdc++</a>.
</p>

<p><i>[2025-10-17; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-4399"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>

<li><p>Modify 28.5.9 <a href="https://wg21.link/format.tuple">[format.tuple]</a> as indicated:</p>

<blockquote>
<p>
-1- For each of <code class='backtick'>pair</code> and <code class='backtick'>tuple</code>, the library provides the following formatter specialization 
where <code><i>pair-or-tuple</i></code> is the name of the template:
</p>
<blockquote>
<pre>
namespace std {
  [&hellip;]
  
  template&lt;class... Ts&gt; 
    constexpr bool enable_nonlocking_formatter_optimization&lt;<i>pair-or-tuple</i>&lt;Ts...&gt;&gt; = 
      (enable_nonlocking_formatter_optimization&lt;<ins>remove_cvref_t&lt;</ins>Ts<ins>&gt;</ins>&gt; &amp;&amp; ...);
}
</pre>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4403"><a href="#4403">4403</a><sup><a href="https://cplusplus.github.io/LWG/issue4403">(i)</a></sup>. <code class='backtick'>simd::basic_vec</code> CTAD misses difference type casting</h3>
<p><b>Section:</b> 29.10.7.2 <a href="https://wg21.link/simd.ctor">[simd.ctor]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-10-04 <b>Last modified:</b> 2025-10-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#simd.ctor">active issues</a> in [simd.ctor].</p>
<p><b>View all other</b> <a href="lwg-index.html#simd.ctor">issues</a> in [simd.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code class='backtick'>basic_vec</code> can take an object <code class='backtick'>r</code> of range type <code class='backtick'>R</code> whose size is a
constant expression and deduced to <code>vec&lt;ranges::range_value_t&lt;R&gt;, ranges::size(r)&gt;</code>.
<p/>
However, such a deduced type is ill-formed when <code class='backtick'>R</code> has a an integer-class type size which cannot
be implicitly converted to <code><i>simd-size-type</i></code>, which is a signed integer type.
<p/>
It is necessary to perform difference type casting here, and the narrowing
conversion will still correctly be rejected due to the constructor's constraints.
</p>

<p><i>[2025-10-17; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-4403"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>

<li><p>Modify 29.10.7.2 <a href="https://wg21.link/simd.ctor">[simd.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class R, class... Ts&gt;
  basic_vec(R&amp;&amp; r, Ts...) -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
-17- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
  <li><p>
  (17.1) &mdash; <code class='backtick'>R</code> models <code class='backtick'>ranges::contiguous_range</code> and <code class='backtick'>ranges::sized_range</code>, and
  </p></li>
  <li><p>
  (17.2) &mdash; <code class='backtick'>ranges::size(r)</code> is a constant expression.
  </p></li>
</ol>
<p>
-18- <i>Remarks</i>: The deduced type is equivalent to <code>
vec&lt;ranges::range_value_t&lt;R&gt;, <ins>static_cast&lt;<i>simd-size-type</i>&gt;(</ins>ranges::size(r)<ins>)</ins>&gt;
</code>
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="4407"><a href="#4407">4407</a><sup><a href="https://cplusplus.github.io/LWG/issue4407">(i)</a></sup>. <code><i>constexpr-wrapper-like</i></code> needs <code class='backtick'>remove_cvref_t</code> in <code class='backtick'>simd::basic_vec</code>
constructor</h3>
<p><b>Section:</b> 29.10.7.2 <a href="https://wg21.link/simd.ctor">[simd.ctor]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-10-05 <b>Last modified:</b> 2025-10-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#simd.ctor">active issues</a> in [simd.ctor].</p>
<p><b>View all other</b> <a href="lwg-index.html#simd.ctor">issues</a> in [simd.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>decltype(From::value)</code> would be <code>const int&amp;</code> if <code class='backtick'>From</code> is a type of <code>std::cw&lt;42&gt;</code>, 
so the reference also needs to be removed for checking the arithmetic type.
</p>

<p><i>[2025-10-17; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-4407"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014">N5014</a>.
</p>

<ol>

<li><p>Modify 29.10.7.2 <a href="https://wg21.link/simd.ctor">[simd.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U&gt; constexpr explicit(<i>see below</i>) basic_vec(U&amp;&amp; value) noexcept;
</pre>
<blockquote>
<p>
-1- Let <code class='backtick'>From</code> denote the type <code>remove_cvref_t&lt;U&gt;</code>.
<p/>
[&hellip;]
<p/>
-4- <i>Remarks</i>:  The expression inside <code class='backtick'>explicit</code> evaluates to <code class='backtick'>false</code> if and only if <code class='backtick'>U</code> 
satisfies <code>convertible_to&lt;value_type&gt;</code>, and either
</p>
<ol style="list-style-type: none">
<li><p>
(4.1) &mdash; <code class='backtick'>From</code> is not an arithmetic type and does not satisfy <code><i>constexpr-wrapper-like</i></code>,
</p></li>
<li><p>
(4.2) &mdash; <code class='backtick'>From</code> is an arithmetic type and the conversion from <code class='backtick'>From</code> to <code class='backtick'>value_type</code> is 
value-preserving (29.10.1 <a href="https://wg21.link/simd.general">[simd.general]</a>), or
</p></li>
<li><p> 
(4.3) &mdash; <code class='backtick'>From</code> satisfies <code><i>constexpr-wrapper-like</i></code>, 
<code><ins>remove_cvref_t</ins><del>remove_const_t</del>&lt;decltype(From::value)&gt;</code> 
is an arithmetic type, and <code class='backtick'>From::value</code> is representable by <code class='backtick'>value_type</code>.
</p></li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>






</body>
</html>
